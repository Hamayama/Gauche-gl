\input texinfo  @c -*-texinfo-*-
@comment %**start of header
@c EN
@setfilename gauche-gl-refe.info
@settitle Gauche-gl : OpenGL binding for Gauche
@dircategory The Algorithmic Language Scheme
@direntry
* Gauche-gl Reference: (gauche-gl-refe.info).	Gauche OpenGL binding
@end direntry
@c JP
@setfilename gauche-gl-refj.info
@settitle Gauche-gl : OpenGL binding for Gauche
@dircategory The Algorithmic Language Scheme
@direntry
* Gauche-gl Reference (ja): (gauche-gl-refj.info).	Gauche OpenGL binding
@end direntry
@c COMMON
@comment %**end of header

@c $Id: gauche-gl-ref.texi,v 1.10 2003-02-11 13:44:33 shirok Exp $

@c module and class index
@defcodeindex md
@defcodeindex cl

@iftex
@finalout
@parskip 4pt plus 1pt
@end iftex

@titlepage
@c EN
@title Gauche-gl : OpenGL binding for Gauche
@c JP
@title Gauche-gl : OpenGL binding for Gauche
@c COMMON
@subtitle version @VERSION@
@author Shiro Kawai (shiro@@acm.org)

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2002-2003 Shiro Kawai (shiro@@acm.org)

@end titlepage

@node Top, Introduction, (dir), (dir)

@ifnottex
This is a reference manual of Gauche-gl, an OpenGL binding for the
Gauche Scheme implementation.
This manual is for version @VERSION@.
@end ifnottex

@c ======================================================================
@menu
* Introduction::                
* Installation::                
* Getting Started::             
* OpenGL API::                  
* GLU API::                     
* GLUT API::                    
* Vectors and matrices::        
* Indices::                     
@end menu

@node Introduction, Installation, Top, Top
@chapter Introduction
@c NODE はじめに

Gauche-gl is an extension module of Gauche Scheme implementation.
It provides the following modules:

@table @code
@item gl
The module that provides bindings to OpenGL API.
It covers almost all functions in OpenGL 1.2,
and most functions in GLU.
The functions are described in @ref{OpenGL API} and
@ref{GLU API}.
@item gl.glut
The module that provides bindings to most functions in GLUT.
The functions are described in @ref{GLUT API}.
@item gl.math3d
The module that provides vector and matrix calculations
optimized for 3D homogeneous coordinates.
The vector and matrix objects here can be directly passed to
Gauche-gl functions.
The functions are descrbied in @ref{Vectors and matrices}.
@end table

@c ======================================================================
@node Installation, Getting Started, Introduction, Top
@chapter Installation

Installing Gauche-gl is usually straightforward on Unix variants.
At the time of writing this Manual, Gauche-gl can't be complied
on Cygwin.

You have to have the following programs installed on your machine.
@itemize @bullet
@item
Gauche 0.6.7 or later
@item
OpenGL 1.1 equivalent library; the auther checked with Mesa 3.4
and NVidia's GLX driver.
@item
GLUT 3.7 or later.
@end itemize

The standard way to compile and install Gauche-gl is as follows:
@example
% gzcat Gauche-gl-@VERSION@.tgz | tar xf -
% cd Gauche-gl-@VERSION@
% ./configure
% make
% make test
% make install
@end example

The confiugre script figures out the location Gauche is installed,
and install Gauche-gl in the same place.

If you have GLUT installed in non-standard place, you have to
tell the configure script where it is.
@example
% ./configure --with-glut=DIR
@end example

It is reported that Mesa in FreeBSD ports is compiled with pthreads
enabled, and Gauche-gl can't be linked unless Gauche itself is
compiled with pthreads.  The configure script of Gauche prints
warning if you specify pthreads, but it is safe as far as you
don't call make-thread in your program.

@c ======================================================================
@node Getting Started, OpenGL API, Installation, Top
@chapter Getting Started

@menu
* GL calls in Scheme::          
* Using GLUT::                  
* Performance tips::            
@end menu

@node GL calls in Scheme, Using GLUT, Getting Started, Getting Started
@section GL calls in Scheme

I assume you have basic knowledge of OpenGL API.
Gauche-gl maps OpenGL calls to Scheme procedures
pretty straightforwardly.  For example, the very first
example of "OpenGL Programming Guide", the pseudo code
of OpenGL application, can be written in Gauche-gl like
this:

@example
(use gl)

(define (main args)
  (@i{initialize-a-window-please})

  (gl-clear-color 0.0 0.0 0.0 0.0)
  (gl-clear GL_COLOR_BUFFER_BIT)
  (gl-color 1.0 1.0 1.0)
  (gl-ortho 0.0 1.0 0.0 1.0 -1.0 1.0)
  (gl-begin* GL_POLYGON
    (gl-vertex 0.25 0.25 0.0)
    (gl-vertex 0.75 0.25 0.0)
    (gl-vertex 0.75 0.75 0.0)
    (gl-vertex 0.25 0.75 0.0)
    )
  (gl-flush)
  (@i{update-the-window-and-check-for-events})
  0)
@end example

Note that @i{initialize-a-window-please} and
@i{update-the-window-and-check-for-events} are function calls
dependent on the windowing system.  Gauche-gl comes with GLUT
binding and you can use it to do basic stuff.  In the separate
package Gauche-gtk, a binding to GtkGLExt is provided, which allows
you to do GL rendering inside Gtk widgets.

For the time being, let's focus on the pure GL part.

The mapping of GL call name is straightforward.
The mixed case names in OpenGL C API is expanded to hyphenated name,
e.g. @code{glClearColor} @result{} @code{gl-clear-color}.
OpenGL enums are mapped as is, e.g. 
@code{GL_POLYGON}.  (Note that Gauche is case-sensitive by default.
Also note the underscore, not hyphen, in constants).

A few convenience macros, such as @code{gl-begin*}, is defined.
There are straight bindings of @code{gl-begin} and @code{gl-end},
so you can write the drawing part in the same way as in C:
@example
  (gl-begin GL_POLYGON)
    (gl-vertex 0.25 0.25 0.0)
    (gl-vertex 0.75 0.25 0.0)
    (gl-vertex 0.75 0.75 0.0)
    (gl-vertex 0.25 0.75 0.0)
  (gl-end)
@end example

Actually @code{gl-begin*} macro expands into the above calls.
It's a matter of taste, but the macro version guarantees
begin and end match, and the syntax-aware editor can indent 
internal calls accordingly.

You might have noticed that the type suffix in C API
is not in Gauche binding.  The Scheme function figures out the
type of passed arguments and calls appropriate C API.
SRFI-4 uniform numeric vectors are used to represent
arrays of numbers.

@example
  (gl-vertex 1.0 2.0 3.0)    @result{} glVertex3d
  (gl-vertex '#f32(1.0 2.0)) @result{} glVertex2fv
  (gl-vertex '#s32(3 2 5))   @result{} glVertex3iv
@end example

Generally, passing uniform vectors is much more efficient than
giving individual numbers, for the former can eliminate
the cost of type checking and unboxing.

Some GL calls can also take @code{gl.math3d} primitive objects
such as @code{vector4f}, @code{point4f} or @code{matrix4f}
(@xref{Vectors and matrices}).   For example, you can pass
@code{point4f} object to @code{gl-vertex}, @code{vector4f} to
@code{gl-normal}, and @code{matrix4f} to @code{gl-mult-matrix}.
They are efficient since calculations on those types are
defined natively in @code{gl.math3d}, and passing it to GL call
doesn't cost unboxing.

Variables @code{GL_VERSION_1_1}, @code{GL_VERSION_1_2} and
@code{GL_VERSION_1_3}
may be defined and bound to #t if the platform on which
Gauche-gl is compiled supports OpenGL version 1.1, 1.2 or
1.3, respectively.  You can use @code{symbol-bound?} to check these
variables are bound.   You can also use @code{symbol-bound?} to
check the existence of extensions, such as @code{GL_ARB_multitexture}.

@node Using GLUT, Performance tips, GL calls in Scheme, Getting Started
@section Using GLUT

In order to make a runnable script, you need to use some
windowing system interface.  GLUT binding provides a simple
way for it.

Here is a complete runnable Scheme script, ported from
Example 1-2 in "OpenGL Programming Guide":

@example
(use gl)
(use gl.glut)

(define (disp)
  (gl-clear GL_COLOR_BUFFER_BIT)
  (gl-color '#f32(1.0 1.0 1.0))
  (gl-begin* GL_POLYGON
    (gl-vertex '#f32(0.25 0.25 0.0))
    (gl-vertex '#f32(0.75 0.25 0.0))
    (gl-vertex '#f32(0.75 0.75 0.0))
    (gl-vertex '#f32(0.25 0.75 0.0))
    )
  (gl-flush)
  )

(define (init)
  (gl-clear-color 0.0 0.0 0.0 0.0)
  (gl-matrix-mode GL_PROJECTION)
  (gl-load-identity)
  (gl-ortho 0.0 1.0 0.0 1.0 -1.0 1.0)
  )

(define (keyboard key x y)
  (cond
   ((= key 27) (exit 0))
   ))

(define (main args)
  (glut-init args)
  (glut-init-display-mode (logior GLUT_SINGLE GLUT_RGB))
  (glut-init-window-size 250 250)
  (glut-init-window-position 100 100)
  (glut-create-window "hello")
  (init)
  (glut-display-func disp)
  (glut-keyboard-func keyboard)
  (glut-main-loop)
  0)
@end example

The @code{(use gl.glut)} form loads GLUT binding.
The name mapping is the same as GL's: mixed case names to 
hyphenated names.

In order to handle various events, you can pass a closure
to @code{glut-display-func} etc.  In the keyboard and mouse
event callback, all arguments are integers.

There are more examples under the @file{examples/} directory
which uses GLUT.

@node Performance tips,  , Using GLUT, Getting Started
@section Performance tips

If you want to display millions of polygons in 30 fps, 
Gauche-gl is not for you.   Consider using implementations
that compiles into native code.   The purpose of Gauche-gl
is to provide reasonable performance for interactive development
and experiment.

However, if you know some tips, actually you can go quite far,
especially with recent processors and graphics chips.

@table @emph
@item Avoid alocation within the inner loop.
The functional (non-destructive) operations tend to return 
newly-allocated objects.
Use linear-update (destructive) versions instead,
such as @code{matrix-mul!}, @code{u8vector-add!}, etc,
whenever possible.
Pre-allocating temporary vectors is also effective.

@item Reduce the number of calls within the inner loop.
Vertex arrays are much better than calling @code{gl-vertex}
over and over.   Also consider using display lists if
you're displaying rigid objects.

@item Keep numbers within a uniform vector.
Every time you take a number out of a uniform vector
(or @code{<vector4f>} etc.), Gauche has to wrap the
number by a tag (boxing).  Also when you store a number
into a uniform vector, Gauche has to check the type
of the object, then strip a tag (unboxing).
Those are all overhead you wouldn't have if
you operate directly on uniform vectors (or @code{<vector4f>} etc).

@item Write extensions to accelerate.
If the above strategies are not enough, consider writing
computation-intensive part in C as an extension.
The easier way is to make C routines operate on uniform vectors,
which is essentially a pointer to an array of numbers from C,
and let Scheme handle higher-level data structures.
(It could be viewed like relations between a coprocessor and
a processor; the former does simple, iterative calculations
fast, and the latter handles complicated logic).
@end table

@c ======================================================================
@node OpenGL API, GLU API, Getting Started, Top
@chapter OpenGL API

@c ======================================================================
@node GLU API, GLUT API, OpenGL API, Top
@chapter GLU API

@c ======================================================================
@node GLUT API, Vectors and matrices, GLU API, Top
@chapter GLUT API

@c ----------------------------------------------------------------------
@menu
* GLUT window manipulation::    
* GLUT overlay::                
* GLUT menu API::               
* GLUT callbacks::              
* GLUT colormap::               
* GLUT state retrieval::        
* GLUT font::                   
* GLUT pre-built models::       
@end menu

@node GLUT window manipulation, GLUT overlay, GLUT API, GLUT API
@section GLUT window manipulation

@defun glut-init args
@end defun

@defun glut-init-display-mode mode
@end defun

@defvr {Constant} GLUT_RGB
@defvrx {Constant} GLUT_RGBA
@defvrx {Constant} GLUT_INDEX
@defvrx {Constant} GLUT_SINGLE
@defvrx {Constant} GLUT_DOUBLE
@defvrx {Constant} GLUT_ACCUM
@defvrx {Constant} GLUT_ALPHA
@defvrx {Constant} GLUT_DEPTH
@defvrx {Constant} GLUT_STENCIL
@defvrx {Constant} GLUT_MULTISAMPLE
@defvrx {Constant} GLUT_STEREO
@defvrx {Constant} GLUT_LUMINANCE
@end defvr

@defun glut-init-display-string string
@end defun

@defun glut-init-window-size width height
@end defun

@defun glut-init-window-position x y
@end defun

@defun glut-main-loop
@end defun

@defun glut-create-widnow name
@end defun

@defun glut-create-sub-window win x y width height
@end defun

@defun glut-destroy-window win
@end defun

@defun glut-post-redisplay
@end defun

@defun glut-post-window-redisplay win
@end defun

@defun glut-swap-buffers
@end defun

@defun glut-get-window
@end defun

@defun glut-set-window win
@end defun

@defun glut-set-window-title title
@end defun

@defun glut-set-icon-title title
@end defun

@defun glut-position-window x y
@end defun

@defun glut-reshape-window width height
@end defun

@defun glut-push-window
@defunx glut-pop-window
@end defun

@defun glut-iconify-window
@end defun

@defun glut-show-window
@defunx glut-hide-window
@end defun

@defun glut-full-screen
@end defun

@defun glut-set-cursor cursor
@end defun

@defvr {Constant} GLUT_CURSOR_RIGHT_ARROW
@defvrx {Constant} GLUT_CURSOR_LEFT_ARROW
@defvrx {Constant} GLUT_CURSOR_INFO
@defvrx {Constant} GLUT_CURSOR_DESTROY
@defvrx {Constant} GLUT_CURSOR_HELP
@defvrx {Constant} GLUT_CURSOR_CYCLE
@defvrx {Constant} GLUT_CURSOR_SPRAY
@defvrx {Constant} GLUT_CURSOR_WAIT
@defvrx {Constant} GLUT_CURSOR_TEXT
@defvrx {Constant} GLUT_CURSOR_CROSSHAIR
@defvrx {Constant} GLUT_CURSOR_UP_DOWN
@defvrx {Constant} GLUT_CURSOR_LEFT_RIGHT
@defvrx {Constant} GLUT_CURSOR_TOP_SIDE
@defvrx {Constant} GLUT_CURSOR_BOTTOM_SIDE
@defvrx {Constant} GLUT_CURSOR_LEFT_SIDE
@defvrx {Constant} GLUT_CURSOR_RIGHT_SIDE
@defvrx {Constant} GLUT_CURSOR_TOP_LEFT_CORNER
@defvrx {Constant} GLUT_CURSOR_TOP_RIGHT_CORNER
@defvrx {Constant} GLUT_CURSOR_BOTTOM_RIGHT_CORNER
@defvrx {Constant} GLUT_CURSOR_BOTTOM_LEFT_CORNER
@defvrx {Constant} GLUT_CURSOR_INHERIT
@defvrx {Constant} GLUT_CURSOR_NONE
@defvrx {Constant} GLUT_CURSOR_FULL_CROSSHAIR
@end defvr


@defun glut-warp-pointer x y
@end defun

@c ----------------------------------------------------------------------
@node GLUT overlay, GLUT menu API, GLUT window manipulation, GLUT API
@section GLUT overlay

@defun glut-establish-overlay
@end defun

@defun glut-remove-overlay
@end defun

@defun glut-use-layer layer
@end defun

@defun glut-post-overlay-redisplay
@end defun

@defun glut-post-window-overlay-redisplay win
@end defun

@defun glut-show-overlay
@end defun

@defun glut-hide-overlay
@end defun

@c ----------------------------------------------------------------------
@node GLUT menu API, GLUT callbacks, GLUT overlay, GLUT API
@section GLUT menu API

@defun glut-create-menu callback
@end defun

@defun glut-destroy-menu menu
@end defun

@defun glut-get-emnu
@end defun

@defun glut-set-menu menu
@end defun

@defun glut-add-menu-entry label value
@end defun

@defun glut-add-sub-menu label submenu
@end defun

@defun glut-change-to-menu-entry item label value
@end defun

@defun glut-change-to-sub-menu item label submenu
@end defun

@defun glut-remove-menu-item item
@end defun

@defun gult-attach-menu button
@end defun

@defun glut-detach-menu button
@end defun

@c ----------------------------------------------------------------------
@node GLUT callbacks, GLUT colormap, GLUT menu API, GLUT API
@section GLUT callbacks

@defun glut-display-func fn
@end defun

@defun glut-reshape-func fn
@end defun

@defun glut-keyboard-func fn
@end defun

@defvr {Constant} GLUT_KEY_F1
@defvrx {Constant} GLUT_KEY_F2
@defvrx {Constant} GLUT_KEY_F3
@defvrx {Constant} GLUT_KEY_F4
@defvrx {Constant} GLUT_KEY_F5
@defvrx {Constant} GLUT_KEY_F6
@defvrx {Constant} GLUT_KEY_F7
@defvrx {Constant} GLUT_KEY_F8
@defvrx {Constant} GLUT_KEY_F9
@defvrx {Constant} GLUT_KEY_F10
@defvrx {Constant} GLUT_KEY_F11
@defvrx {Constant} GLUT_KEY_F12
@defvrx {Constant} GLUT_KEY_LEFT
@defvrx {Constant} GLUT_KEY_UP
@defvrx {Constant} GLUT_KEY_RIGHT
@defvrx {Constant} GLUT_KEY_DOWN
@defvrx {Constant} GLUT_KEY_PAGE_UP
@defvrx {Constant} GLUT_KEY_PAGE_DOWN
@defvrx {Constant} GLUT_KEY_HOME
@defvrx {Constant} GLUT_KEY_END
@defvrx {Constant} GLUT_KEY_INSERT
@end defvr


@defun glut-mouse-func fn
@end defun

@defvr {Constant} GLUT_LEFT_BUTTON
@defvrx {Constant} GLUT_MIDDLE_BUTTON
@defvrx {Constant} GLUT_RIGHT_BUTTON
@defvrx {Constant} GLUT_DOWN
@defvrx {Constant} GLUT_UP
@end defvr

@defun glut-motion-func fn
@end defun

@defun glut-passive-motion-func fn
@end defun

@defun glut-entry-func fn
@end defun

@defvr {Constant} GLUT_LEFT
@defvrx {Constant} GLUT_ENTERED
@end defvr

@defun glut-visibility-func fn
@end defun

@defvr {Constant} GLUT_NOT_VISIBLE
@defvrx {Constant} GLUT_VISIBLE
@end defvr

@defun glut-idle-func fn
@end defun

@defun glut-timer-func millis fn value
@end defun

@defun glut-menu-state-func fn
@end defun

@defun glut-special-func fn
@end defun

@defun glut-spaceball-motion-func fn
@end defun

@defun glut-spaceball-rotate-func fn
@end defun

@defun glut-spaceball-button-func fn
@end defun

@defun glut-button-box-func fn
@end defun

@defun glut-dials-func fn
@end defun

@defun glut-tablet-motion-func fn
@end defun

@defun glut-tablet-button-func fn
@end defun

@defun glut-menu-status-func fn
@end defun

@defun glut-overlay-dislay-func fn
@end defun

@defun glut-window-status-func fn
@end defun

@defun glut-keyboard-up-func fn
@end defun

@defun glut-special-up-func fn
@end defun

@defun glut-joystick-func fn interval
@end defun

@c ----------------------------------------------------------------------
@node GLUT colormap, GLUT state retrieval, GLUT callbacks, GLUT API
@section GLUT colormap

@defun glut-set-color index r g b
@end defun

@defun glut-get-color index component
@end defun

@defvr {Constant} GLUT_RED
@defvrx {Constant} GLUT_GREEN
@defvrx {Constant} GLUT_BLUE
@end defvr

@defun glut-copy-colormap win
@end defun

@c ----------------------------------------------------------------------
@node GLUT state retrieval, GLUT font, GLUT colormap, GLUT API
@section GLUT state retrieval

@defun glut-get type
@end defun

@defvr {Constant} GLUT_WINDOW_X
@defvrx {Constant} GLUT_WINDOW_Y
@defvrx {Constant} GLUT_WINDOW_WIDTH
@defvrx {Constant} GLUT_WINDOW_HEIGHT
@defvrx {Constant} GLUT_WINDOW_BUFFER_SIZE
@defvrx {Constant} GLUT_WINDOW_STENCIL_SIZE
@defvrx {Constant} GLUT_WINDOW_DEPTH_SIZE
@defvrx {Constant} GLUT_WINDOW_RED_SIZE
@defvrx {Constant} GLUT_WINDOW_GREEN_SIZE
@defvrx {Constant} GLUT_WINDOW_BLUE_SIZE
@defvrx {Constant} GLUT_WINDOW_ALPHA_SIZE
@defvrx {Constant} GLUT_WINDOW_ACCUM_RED_SIZE
@defvrx {Constant} GLUT_WINDOW_ACCUM_GREEN_SIZE
@defvrx {Constant} GLUT_WINDOW_ACCUM_BLUE_SIZE
@defvrx {Constant} GLUT_WINDOW_ACCUM_ALPHA_SIZE
@defvrx {Constant} GLUT_WINDOW_DOUBLEBUFFER
@defvrx {Constant} GLUT_WINDOW_RGBA
@defvrx {Constant} GLUT_WINDOW_PARENT
@defvrx {Constant} GLUT_WINDOW_NUM_CHILDREN
@defvrx {Constant} GLUT_WINDOW_COLORMAP_SIZE
@defvrx {Constant} GLUT_WINDOW_NUM_SAMPLES
@defvrx {Constant} GLUT_WINDOW_STEREO
@defvrx {Constant} GLUT_WINDOW_CURSOR
@defvrx {Constant} GLUT_SCREEN_WIDTH
@defvrx {Constant} GLUT_SCREEN_HEIGHT
@defvrx {Constant} GLUT_SCREEN_WIDTH_MM
@defvrx {Constant} GLUT_SCREEN_HEIGHT_MM
@defvrx {Constant} GLUT_MENU_NUM_ITEMS
@defvrx {Constant} GLUT_DISPLAY_MODE_POSSIBLE
@defvrx {Constant} GLUT_INIT_WINDOW_X
@defvrx {Constant} GLUT_INIT_WINDOW_Y
@defvrx {Constant} GLUT_INIT_WINDOW_WIDTH
@defvrx {Constant} GLUT_INIT_WINDOW_HEIGHT
@defvrx {Constant} GLUT_INIT_DISPLAY_MODE
@defvrx {Constant} GLUT_ELAPSED_TIME
@defvrx {Constant} GLUT_WINDOW_FORMAT_ID
@end defvr

@defun glut-device-get type
@end defun

@defvr {Constant} GLUT_HAS_KEYBOARD
@defvrx {Constant} GLUT_HAS_MOUSE
@defvrx {Constant} GLUT_HAS_SPACEBALL
@defvrx {Constant} GLUT_HAS_DIAL_AND_BUTTON_BOX
@defvrx {Constant} GLUT_HAS_TABLET
@defvrx {Constant} GLUT_NUM_MOUSE_BUTTONS
@defvrx {Constant} GLUT_NUM_SPACEBALL_BUTTONS
@defvrx {Constant} GLUT_NUM_BUTTON_BOX_BUTTONS
@defvrx {Constant} GLUT_NUM_DIALS
@defvrx {Constant} GLUT_NUM_TABLET_BUTTONS
@defvrx {Constant} GLUT_DEVICE_IGNORE_KEY_REPEAT
@defvrx {Constant} GLUT_DEVICE_KEY_REPEAT
@defvrx {Constant} GLUT_HAS_JOYSTICK
@defvrx {Constant} GLUT_OWNS_JOYSTICK
@defvrx {Constant} GLUT_JOYSTICK_BUTTONS
@defvrx {Constant} GLUT_JOYSTICK_AXES
@defvrx {Constant} GLUT_JOYSTICK_POLL_RATE
@end defvr

@defun glut-extension-supported name
@end defun

@defun glut-get-modifiers 
@end defun

@defvr {Constant} GLUT_ACTIVE_SHIFT
@defvrx {Constant} GLUT_ACTIVE_CTRL
@defvrx {Constant} GLUT_ACTIVE_ALT
@end defvr

@defun glut-layer-get type
@end defun

@defvr {Constant} GLUT_OVERLAY_POSSIBLE
@defvrx {Constant} GLUT_LAYER_IN_USE
@defvrx {Constant} GLUT_HAS_OVERLAY
@defvrx {Constant} GLUT_TRANSPARENT_INDEX
@defvrx {Constant} GLUT_NORMAL_DAMAGED
@defvrx {Constant} GLUT_OVERLAY_DAMAGED
@end defvr

@c ----------------------------------------------------------------------
@node GLUT font, GLUT pre-built models, GLUT state retrieval, GLUT API
@section GLUT font

@deftp {Class} <glut-font>
@clindex glut-font
@end deftp

@defun glut-bitmap-character font character
@end defun

@defun glut-bitmap-width font character
@end defun

@defun glut-stroke-character font character
@end defun

@defun glut-stroke-width font character
@end defun

@defun glut-bitmap-length font string
@end defun

@defun glut-stroke-length font string
@end defun

@c ----------------------------------------------------------------------
@node GLUT pre-built models,  , GLUT font, GLUT API
@section GLUT pre-built models

@defun glut-wire-sphere radius slices stacks
@defunx glut-solid-sphere radius slices stacks
@end defun

@defun glut-wire-cone radius height slices stacks
@defunx glut-solid-cone radius height slices stacks
@end defun

@defun glut-wire-cube size
@defunx glut-solid-cube size
@end defun

@defun glut-wire-torus inner outer sides rings
@defunx glut-solid-torus inner outer sides rings
@end defun

@defun glut-wire-dodecahedron 
@defunx glut-solid-dodecahedron
@end defun

@defun glut-wire-teapot size
@defunx glut-soild-teapot size
@end defun

@defun glut-wire-octahedron
@defunx glut-solid-octahedron
@end defun

@defun glut-wire-tetrahedron
@defunx glut-solid-tetrahedron
@end defun

@defun glut-wire-icosahedron
@defunx glut-solid-icosahedron
@end defun


@c ======================================================================
@node Vectors and matrices, Indices, GLUT API, Top
@chapter Vectors and matrices

@deftp {Module} gl.math3d
@mdindex gl.math3d
The module provides vector and matrix operations useful for
3D computer graphics.

Actually this module itself doesn't depend on GL; you can use
this module alone to do matrix calculations.  However, the structure
of objects are designed so that they can be passed directly to
Gauche-gl functions, reducing the overhead of type conversions.

The purpose of this module is to provide reasonable performance.
So the operations are fixed to 3D homogeneous coordinates,
i.e. a vector is 4-element column vector, and a matrix is 4x4
square matrix.  If you want more flexibility, @code{<array>}
class in @code{gauche.array} provides much more generic
structures, trading performance.

Elements of vectors and matrices are represented in @code{float}
internally.   When you retrieve each element individually, 
it is converted to @code{double}, so you might see some precision
errors.   There are lots of operations directly manipulate group of
elements without retrieving each element to Scheme world, avoiding
overhead of conversion.
@end deftp

@c ----------------------------------------------------------------------
@menu
* Vectors and points::          
* Vector arrays and point arrays::  
* Matrices::                    
* Quaternions::                 
@end menu

@node Vectors and points, Vector arrays and point arrays, Vectors and matrices, Vectors and matrices
@section Vectors and points

@deftp {Class} <vector4f>
@deftpx {Class} <point4f>
@clindex vector4f
@clindex point4f
4x1 column vectors.  @code{Vector4f} is intended to be used
to represent a vector, and @code{point4f} is to a point,
but as far as OpenGL concerns, both are just an array of four floats,
@var{x}, @var{y}, @var{z} and @var{w}.

These classes inherit @code{<sequence>} and @code{<collection>}
classes.  So if you import @code{gauche.sequence} module,
you can use generic function such as @code{ref} and @code{(setter ref)}
to get/set individual elements.  The generic version of 
@code{map} and @code{for-each} can also be used on the vector4f and
point4f instances.

Aside from the type, 
the only difference is that the default value of @var{w} component---
it's 0.0 for vectors, and 1.0 for points.  So usual transformation
produces expected results; for example point plus vector
becomes point, vector plus vector becomes vector,
and translating point changes its coordinates but
translating vectors doesn't, and so on.
However, you can set @var{w} component to other value to do 
nontrivial operations.
@end deftp

@deftp {Reader syntax} @code{#,(vector4f @var{x} @var{y} @var{z} @var{w})}
@deftpx {Reader syntax} @code{#,(point4f @var{x} @var{y} @var{z} @var{w})}
These SRFI-10 syntax can be used to denote literal @code{<vector4f>}
and @code{<point4f>} instance, respectively.

The write methods are defined so that the instance is written out
in this form, and can be read back later.
@end deftp

@defun vector4f? obj
@defunx point4f? obj
Returns true iff @var{obj} is vector4f and point4f, respectively.
@end defun


@defun vector4f x y z &optional (w 0.0)
@defunx point4f x y z &optional (w 1.0)
Creates a vector4f and point4f instance with given values, respectively.
@end defun

@defun make-vector4f
@defunx make-point4f
Another way to create a vector4f and a point4f.
The first returns @code{#,(vector4f 0.0 0.0 0.0 0.0)},
and the latter returns @code{#,(point4f 0.0 0.0 0.0 1.0)}.
@end defun

@defun list->vector4f l
@defunx list->point4f l
Convert a list of three or four real numbers to a vector4f and a point4f,
respectively.
If @var{l} is not a list of three or four real numbers, an error is
signalled.

@example
(list->vector4f l)
  @equiv{} (apply vector4f l)
  @equiv{} (coerce-to <vector4f> l)
@end example
@end defun

@defun vector4f->list v
@defunx point4f->list p
Convert a vector4f and a point4f to a list of four real numbers,
respectively.

@example
(vector4f->list v)
  @equiv{} (coerce-to <list> v)
  @equiv{} (map (cut ref v <>) (iota 4))
@end example
@end defun

@defun f32vector->vector4f v &optional start
@defunx f32vector->point4f v &optional start
Creates a vector4f or a point4f, initializing by the elements of
f32vector @var{v}.   @var{V} must be longer than 4, and the first
four elements are used to initialize the created vector or point.

If optional @var{start} argument is given, it specifies an index
of @var{v} from which the initial values are taken; that is,
@var{start}, @var{start+1}, @var{start+2} and @var{start+3}-th
elements are used to create a vector or a point.
This allows to create vectors from plain float array:
@example
(map (lambda (off) (f32vector->vector4f vec (* off 4)))
     (iota (/ (size-of vec) 4)))
@end example

The conversion can be done using @code{coerce-to}, as well.
@example
(f32vector->vector4f vec)
  @equiv{} (coerce-to <vector4f> vec)
@end example
@end defun

@defun vector4f->f32vector v
@defunx point4f->f32vector p
Convert a vector4f @var{v} or a point4f @var{p} to four-element
f32vector.

@example
(vector4f->f32vector v)
 @equiv{} (coerce-to <f32vector> v)
@end example
@end defun

@defun vector4f-copy v
@defunx point4f-copy p
Returns a new copy of vector4f @var{v} or point4f @var{p}, respectively.
@end defun

@defun vector4f-copy! dstv srcv
@defunx point4f-copy! dstp srcp
Destructively sets the content of @var{srcv} or @var{srcp} to
@var{dstv} or @var{dstp}, respectively.
@end defun

@defun vector4f-set! v k value
@defunx point4f-set! p k value
Sets a real number @var{value} to
@var{k}-th element of a vector4f @var{v} or a point4f @var{p}.

@example
(vector4f-set! v k value)
  @equiv{} (set! (ref v k) value)
@end example
@end defun

@defun vector4f-ref v k &optional fallback
@defunx point4f-ref p k &optional fallback
Gets a value of @var{k}-th element of a vector4f @var{v} or
a point4f @var{p}.  If @var{k} is out of range,
an error is signalled, unless @var{fallback} is provided,
in such a case @var{fallback} is returned.

@example
(vector4f-ref v k)
  @equiv{} (ref v k)
@end example
@end defun

@defun vector4f-dot x y
Returns a dot product of two vector4fs, @var{x} and @var{y}.
@end defun

@defun vector4f-cross x y
Returns a cross product of two vector4fs, @var{x} and @var{y}.
(@var{w} element is ignored).
@end defun

@defun vector4f-normalize x
@defunx vector4f-normalize! x
Returns a normalized vector of vector4f @var{x}.
@code{Vector4f-normalize} allocates a new vector, while
@code{vector4f-normalize!} modifies the original vector.

As a special case, 
if @var{x} is a vector of length 0, a vector of length 0 is returned.
@end defun

@defun vector4f-add x y
@defunx vector4f-sub x y
@defunx vector4f-add! x y
@defunx vector4f-sub! x y
Returns a sum of two vector4fs, @var{x} and @var{y}.
The destructive version modifies @var{x}.
@end defun

@defun point4f-add x y
@defunx point4f-add! x y
Adds a point4f @var{x} and a vector4f @var{y}, and returns
a translated point.  The destructive version modifies @var{x}.
@end defun

@defun point4f-sub x y
Subtracts either a vector4f or a point4f @var{y} from
a point4f @var{x}.  If @var{y} is a vector4f, returns 
a translated point.  If @var{y} is a point4f, returns
a vector4f from point @var{y} to point @var{x}.
@end defun

@c ----------------------------------------------------------------------
@node Vector arrays and point arrays, Matrices, Vectors and points, Vectors and matrices
@section Vector arrays and point arrays

@deftp {Class} <vector4f-array>
@deftpx {Class} <point4f-array>
@clindex vector4f-array
@clindex point4f-array
Represents an array of vector4fs and point4fs.
This is an efficient way to keep an array of vectors or points,
for the elements are packed in a simple float array.
They are especially useful to work with GL's vertex array feature.
@code{gl-vertex-pointer} can take @code{<point4f-array>},
and @code{gl-normal-pointer} can take @code{<vector4f-array>}.

It is also possible to "view" a plain f32vector as @code{<vector4f-array>}
or @code{<point4f-array>} without copying its content, by
@code{f32vector->vector4f-array/shared} and
@code{f32vector->point4f-array/shared}.   Combined to
@code{read-block!}, you can do efficient binary I/O of
vertex arrays, for example.

Inherits @code{<sequence>} and @code{<collection>}.
When viewed as a sequence or a collection, they behaves like
sequence or collection of @code{vector4f} and @code{point4f} objects,
respectively.
@end deftp

@defun make-vector4f-array len &optional init-vector
@defunx make-point4f-array len &optional init-point
Creates a vector4f-array or point4f-array with @var{len} elements.
Each element is initialized by a vector4f @var{init-vector} or
a point4f @var{init-point} if provided.
@end defun

@defun vector4f-array? obj
@defunx point4f-array? obj
Returns true iff @var{obj} is a vector4f-array or a point4f-array,
respectively.
@end defun

@defun vector4f-array-length array
@defunx point4f-array-length array
Returns length (number of vectors/points) in array @var{array}.
@end defun

@deftp {Reader syntax} @code{#,(vector4f-array @var{len} @var{elt} @dots{})}
@deftpx {Reader syntax} @code{#,(point4f-array @var{len} @var{elt} @dots{})}
Vector4f-array and point4f-array have external representation
using this SRFI-10 syntax.  @var{Len} is a length of array,
and each @var{elt} is a list of four floats representing
each element of the array.

@example
(f32vector->vector4f-array #f32(1 2 3 4 6 7 4 3))
  @result{} #,(vector4f-array 2 (1 2 3 4) (6 7 4 3) )
@end example
@end deftp

@defun list->vector4f-array list
@defunx list->point4f-array list
From given list of vector4fs or point4fs, creates and returns
a vector4f-array or point4f-array, respectively.
@end defun

@defun f32vector->vector4f-array v
@defunx f32vector->point4f-array v
Converts f32vector @var{v} to a vector4f-array or a point4f-array.
The length of @var{v} must be multiple of four.
The content of @var{v} is copied.

@example
(f32vector->vector4f-array v)
  @equiv{} (coerce-to <vector4f-array> v)
@end example
@end defun

@defun f32vector->vector4f-array/shared v
@defunx f32vector->point4f-array/shared v
Like above, but the content of @var{v} is shared by the result
array, instead of being copied.
So the modification of result array will be visible from original
f32vector @var{v} and vice versa.
It will allow efficient handling of large vertex arrays.
@end defun

@defun vector4f-array->f32vector array
@defunx point4f-array->f32vector array
Converts a vector4f-array or a point4f-array @var{array} to a f32vector.

@example
(vector4f-array->f32vector array)
  @equiv{} (coerce-to <f32vector> array)
@end example
@end defun

@defun vector4f-array-set! array i vector
@defunx point4f-array-set! array i point
Sets a vector4f @var{vector} or a point4f @var{point} to
@var{i}-th element of vector4f-array or point4f-array @var{array},
respectively.

@example
(vector4f-array-set! array i vector)
  @equiv{} (set! (ref array i) vector)
@end example
@end defun

@defun vector4f-array-ref array i &optional fallback
@defunx point4f-array-ref array i &optional fallback
Returns a vector4f or a point4f which is the @var{i}-th element
of array @var{array}, respectively.
If @var{k} is out of range,
an error is signalled, unless @var{fallback} is provided,
in such a case @var{fallback} is returned.

@example
(vector4f-array-ref array i)
  @equiv{} (ref array i)

(ref #,(vector4f-array 2 (1 2 3 4) (6 7 4 3))  1)
  @result{} #,(vector4f 6 7 4 3)
@end example
@end defun

@defun vector4f-array-ref/shared array i &optional fallback
@defunx point4f-array-ref/shared array i &optional fallback
Like above, but the returned vector4f or point4f shares the storage
with the original array.  Thus the modification of the result
vector or point will be visible from @var{array}, and vice versa.
@end defun

@c ----------------------------------------------------------------------
@node Matrices, Quaternions, Vector arrays and point arrays, Vectors and matrices
@section Matrices

@deftp {Class} <matrix4f>
@clindex matrix4f
4x4 matrix.  Internally it is represented as an array of 16 floats,
stored in column-major order.
(It is the same order OpenGL uses, so it can be passed to OpenGL
calls without overhead).

Inherits @code{<sequence>} and @code{<collection>}.
When a matrix4f is treated as a sequence, it works as if it is 
a single sequence of floats in column-major order.
@end deftp

@defun make-matrix4f &optional init
Returns a new matrix4f instance.  If @var{init} is omitted,
the matrix is a unit matrix.  Otherwise, @var{init} must be a f32vector
of length 16, and the elements in the matrix is initialized by
ones in f32vector.

@example
;; Creates a matrix like this:
;;    1 2 3 4
;;    0 1 0 5
;;    0 0 1 6
;;    0 0 0 1

(make-matrix4f '#f32vector(1 0 0 0
                           2 1 0 0
                           3 0 1 0
                           4 5 6 1))
@end example
@end defun

@defun matrix4f m00 m10 m20 m30 m01 m11 m21 m31 m02 m12 m22 m32 m03 m13 m23 m33
Creates a new matrix4f instance with give values.
@end defun

@defun matrix4f? obj
Returns true iff @var{obj} is a matrix4f.
@end defun

@deftp {Reader syntax} @code{#,(matrix4f @var{elt} @dots{})}
A matrix4f is represented extrenally using SRFI-10 syntax.
The elements are listed in column-major order.
@end deftp

@defun list->matrix4f l
@defunx matrix4f->list m
Converts between list of 16 real numbers and matrix4f.
@end defun

@defun f32vector->matrix4f v &optional start
Creates a new matrix4f and initializes it with 16 elements in
f32vector @var{v}.   If optional @var{start} is given,
it specifies the start offset in vector @var{v} to be used as
initial values.  The f32vector @var{v} must have enough length.
@end defun

@defun matrix4f->f32vector m
Returns a new f32vector that has elements from matrix4f @var{m}.
@end defun

@defun matrix4f-copy m
Returns a new copy of @var{m}.
@end defun

@defun matrix4f-copy! dstm srcm
Copies contents of @var{srcm} to @var{dstm}.
@end defun

@defun matrix4f-set! m i value
Sets a real number @var{value} to @var{i}-th element of matrix @var{m}.
Since the matrix is laid out in column-major order,
the one-dimensional index @code{m@{@var{i}@}} and two-dimensional
index @code{m(@var{i},@var{j})} corresponds as follows:
@example
  m(0,0) = m@{0@}   m(0,1) = m@{4@}   m(0,2) = m@{8@}   m(0,3) = m@{12@}
  m(1,0) = m@{1@}   m(1,1) = m@{5@}   m(1,2) = m@{9@}   m(1,3) = m@{13@}
  m(2,0) = m@{2@}   m(2,1) = m@{6@}   m(2,2) = m@{10@}  m(2,3) = m@{14@}
  m(3,0) = m@{3@}   m(3,1) = m@{7@}   m(3,2) = m@{11@}  m(3,3) = m@{15@}
@end example
@end defun

@defun matrix4f-ref m i &optional fallback
Returns the @var{i}-th element of matrix @var{m}.
If @var{i} is out of range, an error is signalled,
unless @var{fallback} is provided, in such a case
@var{fallback} is returned.
@end defun

@defun matrix4f-set2! m i j value
Sets @var{value} to @code{(@var{i}, @var{j})} element of matrix @var{m}.
@end defun

@defun matrix4f-ref2 m i j
Returns the @code{(@var{i}, @var{j})} element of matrix @var{m}.
@end defun

@defun matrix4f-row m i
@defunx matrix4f-column m i
@defunx matrix4f-column/shared m i
Returns @var{i}-th row vector or @var{i}-th column vector
of matrix @var{m}, as a vector4f instance.

Furthermore, the returned vector from @code{matrix4f-column/shared}
shares the storage with @code{m}.
@end defun

@defun matrix4f-mul m obj
@var{Obj} may be a scalar (real number), a vector4f, a point4f, or a matrix4f.
Returns @var{m} x @var{obj}.
@end defun

@defun matrix4f-mul! m obj
@var{Obj} may be a scalar or a matrix4f.
Matrix @var{m} is multiplied by @var{obj}, and the result is
set to @var{m} destructively.
@end defun

@defun matrix4f-transpose m
@defunx matrix4f-transpose! m
Returns a transposed matrix of @var{m}.  The destructive version
modifies @var{m}.
@end defun

@defun matrix4f-determinant m
Returns a determinant of @var{m}.
@end defun

@defun matrix4f-inverse m &optional (error-on-singular? #t)
@defunx matrix4f-inverse! m &optional (error-on-singular? #t)
Returns a inverse matrix of @var{m}.  The destructive version
modifies @var{m}.  If given @var{m} is a singular matrix,
an error is signalled by default.  However, if @code{#f} is given
to the optional @var{error-on-singular?} argument,
@code{#f} is returned in such a case.
@end defun

@defun translation->matrix4f translation-vector
@defunx translation->matrix4f! m translation-vector
Returns a matrix which represents a translation by @var{translation-vector},
which must be either a vector4f, a point4f, or
a f32vector of length 3 or 4.   Only the first three elements
in @var{translation-vector} is used.
The destructive version updates @var{m}.
@end defun

@defun rotation->matrix4f axis angle
@defunx rotation->matrix4f! m axis angle
Returns a matrix which represents a rotation around
@var{axis} by @var{angle} radian.  @var{Axis} must be
a vector4f or a f32vector of length 3 or 4, and must be normalized.
The result is undefined if anormalized vector is passed as @var{axis}.
The destructive version updates @var{m}.
@end defun

@defun scale->matrix4f scale-vector
@defunx scale->matrix4f! m scale-vector
Returns a matrix which represents a scale by @var{scale-vector},
which must be either a vector4f, a point4f, or
a f32vector of length 3 or 4.  Only the first three elements
in @var{scale-vector} is used.  Each element of @var{scale-vector}
represents the scale factor along x, y, and z axis.
The destructive version updates @var{m}.
@end defun

@defun trs->matrix4f translation rotation-axis rotation-angle scale
@defunx trs->matrix4f! m translation rotation-axis rotation-angle scale
This combines above three procedure.
Returns a matrix that represents translation, rotation and
scale, specified by @var{translation}, @var{rotation-axis},
@var{rotation-angle} and @var{scale}.
The destructive version updates @var{m}.

If @code{@i{T}}, @code{@i{R}} and @code{@i{S}}, are
the matrices that represent translation, rotation and scale, respectively,
then these procedures effectively calculates
a matrix @code{@i{TRS}}. 
@end defun

@defun tqs->matrix4f translation rotation-quat scale
@defunx tqs->matrix4f! m translation rotation-quat scale
A variation of @code{trs->matrix4f}.  Instead of axis and angle,
rotation is represented by a quaternion @var{rotation-quat}.
@xref{Quaternions}, for more details about quaternions.
@end defun

@defun euler-angle->matrxi4f xangle yangle zangle &optional order
@defunx euler-angle->matrxi4f! m xangle yangle zangle &optional order
Returns a matrix that represents rotation along x, y and z axis
by @var{xangle}, @var{yangle}, and @var{zangle}, respectively.

The order of rotation can be specified by the optional argument
@var{order}, which may be one of the symbols @code{xyz}, @code{xzy},
@code{yzx}, @code{yxz}, @code{zxy}, or @code{zyx}.  For example,
symbol @code{xyz} means rotation around x-axis, then y-axis, then
z-axis.  Thus, if we write each rotation as @i{Rx}, @i{Ry}, and
@i{Rz}, the returned matrix is @i{RzRyRx}.
The default value of @var{order} is @code{xyz}.

The desrtuctive version modifies @var{m}.
@end defun

@defun matrix4f-decompose m
Matrix @var{m} is a composition of translation, rotation, shear and
scale.  Suppose transformation is applied in the reverse order.
This procedure decompose @var{m} into each individual transformation.

Returns five values.
@itemize @bullet
@item
A flag to indicate if @var{m} is non-singular.
@item
A translation vector @var{t}, in vector4f.  The first three elements
of @var{t} are for x, y, and z translations.
@item
A rotation matrix @var{r}, in matrix4f.
This is an orthogonal matrix represents rotation component.
@item
A shear vector @var{h}, in vector4f.  The first three elements
of @var{h} are for xy, xz and yz shear factors.
@item
A scale vector @var{s}, in vector4f.  The first three elements
of @var{s} are fof x, y, and z scale factors.
@end itemize

If @var{m} is singular, certain part of rotation matrix can't 
be recovered.   In such a case, @var{r} becomes also singular matrix.

If the original matrix has negative scale factor in any of 
x, y, or z scale, the decomposed scale factor will have all negative
components.  The signs of elements of @var{r} are adjusted accordingly.

Due to the precision errors,
you will see small values appear in shear component even @var{m} is
pure TRS matrix.
@end defun

@defun matrix4f-decompose! m t r h s
Linear update version of @code{matrix4f-decompose}.
The result vectors and matrices are stored in @var{t}, @var{r}, @var{h}
and @var{s}.  The return value is a boolean value indicates
@var{m} is non-singular or not.
@end defun

@defun matrix4f->rotation m
From given orthogonal matrix @var{m}, extracts and returns
and rotation axis and angle, as a vector4f and a real number.
@end defun

@defun matrix4f->rotation! m v
Same as above, except the storage of vector4f @var{v} is reused
to store the result axis.
@end defun

@c ----------------------------------------------------------------------
@node Quaternions,  , Matrices, Vectors and matrices
@section Quaternions

@deftp {Class} <quatf>
@clindex quatf
Quaternions.   Internally quaternions are represented as just
an array of four floats; the first three are the vector component
and the last is the scalar component.

Inherits @code{<sequence>} and @code{<collection>}.  When viewed
as sequence, it is just like a vector of four floats.
@end deftp

@defun quatf? obj
Returns true iff @var{obj} is a quaternion.
@end defun

@deftp {Reader syntax} @code{#,(quatf @var{x} @var{y} @var{z} @var{w})}
External representation of quaternion
@i{x}@b{i}+@i{y}@b{j}+@i{z}@b{k}+@i{w}.
@end deftp

@defun make-quatf &optional axis (angle 0)
Returns a new unit quaternion that represents a rotation
around vector @var{axis} by @var{angle} radians.
@var{Axis} can be a vector4f, a point4f or 
a f32vector (only first three component is used).
@var{Axis} must be a unit vector; if @var{axis} is anormalized,
the result is undefined.

If both @var{axis} and @var{angle} is omitted,
@code{#,(quatf 0 0 0 1)} is returned.
@end defun

@defun quatf x y z w
Returns a new quaternion whose elements are initialized by
@var{x}, @var{y}, @var{z}, @var{w}.
@end defun

@defun list->quatf l
@defunx quatf->list q
Converts between a list of four real numbers and a quaternion.
@end defun

@defun f32vector->quatf x &optional start
Returns a new quaternion whose elements are initialized by
the first four elements of f32vector @var{x}.
If @var{start} is given, the initial value is taken
starting from @var{start}-th index in @var{x}.
@end defun

@defun quatf->f32vector q
Returns a new f32vector whose contents is the same as a quaternion @var{q}.
@end defun

@defun quatf-copy q
Returns a fresh copy of a quaternion @var{q}.
@end defun

@defun quatf-copy! dstq srcq
Copies contents of a quaternion @var{srcq} to a quaternion @var{dstq}.
@end defun

@defun rotation->quatf! quat axis angle
Sets a quaternion @var{quat} so that it represents a rotation
around a unit vector @var{axis} by angle @var{angle} radians.
@var{Axis} can be a vector4f, a point4f or 
a f32vector (only first three component is used).
@end defun

@defun quatf-add p q
@defunx quatf-add! p q
@defunx quatf-sub p q
@defunx quatf-sub! p q
Addition and subtraction of quaternions.  The destructive version
modifies the first argument.
@end defun

@defun quatf-scale q s
@defunx quatf-scale! q s
Multiplies a quaternion @var{q} by a scalar value @var{s}.
The destructive version modifies @var{q}.
@end defun

@defun quatf-mul p q
@defunx quatf-mul! p q
Multiply two quaternions @var{p} and @var{q}.
The destructive version modifies @var{p}.
@end defun

@defun quatf-conjugate q
Returns a conjugate of a quaternion @var{q}.
@end defun

@defun quatf-transform q p
Transforms a vector or a point @var{p} by quaternion @var{q},
that is, returns @var{qpq*}, where @var{q*} is a conjugate of @var{q}.

This procedure assumes @var{q} is normalized.

@var{P} can be a vector4f, a point4f or a f32vector
(only first three elements are used).
Returns the same type of object as @var{p}.
@end defun

@defun quatf-norm q
Returns norm of @var{q}.
@end defun

@defun quatf-normalize q
@defunx quatf-normalize! q
Returns normalized quaternion of @var{q}.
The destructive version modifies @var{q}.
@end defun

@defun quatf->matrix4f q
@defunx quatf->matrix4f! m q
Returns a matrix that represents a rotation specified by a unit
quaternion @var{q}.
The behavior is undefined if @var{q} is not normalized.
The destructive version modifies @var{m}.
@end defun

@defun quatf-slerp p q t
@defunx quatf-slerp! r p q t
Returns a quaternion that interpolates between two
unit quaternions @var{p} and @var{q}, by a scalar value @var{t}.
The destructive version modifies @var{t}.
@end defun




@c ======================================================================
@c @node GL-Scheme utility, Indices, 3D vectors and matrices, Top
@c @chapter GL-Scheme utility



@c ======================================================================
@node Indices,  , Vectors and matrices, Top
@appendix Indices
@c NODE 索引

@menu
* Function and Syntax Index::   
* Module Index::                
* Class Index::                 
* Variable Index::              
@end menu

@node Function and Syntax Index, Module Index, Indices, Indices
@appendixsec Function and Syntax Index
@c NODE 手続きと構文索引
@printindex fn

@node Module Index, Class Index, Function and Syntax Index, Indices
@appendixsec Module Index
@c NODE モジュール索引
@printindex md

@node Class Index, Variable Index, Module Index, Indices
@appendixsec Class Index
@c NODE クラス索引

For readability, the surrounding @code{<} and @code{>} are stripped off.

@printindex cl

@node Variable Index,  , Class Index, Indices
@appendixsec Variable Index
@c NODE 変数索引
@printindex vr


@contents
@bye

@c Local variables:
@c outline-regexp: "@chap\\|@unnu\\|@\\(sub\\)*section"
@c end:

