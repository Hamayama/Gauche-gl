;;;
;;; glu-lib.stub - glue functions for GLU
;;;
;;;  Copyright (c) 2001-2008  Shiro Kawai  <shiro@acm.org>
;;;
;;;  Permission to use, copy, modify, distribute this software and
;;;  accompanying documentation for any purpose is hereby granted,
;;;  provided that existing copyright notices are retained in all
;;;  copies and that this notice is included verbatim in all
;;;  distributions.
;;;  This software is provided as is, without express or implied
;;;  warranty.  In no circumstances the author(s) shall be liable
;;;  for any damages arising out of the use of this software.
;;;
;;;  $Id: glu-lib.stub,v 1.14 2008-06-04 11:51:00 shirok Exp $
;;;

"
#if  MacOSX
#include <OpenGL/gl.h>
#include <OpenGL/glu.h>
#else
#include <GL/gl.h>
#include <GL/glu.h>
#endif
#include <gauche/uvector.h>
#include \"gauche-gl.h\"
"

(define-type <uvector> "ScmUVector*" "uniform vector"
  "SCM_UVECTORP" "SCM_UVECTOR")

;;================================================================
;; Miscellaneous
;;

(define-cproc glu-look-at (eyex::<real> eyey::<real> eyez::<real>
                           ctrx::<real> ctry::<real> ctrz::<real>
                           upx::<real> upy::<real> upz::<real>)
  (call <void> "gluLookAt"))

(define-cproc glu-ortho-2d (left::<real> right::<real>
                            bottom::<real> top::<real>)
  (call <void> "gluOrtho2D"))

(define-cproc glu-perspective (fovy::<real> aspect::<real>
                               znear::<real> zfar::<real>)
  (call <void> "gluPerspective"))

(define-cproc glu-pick-matrix (x::<real> y::<real> w::<real> h::<real> vp)
  "if (!SCM_S32VECTORP(vp) || SCM_S32VECTOR_SIZE(vp) != 4) {
     Scm_Error(\"s32 vector of size 4 required for vp, but got %S\", vp);
   }
  gluPickMatrix((GLdouble)x, (GLdouble)y, (GLdouble)w, (GLdouble)h,
                 (GLint*)SCM_S32VECTOR_ELEMENTS(vp));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc glu-error-string (code::<int>)
  "  const GLubyte *s = gluErrorString(code);
  if (s) SCM_RETURN(Scm_MakeString((const char *)s, -1, -1, 0));
  else   SCM_RETURN(SCM_FALSE);")

;; common routine for glu-project and glu-un-project
"static ScmObj glu_xproject(double srcx, double srcy, double srcz,
                            ScmObj model_mat, ScmObj proj_mat, ScmObj vp,
                            GLint (*fn)(GLdouble, GLdouble, GLdouble, const GLdouble*, const GLdouble*, const GLint*, GLdouble*, GLdouble*, GLdouble*))
 {
   int r; GLdouble dstx, dsty, dstz;
   if (!SCM_F64VECTORP(model_mat) || SCM_F64VECTOR_SIZE(model_mat) != 16) {
     Scm_Error(\"f64 vector of size 16 required for model-mat, but got %S\",
               model_mat);
   }
   if (!SCM_F64VECTORP(proj_mat) || SCM_F64VECTOR_SIZE(proj_mat) != 16) {
     Scm_Error(\"f64 vector of size 16 required for proj-mat, but got %S\",
               proj_mat);
   }
   if (!SCM_S32VECTORP(vp) || SCM_S32VECTOR_SIZE(vp) != 4) {
     Scm_Error(\"s32 vector of size 4 required for vp, but got %S\", vp);
   }
   r = fn(srcx, srcy, srcz,
          SCM_F64VECTOR_ELEMENTS(model_mat),
          SCM_F64VECTOR_ELEMENTS(proj_mat),
          (GLint*)SCM_S32VECTOR_ELEMENTS(vp),
          &dstx, &dsty, &dstz);
   if (r == GL_TRUE) {
     SCM_RETURN(Scm_Values3(Scm_MakeFlonum(dstx),
                            Scm_MakeFlonum(dsty),
                            Scm_MakeFlonum(dstz)));
   } else {
     SCM_RETURN(Scm_Values3(SCM_FALSE, SCM_FALSE, SCM_FALSE));
   }
 }"

(define-cproc glu-project (objx::<real> objy::<real> objz::<real>
                           model-mat proj-mat vp)
  "SCM_RETURN(glu_xproject(objx, objy, objz, model_mat, proj_mat, vp, gluProject));")

(define-cproc glu-un-project (winx::<real> winy::<real> winz::<real>
                              model-mat proj-mat vp)
  "SCM_RETURN(glu_xproject(winx, winy, winz, model_mat, proj_mat, vp, gluUnProject));")

;; common routine for glu-project! and glu-un-project!
"static ScmObj glu_xprojectX(ScmObj dst, ScmObj src,
                             ScmObj model_mat, ScmObj proj_mat, ScmObj vp,
                             GLint (*fn)(GLdouble, GLdouble, GLdouble, const GLdouble*, const GLdouble*, const GLint*, GLdouble*, GLdouble*, GLdouble*))
 {
   int r;
   float *dstfp = NULL, *srcfp = NULL;
   double *dstdp = NULL, *srcdp = NULL;
   GLdouble dstx, dsty, dstz;
   if (SCM_F64VECTORP(dst) && SCM_F64VECTOR_SIZE(dst) == 4) {
     dstdp = SCM_F64VECTOR_ELEMENTS(dst);
   } else {
     SCM_MATH3D_X4FP(dstfp, dst);
   }
   if (SCM_F64VECTORP(src) && SCM_F64VECTOR_SIZE(src) == 4) {
     srcdp = SCM_F64VECTOR_ELEMENTS(src);
   } else {
     SCM_MATH3D_X4FP(srcfp, src);
   }
   if (!SCM_F64VECTORP(model_mat) || SCM_F64VECTOR_SIZE(model_mat) != 16) {
     Scm_Error(\"f64 vector of size 16 required for model-mat, but got %S\",
               model_mat);
   }
   if (!SCM_F64VECTORP(proj_mat) || SCM_F64VECTOR_SIZE(proj_mat) != 16) {
     Scm_Error(\"f64 vector of size 16 required for proj-mat, but got %S\",
               proj_mat);
   }
   if (!SCM_S32VECTORP(vp) || SCM_S32VECTOR_SIZE(vp) != 4) {
     Scm_Error(\"s32 vector of size 4 required for vp, but got %S\", vp);
   }
   if (srcfp) {
     r = fn((GLdouble)srcfp[0], (GLdouble)srcfp[1], (GLdouble)srcfp[2],
            SCM_F64VECTOR_ELEMENTS(model_mat),
            SCM_F64VECTOR_ELEMENTS(proj_mat),
            (GLint*)SCM_S32VECTOR_ELEMENTS(vp),
            &dstx, &dsty, &dstz);
   } else {
     r = fn((GLdouble)srcdp[0], (GLdouble)srcdp[1], (GLdouble)srcdp[2],
            SCM_F64VECTOR_ELEMENTS(model_mat),
            SCM_F64VECTOR_ELEMENTS(proj_mat),
            (GLint*)SCM_S32VECTOR_ELEMENTS(vp),
            &dstx, &dsty, &dstz);
   }
   if (r == GL_TRUE) {
     if (dstfp) {
       dstfp[0] = (float)dstx, dstfp[1] = (float)dsty, dstfp[2] = (float)dstz;
     } else {
       dstdp[0] = dstx, dstdp[1] = dsty, dstdp[2] = dstz;
     }
     SCM_RETURN(SCM_OBJ(dst));
   } else {
     SCM_RETURN(SCM_FALSE);
   }
 }"

(define-cproc glu-project! (win obj model-mat proj-mat vp)
  "SCM_RETURN(glu_xprojectX(win, obj, model_mat, proj_mat, vp, gluProject));")

(define-cproc glu-un-project! (obj win model-mat proj-mat vp)
  "SCM_RETURN(glu_xprojectX(obj, win, model_mat, proj_mat, vp, gluUnProject));")

;;=============================================================
;; Mipmapping and image scaling
;;

;(define-cproc glu-scale-image! (format::<fixnum>
;                                width-in::<fixnum> height-in::<fixnum>
;                                type-in::<fixnum> data-in::<uvector>
;                                width-out::<fixnum> height-out::<fixnum>
;                                type-out::<fixnum> data-out::<uvector>)


;;=============================================================
;; Quadrics
;;

(define-type <glu-quadric> "ScmGluQuadric*" #f
  "SCM_GLU_QUADRIC_P" "SCM_GLU_QUADRIC")

;; gluNewQuadric : (make <glu-quadric>)
;; gluDeleteQuadric : GC takes care of this

(define-cproc glu-quadric-draw-style (quad::<glu-quadric> style::<fixnum>)
  "gluQuadricDrawStyle(quad->quadric, style);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc glu-quadric-orientation (quad::<glu-quadric> orientation::<fixnum>)
  "gluQuadricOrientation(quad->quadric, orientation);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc glu-quadric-normals (quad::<glu-quadric> normals::<fixnum>)
  "gluQuadricNormals(quad->quadric, normals);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc glu-quadric-texture (quad::<glu-quadric> texcoords::<fixnum>)
  "gluQuadricTexture(quad->quadric, texcoords);
   SCM_RETURN(SCM_UNDEFINED);")

;; glu-quadric-callback - gluQuadricCallback doesn't pass the closure
;;   information, so it is practially impossible to implement this in
;;   reasonable way.

(define-cproc glu-cylinder (quad::<glu-quadric> base-radius::<real>
                            top-radius::<real> height::<real>
                            slices::<fixnum> stacks::<fixnum>)
  "gluCylinder(quad->quadric, base_radius, top_radius, height, slices, stacks);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc glu-sphere (quad::<glu-quadric> radius::<real>
                          slices::<fixnum> stacks::<fixnum>)
  "gluSphere(quad->quadric, radius, slices, stacks);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc glu-disk (quad::<glu-quadric>
                        inner-radius::<real> outer-radius::<real>
                        slices::<fixnum> loops::<fixnum>)
  "gluDisk(quad->quadric, inner_radius, outer_radius, slices, loops);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc glu-partial-disk (quad::<glu-quadric>
                                inner-radius::<real> outer-radius::<real>
                                slices::<fixnum> loops::<fixnum>
                                start-angle::<real> sweep-angle::<real>)
  "gluPartialDisk(quad->quadric, inner_radius, outer_radius, slices, loops,
                  start_angle, sweep_angle);
   SCM_RETURN(SCM_UNDEFINED);")


;;=============================================================
;; Nurbs
;;

(define-type <glu-nurbs> "ScmGluNurbs*" #f
  "SCM_GLU_NURBS_P" "SCM_GLU_NURBS")

;; glu-new-nurbs-renderer : (make <glu-nurbs>)
;; glu-delete-nurbs-renderer : GC takes care of this.

(define-cproc glu-load-sampling-matrices (nurbs::<glu-nurbs>
                                          model-matrix proj-matrix viewport)
  "if (!SCM_F32VECTORP(model_matrix)
       || SCM_F32VECTOR_SIZE(model_matrix) != 16) {
     Scm_Error(\"f32vector of length 16 required for model-matrix, but got %S\", model_matrix);
   }
   if (!SCM_F32VECTORP(proj_matrix)
       || SCM_F32VECTOR_SIZE(proj_matrix) != 16) {
     Scm_Error(\"f32vector of length 16 required for proj-matrix, but got %S\", proj_matrix);
   }
   if (!SCM_S32VECTORP(viewport)
       || SCM_S32VECTOR_SIZE(viewport) != 4) {
     Scm_Error(\"s32vector of length 4 required for viewport, but got %S\", viewport);
   }
   gluLoadSamplingMatrices(nurbs->nurbs,
                           SCM_F32VECTOR_ELEMENTS(model_matrix),
                           SCM_F32VECTOR_ELEMENTS(proj_matrix),
                           (GLint*)SCM_S32VECTOR_ELEMENTS(viewport));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc glu-nurbs-property (nurbs::<glu-nurbs>
                                  property::<fixnum> value::<real>)
  "gluNurbsProperty(nurbs->nurbs, (GLenum)property, (GLfloat)value);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc glu-get-nurbs-property (nurbs::<glu-nurbs> property::<fixnum>)
  "GLfloat value;
   gluGetNurbsProperty(nurbs->nurbs, (GLenum)property, &value);
   SCM_RETURN(Scm_MakeFlonum((double)value));")

(define-cproc glu-begin-curve (nurbs::<glu-nurbs>)
  "gluBeginCurve(nurbs->nurbs);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc glu-end-curve (nurbs::<glu-nurbs>)
  "gluEndCurve(nurbs->nurbs);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc glu-nurbs-curve (nurbs::<glu-nurbs>
                               knot stride::<fixnum> ctlarray
                               order::<fixnum> type::<fixnum>)
  "int nknots, nctlarray;
  if (!SCM_F32VECTORP(knot)) {
    Scm_Error(\"f32vector required for knot, but got %S\", knot);
  }
  nknots = SCM_F32VECTOR_SIZE(knot);
  nctlarray = (nknots - order) * stride;
  if (!SCM_F32VECTORP(ctlarray) || SCM_F32VECTOR_SIZE(ctlarray) != nctlarray) {
    Scm_Error(\"f32vector of length %d is required for control points, but got %S\", nctlarray, ctlarray);
  }
  gluNurbsCurve(nurbs->nurbs, nknots, SCM_F32VECTOR_ELEMENTS(knot),
                stride, SCM_F32VECTOR_ELEMENTS(ctlarray), order, type);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc glu-begin-surface (nurbs::<glu-nurbs>)
  "gluBeginSurface(nurbs->nurbs);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc glu-end-surface (nurbs::<glu-nurbs>)
  "gluEndSurface(nurbs->nurbs);
   SCM_RETURN(SCM_UNDEFINED);")

;;================================================================
;; Polygon tesselation
;;

(define-type <glu-tesselator> "ScmGluTesselator*" #f
  "SCM_GLU_TESSELATOR_P" "SCM_GLU_TESSELATOR")

;;=============================================================
;; Mipmapping and image scaling
;;

;; caller must ensure vector has enough length
(define-cproc glu-build-1d-mipmaps (target::<fixnum>
                                    internalformat::<fixnum>
                                    width::<fixnum>
                                    format::<fixnum> type::<fixnum>
                                    texels)
  "int elttype, size, r; void *texelptr;
  size = Scm_GLPixelDataSize(width, 1, format, type, &elttype,
NULL);
  texelptr = Scm_GLPixelDataCheck(texels, elttype, size);
  r = gluBuild1DMipmaps(target, internalformat, width, format,
                        type, texelptr);
  SCM_RETURN(SCM_MAKE_INT(r));")

(define-cproc glu-build-2d-mipmaps (target::<fixnum>
                                    internalformat::<fixnum>
                                    width::<fixnum> height::<fixnum>
                                    format::<fixnum>
                                    type::<fixnum> texels)
  "int elttype, size, r; void *texelptr;
  size = Scm_GLPixelDataSize(width, height, format, type, &elttype,
NULL);
  texelptr = Scm_GLPixelDataCheck(texels, elttype, size);
  r = gluBuild2DMipmaps(target, internalformat, width, height, format,
                        type, texelptr);
  SCM_RETURN(SCM_MAKE_INT(r));")

(if "defined(GL_VERSION_1_2)" (begin

(define-cproc glu-build-3d-mipmaps (target::<fixnum>
                                    internalformat::<fixnum>
                                    width::<fixnum> height::<fixnum>
                                    depth::<fixnum> format::<fixnum>
                                    type::<fixnum> texels)
  ;; NB: does Scm_GLPxielDataSize work to pass height*depth as height?
  ;; need to think over it.
  "int elttype, size, r; void *texelptr;
  size = Scm_GLPixelDataSize(width, height*depth, format, type, &elttype,
NULL);
  texelptr = Scm_GLPixelDataCheck(texels, elttype, size);
  r = gluBuild3DMipmaps(target, internalformat, width, height, depth, format,
                        type, texelptr);
  SCM_RETURN(SCM_MAKE_INT(r));")

(define-cproc glu-build-1d-mipmap-levels (target::<fixnum>
                                          internalformat::<fixnum>
                                          width::<fixnum>
                                          format::<fixnum> type::<fixnum>
                                          level::<fixnum> base::<fixnum>
                                          max::<fixnum>
                                          texels)
  "int elttype, size, r; void *texelptr;
  size = Scm_GLPixelDataSize(width, 1, format, type, &elttype,
NULL);
  texelptr = Scm_GLPixelDataCheck(texels, elttype, size);
  r = gluBuild1DMipmapLevels(target, internalformat, width, format,
                             type, level, base, max, texelptr);
  SCM_RETURN(SCM_MAKE_INT(r));")

(define-cproc glu-build-2d-mipmap-levels (target::<fixnum>
                                          internalformat::<fixnum>
                                          width::<fixnum> height::<fixnum>
                                          format::<fixnum> type::<fixnum>
                                          level::<fixnum> base::<fixnum>
                                          max::<fixnum>
                                          texels)
  "int elttype, size, r; void *texelptr;
  size = Scm_GLPixelDataSize(width, height, format, type, &elttype,
NULL);
  texelptr = Scm_GLPixelDataCheck(texels, elttype, size);
  r = gluBuild2DMipmapLevels(target, internalformat, width, height, format,
                             type, level, base, max, texelptr);
  SCM_RETURN(SCM_MAKE_INT(r));")

(define-cproc glu-build-3d-mipmap-levels (target::<fixnum>
                                          internalformat::<fixnum>
                                          width::<fixnum> height::<fixnum>
                                          depth::<fixnum> format::<fixnum>
                                          type::<fixnum> level::<fixnum>
                                          base::<fixnum> max::<fixnum>
                                          texels)
  ;; NB: does Scm_GLPxielDataSize work to pass height*depth as height?
  ;; need to think over it.
  "int elttype, size, r; void *texelptr;
  size = Scm_GLPixelDataSize(width, height*depth, format, type, &elttype,
NULL);
  texelptr = Scm_GLPixelDataCheck(texels, elttype, size);
  r = gluBuild3DMipmapLevels(target, internalformat, width, height, depth, 
                             format, type, level, base, max, texelptr);
  SCM_RETURN(SCM_MAKE_INT(r));")

)) ;; if defined(GL_VERSION_1_2)

;;================================================================
;; New function in GLU 1.1
;;

(define-cproc glu-get-string (name::<fixnum>)
  "  const GLubyte *p = gluGetString(name);
  if (p) SCM_RETURN(Scm_MakeString((const char*)p, -1, -1, 0));
  else SCM_RETURN(SCM_FALSE);")

;;================================================================
;; Constants
;;

;; Normal vectors 
(define-enum GLU_SMOOTH)
(define-enum GLU_FLAT)
(define-enum GLU_NONE)

;; Quadric draw styles 
(define-enum GLU_POINT)
(define-enum GLU_LINE)
(define-enum GLU_FILL)
(define-enum GLU_SILHOUETTE)

;; Quadric orientation 
(define-enum GLU_OUTSIDE)
(define-enum GLU_INSIDE)

;; Tesselator
(if "!defined(__CYGWIN__)"
    (begin
      (define-enum GLU_BEGIN)
      (define-enum GLU_VERTEX)
      (define-enum GLU_END)
      (define-enum GLU_ERROR)
      (define-enum GLU_EDGE_FLAG)))

;; Contour types 
(if "!defined(__CYGWIN__)"
    (begin
      (define-enum GLU_CW)
      (define-enum GLU_CCW)
      (define-enum GLU_INTERIOR)
      (define-enum GLU_EXTERIOR)
      (define-enum GLU_UNKNOWN)))

;; Tesselation errors 
(define-enum GLU_TESS_ERROR1)
(define-enum GLU_TESS_ERROR2)
(define-enum GLU_TESS_ERROR3)
(define-enum GLU_TESS_ERROR4)
(define-enum GLU_TESS_ERROR5)
(define-enum GLU_TESS_ERROR6)
(define-enum GLU_TESS_ERROR7)
(define-enum GLU_TESS_ERROR8)
;(define-enum GLU_TESS_ERROR9)

;; NURBS 
(define-enum GLU_AUTO_LOAD_MATRIX)
(define-enum GLU_CULLING)
(define-enum GLU_PARAMETRIC_TOLERANCE)
(define-enum GLU_SAMPLING_TOLERANCE)
(define-enum GLU_DISPLAY_MODE)
(define-enum GLU_SAMPLING_METHOD)
(define-enum GLU_U_STEP)
(define-enum GLU_V_STEP)

(define-enum GLU_PATH_LENGTH)
(define-enum GLU_PARAMETRIC_ERROR)
(define-enum GLU_DOMAIN_DISTANCE)

(define-enum GLU_MAP1_TRIM_2)
(define-enum GLU_MAP1_TRIM_3)

(define-enum GLU_OUTLINE_POLYGON)
(define-enum GLU_OUTLINE_PATCH)

(define-enum GLU_NURBS_ERROR1)
(define-enum GLU_NURBS_ERROR2)
(define-enum GLU_NURBS_ERROR3)
(define-enum GLU_NURBS_ERROR4)
(define-enum GLU_NURBS_ERROR5)
(define-enum GLU_NURBS_ERROR6)
(define-enum GLU_NURBS_ERROR7)
(define-enum GLU_NURBS_ERROR8)
(define-enum GLU_NURBS_ERROR9)
(define-enum GLU_NURBS_ERROR10)
(define-enum GLU_NURBS_ERROR11)
(define-enum GLU_NURBS_ERROR12)
(define-enum GLU_NURBS_ERROR13)
(define-enum GLU_NURBS_ERROR14)
(define-enum GLU_NURBS_ERROR15)
(define-enum GLU_NURBS_ERROR16)
(define-enum GLU_NURBS_ERROR17)
(define-enum GLU_NURBS_ERROR18)
(define-enum GLU_NURBS_ERROR19)
(define-enum GLU_NURBS_ERROR20)
(define-enum GLU_NURBS_ERROR21)
(define-enum GLU_NURBS_ERROR22)
(define-enum GLU_NURBS_ERROR23)
(define-enum GLU_NURBS_ERROR24)
(define-enum GLU_NURBS_ERROR25)
(define-enum GLU_NURBS_ERROR26)
(define-enum GLU_NURBS_ERROR27)
(define-enum GLU_NURBS_ERROR28)
(define-enum GLU_NURBS_ERROR29)
(define-enum GLU_NURBS_ERROR30)
(define-enum GLU_NURBS_ERROR31)
(define-enum GLU_NURBS_ERROR32)
(define-enum GLU_NURBS_ERROR33)
(define-enum GLU_NURBS_ERROR34)
(define-enum GLU_NURBS_ERROR35)
(define-enum GLU_NURBS_ERROR36)
(define-enum GLU_NURBS_ERROR37)

;; Errors 
(define-enum GLU_INVALID_ENUM)
(define-enum GLU_INVALID_VALUE)
(define-enum GLU_OUT_OF_MEMORY)
(if "defined(GLU_INCOMPATIBLE_GL_VERSION)"
    (define-enum GLU_INCOMPATIBLE_GL_VERSION)
    )

;; New in GLU 1.1 
(define-enum GLU_VERSION)
(define-enum GLU_EXTENSIONS)

;; Local variables:
;; mode: scheme
;; end:
