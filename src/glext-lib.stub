;;;
;;; glext-lib.stub - glue functions for GL extensions
;;;
;;;  Copyright(C) 2004-2005 by Shiro Kawai (shiro@acm.org)
;;;
;;;  Permission to use, copy, modify, distribute this software and
;;;  accompanying documentation for any purpose is hereby granted,
;;;  provided that existing copyright notices are retained in all
;;;  copies and that this notice is included verbatim in all
;;;  distributions.
;;;  This software is provided as is, without express or implied
;;;  warranty.  In no circumstances the author(s) shall be liable
;;;  for any damages arising out of the use of this software.
;;;
;;;  $Id: glext-lib.stub,v 1.12 2005-06-08 12:26:15 shirok Exp $
;;;

"
#include \"gauche-gl.h\"
#include \"gl-syms.h\"
#include \"gl-ptrs.h\"
"

"#define CHECK_ERROR(msg__)                            \\
  do {                                                 \\
    GLenum e = glGetError();                           \\
    if (e != GL_NO_ERROR) {                            \\
      Scm_Error(\"%s: %s\", msg__, gluErrorString(e)); \\
    }                                                  \\
  } while (0)

/* GLhandle is (currently) typedef'ed to uint. */
#define SCM_GL_HANDLE_P(obj)  SCM_INTEGERP(obj)
#define SCM_MAKE_GL_HANDLE(handle)  Scm_MakeIntegerU(handle)
#define SCM_GL_HANDLE_VALUE(shandle) Scm_GetIntegerU(shandle)


"

;; NB: this should be taken care of by genstub.
(define-type <u32vector> "ScmU32Vector*" "u32vector"
  "SCM_U32VECTORP" "SCM_U32VECTOR")
(define-type <s32vector> "ScmS32Vector*" "s32vector"
  "SCM_S32VECTORP" "SCM_S32VECTOR")
(define-type <f32vector> "ScmF32Vector*" "f32vector"
  "SCM_F32VECTORP" "SCM_F32VECTOR")

;;=============================================================
;; GL 1.2
;;

(define-cproc gl-tex-image-3d (target::<fixnum> level::<fixnum>
                               internal-format::<fixnum>
                               width::<fixnum> height::<fixnum>
                               depth::<fixnum> border::<fixnum>
                               format::<fixnum> type::<fixnum>
                               texels)
  "int elttype, size; void *texelptr;
   size = Scm_GLPixelDataSize(width, height, format, type, &elttype, NULL);
   texelptr = Scm_GLPixelDataCheck(texels, elttype, size*depth);
   if (texelptr) {
     ENSURE(glTexImage3D);
     glTexImage3D(target, level, internal_format, width, height, depth, border, format, type, texelptr);
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-sub-image-3d (target::<fixnum> level::<fixnum>
                                   xoffset::<fixnum> yoffset::<fixnum>
                                   zoffset::<fixnum>
                                   width::<fixnum> height::<fixnum>
                                   depth::<fixnum>
                                   format::<fixnum> type::<fixnum>
                                   texels)
  "int elttype, size; void *texelptr;
   size = Scm_GLPixelDataSize(width, height, format, type, &elttype, NULL);
   texelptr = Scm_GLPixelDataCheck(texels, elttype, size*depth);
   if (texelptr) {
     ENSURE(glTexSubImage3D);
     glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texelptr);
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-copy-tex-sub-image-3d (target::<fixnum> level::<fixnum>
                                        xoffset::<fixnum> yoffset::<fixnum>
                                        zoffset::<fixnum>
                                        x::<fixnum> y::<fixnum>
                                        width::<fixnum> height::<fixnum>)
  "ENSURE(glCopyTexSubImage3D);
   glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-draw-range-elements (mode::<fixnum>
                                      start::<uint> end::<uint>
                                      indices)
  "ENSURE(glDrawRangeElements);
   if (SCM_U8VECTORP(indices)) {
     glDrawRangeElements(mode, start, end, 
                         SCM_U8VECTOR_SIZE(indices), GL_UNSIGNED_BYTE,
                         SCM_U8VECTOR_ELEMENTS(indices));
   } else if (SCM_U16VECTORP(indices)) {
     glDrawRangeElements(mode, start, end,
                         SCM_U16VECTOR_SIZE(indices), GL_UNSIGNED_SHORT,
                         SCM_U16VECTOR_ELEMENTS(indices));
   } else if (SCM_U32VECTORP(indices)) {
     glDrawRangeElements(mode, start, end,
                         SCM_U32VECTOR_SIZE(indices), GL_UNSIGNED_INT,
                         SCM_U32VECTOR_ELEMENTS(indices));
   } else {
     Scm_Error(\"bad argument for indices: %S, must be u8, u16 or u32vector\", indices);
   }
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; GL_ARB_imaging
;;

(define-cproc gl-color-table (target::<fixnum> internal-format::<fixnum>
                              width::<int> format::<int> type::<int>
                              data)
  "int elttype, size, packed;
   size = Scm_GLPixelDataSize(width, 1, format, type, &elttype, &packed);
   ENSURE(glColorTable);
   glColorTable(target, internal_format, width, format, type,
                Scm_GLPixelDataCheck(data, elttype, size));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-color-sub-table (target::<fixnum> start::<int> count::<int>
                                  format::<int> type::<int>
                                  data)
  "int elttype, size, packed;
   size = Scm_GLPixelDataSize(count, 1, format, type, &elttype, &packed);
   ENSURE(glColorSubTable);
   glColorSubTable(target, start, count, format, type,
                   Scm_GLPixelDataCheck(data, elttype, size));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-color-table-parameter (target::<fixnum> pname::<fixnum>
                                        param)
  "if (SCM_F32VECTORP(param)) {
    if (SCM_F32VECTOR_SIZE(param) != 4) goto err;
    ENSURE(glColorTableParameterfv);
    glColorTableParameterfv(target, pname, SCM_F32VECTOR_ELEMENTS(param));
  } else if (SCM_S32VECTORP(param)) {
    if (SCM_S32VECTOR_SIZE(param) != 4) goto err;
    ENSURE(glColorTableParameteriv);
    glColorTableParameteriv(target, pname, SCM_S32VECTOR_ELEMENTS(param));
  } else goto err;
  SCM_RETURN(SCM_UNDEFINED);
 err:
  Scm_Error(\"f32 or s32 vector of size 4 required, but got %S\", param);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-copy-color-sub-table (target::<fixnum> start::<fixnum>
                                       x::<int> y::<int> width::<int>)
  "ENSURE(glCopyColorSubTable);
   glCopyColorSubTable(target, start, x, y, width);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-copy-color-table (target::<fixnum> internal-format::<fixnum>
                                   x::<int> y::<int> width::<int>)
  "ENSURE(glCopyColorTable);
   glCopyColorTable(target, internal_format, x, y, width);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-color-table! (target::<fixnum> format::<fixnum>
                                   type::<fixnum> data)
  ;; TODO: check the type and size vailidity of data
  "ENSURE(glGetColorTable);
   if (!SCM_UVECTORP(data)) {
     Scm_Error(\"uniform vector required, but got %S\", data);
   }
   glGetColorTable(target, format, type, SCM_UVECTOR_ELEMENTS(data));
   SCM_RETURN(data);")

; gl-get-color-table-parameter

(define-cproc gl-blend-equation (mode::<fixnum>)
  "ENSURE(glBlendEquation);
   glBlendEquation(mode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-blend-color (red::<float> green::<float> blue::<float> alpha::<float>)
  "ENSURE(glBlendColor);
   glBlendColor(red, green, blue, alpha);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-histogram (target::<fixnum> width::<int> internal-format::<fixnum> sink::<boolean>)
  "ENSURE(glHistogram);
   glHistogram(target, width, internal_format, sink);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-reset-histogram (target::<fixnum>)
  "ENSURE(glResetHistogram);
   glResetHistogram(target);
   SCM_RETURN(SCM_UNDEFINED);")

; gl-get-histogram

; gl-get-histogram-parameter

(define-cproc gl-minmax (target::<fixnum> internal-format::<fixnum> sink::<boolean>)
  "ENSURE(glMinmax);
   glMinmax(target, internal_format, sink);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-reset-minmax (target::<fixnum>)
  "ENSURE(glResetMinmax);
   glResetMinmax(target);
   SCM_RETURN(SCM_UNDEFINED);")

; gl-get-minmax
; gl-get-minmax-parameter
; gl-convolution-filter-1d

(define-cproc gl-convolution-filter-2d (target::<fixnum>
                                        internal-format::<fixnum>
                                        width::<fixnum> height::<fixnum>
                                        format::<fixnum> type::<fixnum>
                                        data)
  "int elttype, size;
   size = Scm_GLPixelDataSize(width, height, format, type, &elttype, NULL);
   if (!SCM_UVECTORP(data)) {
     Scm_Error(\"uniform vector required, but got %S\", data);
   }
   if (SCM_UVECTOR_SIZE(data) < size) {
     Scm_Error(\"given vector is too short (minimum %d elements): %S\",
               size, data);
   }
   ENSURE(glConvolutionFilter2D);
   glConvolutionFilter2D(target, internal_format, width, height, 
                         format, type, SCM_UVECTOR_ELEMENTS(data));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-copy-convolution-filter-2d (target::<fixnum>
                                             internal-format::<fixnum>
                                             x::<fixnum> y::<fixnum>
                                             width::<fixnum> height::<fixnum>)
  "ENSURE(glCopyConvolutionFilter2D);
   glCopyConvolutionFilter2D(target, internal_format, x, y, width, height);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-separable-filter-2d (target::<fixnum>
                                      internal-format::<fixnum>
                                      width::<fixnum> height::<fixnum>
                                      format::<fixnum> type::<fixnum>
                                      row column)
  "if (!SCM_UVECTORP(row)) {
     Scm_Error(\"uniform vector required, but got %S\", row);
   }
   if (!SCM_UVECTORP(column)) {
     Scm_Error(\"uniform vector required, but got %S\", column);
   }
   ENSURE(glSeparableFilter2D);
   glSeparableFilter2D(target, internal_format, width, height, format, type,
                       SCM_UVECTOR_ELEMENTS(row),
                       SCM_UVECTOR_ELEMENTS(column));
   SCM_RETURN(SCM_UNDEFINED);")



; gl-convolution-parameter
; gl-copy-convolution-filter-1d
; gl-get-convolution-filter
; gl-get-convolution-parameter
; gl-get-separable-filter

;;=============================================================
;; GL_ARB_depth_texture
;;

;;=============================================================
;; GL_ARB_fragment_program
;;

;;=============================================================
;; GL_ARB_fragment_program_shadow
;;

;;=============================================================
;; GL_ARB_fragment_shader
;;

;;=============================================================
;; GL_ARB_matrix_palette
;;

;;=============================================================
;; GL_ARB_multisample
;;

(define-cproc gl-sample-coverage-arb (value::<float> invert::<boolean>)
  "ENSURE(glSampleCoverageARB);
   glSampleCoverageARB(value, invert);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; GL_ARB_multitexture
;;

(define-cproc gl-active-texture-arb (texture::<int>)
  "ENSURE(glActiveTextureARB);
   glActiveTextureARB(texture);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-client-active-texture-arb (texture::<int>)
  "ENSURE(glClientActiveTextureARB);
   glClientActiveTextureARB(texture);
   SCM_RETURN(SCM_UNDEFINED);")

; gl-multi-tex-coord1
; gl-multi-tex-coord2
; gl-multi-tex-coord3
; gl-multi-tex-coord4

;;=============================================================
;; GL_ARB_occlusion_query
;;

;; gl-genqueries-arb
;; gl-delete-queries-arb

(define-cproc gl-is-query-arb (query::<uint>)
  "ENSURE(glIsQueryARB);
   SCM_RETURN(SCM_MAKE_BOOL(glIsQueryARB(query)));")

(define-cproc gl-begin-query-arb (op::<uint> query::<uint>)
  "ENSURE(glBeginQueryARB);
   glBeginQueryARB(op, query);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-end-query-arb (op::<uint>)
  "ENSURE(glEndQueryARB);
   glEndQueryARB(op);
   SCM_RETURN(SCM_UNDEFINED);")

;; gl-get-query-rab
;; gl-get-query-object-arb

;;=============================================================
;; GL_ARB_point_parameters
;;

;;=============================================================
;; GL_ARB_point_sprite
;;

;;=============================================================
;; GL_ARB_shader_objects
;;

(define-type <gl-handle> "GLhandleARB" "glhandle"
  "SCM_GL_HANDLE_P" "SCM_GL_HANDLE_VALUE" "SCM_MAKE_GL_HANDLE")

(define-cproc gl-delete-object-arb (h::<gl-handle>)
  "ENSURE(glDeleteObjectARB);
   glDeleteObjectARB(h);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-handle-arb (type::<uint>)
  "ENSURE(glGetHandleARB);
   SCM_RETURN(SCM_MAKE_GL_HANDLE(glGetHandleARB(type)));")

(define-cproc gl-create-shader-object-arb (type::<uint>)
  "ENSURE(glCreateShaderObjectARB);
   SCM_RETURN(SCM_MAKE_GL_HANDLE(glCreateShaderObjectARB(type)));")

(define-cproc gl-shader-source-arb (shader::<gl-handle> strings)
  "GLint nstrings = Scm_Length(strings); int i = 0;
  GLint *lengths;
  GLcharARB **ss;
  ENSURE(glShaderSourceARB);
  if (nstrings < 0) goto einval;
  lengths = SCM_NEW_ATOMIC2(GLint*, nstrings*sizeof(GLint));
  /* NB: we can use atomic here, since all strings are pointed by the
     input parameter, and we don't need this array after calling
     glShaderSourceARB. */
  ss = SCM_NEW_ATOMIC2(GLcharARB**, nstrings*sizeof(GLcharARB*));
  ScmObj sp;
  SCM_FOR_EACH(sp, strings) {
    if (!SCM_STRINGP(SCM_CAR(sp))) goto einval;
    lengths[i] = SCM_STRING_SIZE(SCM_CAR(sp));
    ss[i] = (GLcharARB*)SCM_STRING_START(SCM_CAR(sp));
    i++;
  }
  glShaderSourceARB(shader, nstrings, (const GLcharARB**)ss, lengths);
  SCM_RETURN(SCM_UNDEFINED);
 einval:
  Scm_Error(\"list of strings required, but got %S\", strings);
  SCM_RETURN(SCM_UNDEFINED);
 ")

(define-cproc gl-compile-shader-arb (shader::<gl-handle>)
  "ENSURE(glCompileShaderARB);
   glCompileShaderARB(shader);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-create-program-object-arb ()
  "ENSURE(glCreateProgramObjectARB);
   SCM_RETURN(SCM_MAKE_GL_HANDLE(glCreateProgramObjectARB()));")

(define-cproc gl-attach-object-arb (program::<gl-handle> shader::<gl-handle>)
  "ENSURE(glAttachObjectARB);
   glAttachObjectARB(program, shader);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-detach-object-arb (program::<gl-handle> shader::<gl-handle>)
  "ENSURE(glDetachObjectARB);
   glDetachObjectARB(program, shader);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-link-program-arb (program::<gl-handle>)
  "ENSURE(glLinkProgramARB);
   glLinkProgramARB(program);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-use-program-object-arb (program::<gl-handle>)
  "ENSURE(glUseProgramObjectARB);
   glUseProgramObjectARB(program);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-validate-program-arb (program::<gl-handle>)
  "ENSURE(glValidateProgramARB);
   glValidateProgramARB(program);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-uniform-1f-arb (location::<int> v0)
  "ENSURE(glUniform1fARB);
   glUniform1fARB(location, (GLfloat)Scm_GetDouble(v0));
   SCM_RETURN(SCM_UNDEFINED);")
(define-cproc gl-uniform-2f-arb (location::<int> v0 v1)
  "ENSURE(glUniform2fARB);
   glUniform2fARB(location, (GLfloat)Scm_GetDouble(v0),
                  (GLfloat)Scm_GetDouble(v1));
   SCM_RETURN(SCM_UNDEFINED);")
(define-cproc gl-uniform-3f-arb (location::<int> v0 v1 v2)
  "ENSURE(glUniform3fARB);
   glUniform3fARB(location, (GLfloat)Scm_GetDouble(v0),
                  (GLfloat)Scm_GetDouble(v1),
                  (GLfloat)Scm_GetDouble(v2));
   SCM_RETURN(SCM_UNDEFINED);")
(define-cproc gl-uniform-4f-arb (location::<int> v0 v1 v2 v3)
  "ENSURE(glUniform4fARB);
   glUniform4fARB(location, (GLfloat)Scm_GetDouble(v0),
                  (GLfloat)Scm_GetDouble(v1),
                  (GLfloat)Scm_GetDouble(v2),
                  (GLfloat)Scm_GetDouble(v3));
   SCM_RETURN(SCM_UNDEFINED);")
(define-cproc gl-uniform-1i-arb (location::<int> v0)
  "ENSURE(glUniform1iARB);
   glUniform1iARB(location, Scm_GetInteger(v0));
   SCM_RETURN(SCM_UNDEFINED);")
(define-cproc gl-uniform-2i-arb (location::<int> v0 v1)
  "ENSURE(glUniform2iARB);
   glUniform2iARB(location, Scm_GetInteger(v0),
                  Scm_GetInteger(v1));
   SCM_RETURN(SCM_UNDEFINED);")
(define-cproc gl-uniform-3i-arb (location::<int> v0 v1 v2)
  "ENSURE(glUniform3iARB);
   glUniform3iARB(location, Scm_GetInteger(v0),
                  Scm_GetInteger(v1),
                  Scm_GetInteger(v2));
   SCM_RETURN(SCM_UNDEFINED);")
(define-cproc gl-uniform-4i-arb (location::<int> v0 v1 v2 v3)
  "ENSURE(glUniform4iARB);
   glUniform4iARB(location, Scm_GetInteger(v0),
                  Scm_GetInteger(v1),
                  Scm_GetInteger(v2),
                  Scm_GetInteger(v3));
   SCM_RETURN(SCM_UNDEFINED);")
  
(define-cproc gl-uniform-1fv-arb (location::<int> count::<uint> v::<f32vector>)
  "ENSURE(glUniform1fvARB);
   if (SCM_F32VECTOR_SIZE(v) < 1*count)
     Scm_Error(\"not enough value for gl-uniform-1fv-arb: %S\", v);
   glUniform1fvARB(location, count, SCM_F32VECTOR_ELEMENTS(v));
   SCM_RETURN(SCM_UNDEFINED);")
(define-cproc gl-uniform-2fv-arb (location::<int> count::<uint> v::<f32vector>)
  "ENSURE(glUniform2fvARB);
   if (SCM_F32VECTOR_SIZE(v) < 2*count) 
     Scm_Error(\"not enough value for gl-uniform-2fv-arb: %S\", v);
   glUniform2fvARB(location, count, SCM_F32VECTOR_ELEMENTS(v));
   SCM_RETURN(SCM_UNDEFINED);")
(define-cproc gl-uniform-3fv-arb (location::<int> count::<uint> v::<f32vector>)
  "ENSURE(glUniform3fvARB);
   if (SCM_F32VECTOR_SIZE(v) < 3*count) 
     Scm_Error(\"not enough value for gl-uniform-3fv-arb: %S\", v);
   glUniform3fvARB(location, count, SCM_F32VECTOR_ELEMENTS(v));
   SCM_RETURN(SCM_UNDEFINED);")
(define-cproc gl-uniform-4fv-arb (location::<int> count::<uint> v::<f32vector>)
  "ENSURE(glUniform4fvARB);
   if (SCM_F32VECTOR_SIZE(v) < 4*count) 
     Scm_Error(\"not enough value for gl-uniform-4fv-arb: %S\", v);
   glUniform4fvARB(location, count, SCM_F32VECTOR_ELEMENTS(v));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-uniform-1iv-arb (location::<int> count::<uint> v::<s32vector>)
  "ENSURE(glUniform1ivARB);
   if (SCM_S32VECTOR_SIZE(v) < 1*count) 
     Scm_Error(\"not enough value for gl-uniform-1iv-arb: %S\", v);
   glUniform1ivARB(location, count, SCM_S32VECTOR_ELEMENTS(v));
   SCM_RETURN(SCM_UNDEFINED);")
(define-cproc gl-uniform-2iv-arb (location::<int> count::<uint> v::<s32vector>)
  "ENSURE(glUniform2ivARB);
   if (SCM_S32VECTOR_SIZE(v) < 2*count) 
     Scm_Error(\"not enough value for gl-uniform-2iv-arb: %S\", v);
   glUniform2ivARB(location, count, SCM_S32VECTOR_ELEMENTS(v));
   SCM_RETURN(SCM_UNDEFINED);")
(define-cproc gl-uniform-3iv-arb (location::<int> count::<uint> v::<s32vector>)
  "ENSURE(glUniform3ivARB);
   if (SCM_S32VECTOR_SIZE(v) < 3*count) 
     Scm_Error(\"not enough value for gl-uniform-3iv-arb: %S\", v);
   glUniform3ivARB(location, count, SCM_S32VECTOR_ELEMENTS(v));
   SCM_RETURN(SCM_UNDEFINED);")
(define-cproc gl-uniform-4iv-arb (location::<int> count::<uint> v::<s32vector>)
  "ENSURE(glUniform4ivARB);
   if (SCM_S32VECTOR_SIZE(v) < 4*count) 
     Scm_Error(\"not enough value for gl-uniform-4iv-arb: %S\", v);
   glUniform4ivARB(location, count, SCM_S32VECTOR_ELEMENTS(v));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-uniform-matrix-2fv-arb (location::<int>
                                         count::<uint>
                                         transpose::<boolean>
                                         v::<f32vector>)
  "ENSURE(glUniformMatrix2fvARB);
   if (SCM_F32VECTOR_SIZE(v) < 4*count)
     Scm_Error(\"not enough value for gl-uniform-matrix-2fv-arb: %S\", v);
   glUniformMatrix2fvARB(location, count, transpose, 
                         SCM_F32VECTOR_ELEMENTS(v));
   SCM_RETURN(SCM_UNDEFINED);")
(define-cproc gl-uniform-matrix-3fv-arb (location::<int>
                                         count::<uint>
                                         transpose::<boolean>
                                         v::<f32vector>)
  "ENSURE(glUniformMatrix3fvARB);
   if (SCM_F32VECTOR_SIZE(v) < 9*count)
     Scm_Error(\"not enough value for gl-uniform-matrix-3fv-arb: %S\", v);
   glUniformMatrix3fvARB(location, count, transpose, 
                         SCM_F32VECTOR_ELEMENTS(v));
   SCM_RETURN(SCM_UNDEFINED);")
(define-cproc gl-uniform-matrix-4fv-arb (location::<int>
                                         count::<uint>
                                         transpose::<boolean>
                                         v::<f32vector>)
  "ENSURE(glUniformMatrix4fvARB);
   if (SCM_F32VECTOR_SIZE(v) < 16*count)
     Scm_Error(\"not enough value for gl-uniform-matrix-4fv-arb: %S\", v);
   glUniformMatrix4fvARB(location, count, transpose, 
                         SCM_F32VECTOR_ELEMENTS(v));
   SCM_RETURN(SCM_UNDEFINED);")

;; glGetObjectParameter
;;  In OpenGL 2.0 these functions only returns a single value.  In future
;;  they might be extended to return an array of values, hence we may need
;;  a similar mechanism of the gl-get-integer and gl-get-integer! pair
;;  later.

"
 static int get_object_parameter_num_values(GLenum pname)
 {
   switch (pname) {
     case GL_OBJECT_TYPE_ARB:;
     case GL_OBJECT_SUBTYPE_ARB:;
     case GL_OBJECT_DELETE_STATUS_ARB:;
     case GL_OBJECT_COMPILE_STATUS_ARB:;
     case GL_OBJECT_LINK_STATUS_ARB:;
     case GL_OBJECT_VALIDATE_STATUS_ARB:;
     case GL_OBJECT_INFO_LOG_LENGTH_ARB:;
     case GL_OBJECT_ATTACHED_OBJECTS_ARB:;
     case GL_OBJECT_ACTIVE_ATTRIBUTES_ARB:; 
     case GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB:;
     case GL_OBJECT_ACTIVE_UNIFORMS_ARB:;
     case GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB:;
     case GL_OBJECT_SHADER_SOURCE_LENGTH_ARB:;
      return 1;
     default:
      return 0;
   }
 }
"

(define-cproc gl-get-object-parameter-f-arb (object::<gl-handle>
                                             pname::<uint>)
  "GLfloat r;
  ENSURE(glGetObjectParameterfvARB);
  if (get_object_parameter_num_values(pname) != 1) {
    Scm_Error(\"invalid pname for gl-get-object-parameter-f-arb: %d\", pname);
  }
  glGetObjectParameterfvARB(object, pname, &r);
  SCM_RETURN(Scm_MakeFlonum((double)r));")

(define-cproc gl-get-object-parameter-i-arb (object::<gl-handle>
                                             pname::<uint>)
  "GLint r;
  ENSURE(glGetObjectParameterivARB);
  if (get_object_parameter_num_values(pname) != 1) {
    Scm_Error(\"invalid pname for gl-get-object-parameter-i-arb: %d\", pname);
  }
  glGetObjectParameterivARB(object, pname, &r);
  SCM_RETURN(Scm_MakeInteger(r));")

(define-cproc gl-get-info-log-arb (object::<gl-handle>)
  "GLint loglen = 0; GLcharARB *logstr;
   ENSURE(glGetObjectParameterivARB);
   ENSURE(glGetInfoLogARB);
   glGetObjectParameterivARB(object, GL_OBJECT_INFO_LOG_LENGTH_ARB, &loglen);
   logstr = SCM_NEW_ATOMIC2(char*, (loglen+1)*sizeof(GLcharARB));
   glGetInfoLogARB(object, loglen, NULL, logstr);
   CHECK_ERROR(\"glGetInfoLogARB\");
   SCM_RETURN(Scm_MakeString((const char*)logstr, loglen-1, -1, 0));")

(define-cproc gl-get-attached-objects-arb (program::<gl-handle>)
  "GLint numobjs = 0; GLhandleARB *objs; ScmObj r; int i;
   ENSURE(glGetObjectParameterivARB);
   ENSURE(glGetAttachedObjectsARB);
   glGetObjectParameterivARB(program, GL_OBJECT_ATTACHED_OBJECTS_ARB, &numobjs);
   CHECK_ERROR(\"glGetObjectParameterivARB\");
   objs = SCM_NEW_ATOMIC2(GLhandleARB*, numobjs * sizeof(GLhandleARB));
   glGetAttachedObjectsARB(program, numobjs, NULL, objs);
   CHECK_ERROR(\"glGetInfoLogARB\");
   r = Scm_MakeVector(numobjs, SCM_FALSE);
   for (i=0; i<numobjs; i++) {
     SCM_VECTOR_ELEMENT(r, i) = SCM_MAKE_GL_HANDLE(objs[i]);
   }
   SCM_RETURN(r);")

(define-cproc gl-get-uniform-location-arb (program::<gl-handle>
                                           expr::<string>)
  "GLint r;
   ENSURE(glGetUniformLocationARB);
   r  = glGetUniformLocationARB(program, (const GLcharARB*)Scm_GetStringConst(expr));
   CHECK_ERROR(\"glGetUniformLocationARB\");
   SCM_RETURN(Scm_MakeInteger(r));")

;; returns (size, type, name)
(define-cproc gl-get-active-uniform-arb (program::<gl-handle>
                                         index::<uint>)
  "GLint maxlen, size; GLsizei len; GLenum type; GLcharARB *namebuf;
   ENSURE(glGetObjectParameterivARB);
   ENSURE(glGetActiveUniformARB);
   glGetObjectParameterivARB(program, GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB,
                            &maxlen);
   CHECK_ERROR(\"glGetObjectParameterivARB\");
   namebuf = SCM_NEW_ATOMIC2(GLcharARB*, (maxlen+1)*sizeof(GLcharARB*));
   glGetActiveUniformARB(program, index, maxlen, &len, &size, &type, namebuf);
   CHECK_ERROR(\"glGetActiveUniformARB\");
   SCM_RETURN(Scm_Values3(Scm_MakeInteger(size),
                          Scm_MakeInteger(type),
                          Scm_MakeString(namebuf, len, -1, 0)));")

; get-uniform-f-arb
; get-uniform-i-arb

(define-cproc gl-get-shader-source-arb (object::<gl-handle>)
  "GLint srclen = 0; GLcharARB *srcstr;
   ENSURE(glGetObjectParameterivARB);
   ENSURE(glGetShaderSourceARB);
   glGetObjectParameterivARB(object, GL_OBJECT_SHADER_SOURCE_LENGTH_ARB, &srclen);
   srcstr = SCM_NEW_ATOMIC2(char*, (srclen+1)*sizeof(GLcharARB));
   glGetShaderSourceARB(object, srclen, NULL, srcstr);
   CHECK_ERROR(\"glGetShaderSourceARB\");
   SCM_RETURN(Scm_MakeString((const char*)srcstr, srclen-1, -1, 0));")

;;=============================================================
;; GL_ARB_shading_language_100
;;

;;=============================================================
;; GL_ARB_shadow
;;

;;=============================================================
;; GL_ARB_shadow_ambient
;;

;;=============================================================
;; GL_ARB_texture_border_clamp
;;

;;=============================================================
;; GL_ARB_texture_compression
;;

; gl-compressed-tex-image-3d-arb
; gl-compressed-tex-image-2d-arb
; gl-compressed-tex-image-1d-arb
; gl-compressed-tex-subimage-3d-arb
; gl-compressed-tex-subimage-2d-arb
; gl-compressed-tex-subimage-1d-arb
; gl-get-compressed-tex-image-arb

;;=============================================================
;; GL_ARB_texture_cube_map
;;

;;=============================================================
;; GL_ARB_texture_env_add
;;

;;=============================================================
;; GL_ARB_texture_env_combine
;;

;;=============================================================
;; GL_ARB_texture_env_dot3
;;

;;=============================================================
;; GL_ARB_texture_mirrored_repeat
;;

;;=============================================================
;; GL_ARB_texture_non_power_of_two
;;

;;=============================================================
;; GL_ARB_transpose_matrix
;;

(define-cproc gl-load-transpose-matrix-arb (m)
  "if (SCM_MATRIX4FP(m)) {
    ENSURE(glLoadTransposeMatrixfARB);
    glLoadTransposeMatrixfARB(SCM_MATRIX4F_D(m));
  } else if (SCM_F32VECTORP(m) && SCM_F32VECTOR_SIZE(m) == 16) {
    ENSURE(glLoadTransposeMatrixfARB);
    glLoadTransposeMatrixfARB(SCM_F32VECTOR_ELEMENTS(m));
  } else if (SCM_F64VECTORP(m) && SCM_F64VECTOR_SIZE(m) == 16) {
    ENSURE(glLoadTransposeMatrixdARB);
    glLoadTransposeMatrixdARB(SCM_F64VECTOR_ELEMENTS(m));
  } else {
     Scm_Error(\"3dmatrix, f32vector or f64vector of length 16 is required, but got %S\", m);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-mult-transpose-matrix-arb (m)
  "if (SCM_MATRIX4FP(m)) {
    ENSURE(glMultTransposeMatrixfARB);
    glMultTransposeMatrixfARB(SCM_MATRIX4F_D(m));
  } else if (SCM_F32VECTORP(m) && SCM_F32VECTOR_SIZE(m) == 16) {
    ENSURE(glMultTransposeMatrixfARB);
    glMultTransposeMatrixfARB(SCM_F32VECTOR_ELEMENTS(m));
  } else if (SCM_F64VECTORP(m) && SCM_F64VECTOR_SIZE(m) == 16) {
    ENSURE(glMultTransposeMatrixdARB);
    glMultTransposeMatrixdARB(SCM_F64VECTOR_ELEMENTS(m));
  } else {
     Scm_Error(\"3dmatrix, f32vector or f64vector of length 16 is required, but got %S\", m);
  }
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; GL_ARB_vertex_buffer_object
;;

(define-cproc gl-bind-buffer-arb (target::<int> buffer::<uint>)
  "ENSURE(glBindBufferARB);
   glBindBufferARB(target, buffer);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-delete-buffers-arb (buffers::<u32vector>)
  "ENSURE(glDeleteBuffersARB);
   glDeleteBuffersARB(SCM_U32VECTOR_SIZE(buffers),
                      SCM_U32VECTOR_ELEMENTS(buffers));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-gen-buffers-arb (n::<uint>)
  "ScmObj v = Scm_MakeU32Vector(n, 0);
   ENSURE(glGenBuffersARB);
   glGenBuffersARB(n, SCM_U32VECTOR_ELEMENTS(v));
   SCM_RETURN(v);")

(define-cproc gl-is-buffer-arb (buffer::<uint>)
  "ENSURE(glIsBufferARB);
   SCM_RETURN(SCM_MAKE_BOOL(glIsBufferARB(buffer)));")

; gl-buffer-data-arb
; gl-buffer-sub-data-arb
; gl-get-buffer-sub-data-arb
; gl-map-buffer-arb

(define-cproc gl-unmap-buffer-arb (target::<int>)
  "ENSURE(glUnmapBufferARB);
   SCM_RETURN(SCM_MAKE_BOOL(glUnmapBufferARB(target)));")

; glGetBufferParameterivARB
; glGetBufferPointervARB

;;=============================================================
;; GL_ARB_vertex_program
;;

(define-cproc gl-vertex-attrib-arb (index::<uint> arg0 &rest args)
  "if (SCM_POINT4FP(arg0) || SCM_VECTOR4FP(arg0)) {
    ENSURE(glVertexAttrib4fvARB);
    glVertexAttrib4fvARB(index, SCM_VECTOR4F_D(arg0));
  } else if (SCM_F32VECTORP(arg0)) {
    switch (SCM_F32VECTOR_SIZE(arg0)) {
      case 1: ENSURE(glVertexAttrib1fvARB);
              glVertexAttrib1fvARB(index, SCM_F32VECTOR_ELEMENTS(arg0));
              break;
      case 2: ENSURE(glVertexAttrib2fvARB);
              glVertexAttrib2fvARB(index, SCM_F32VECTOR_ELEMENTS(arg0));
              break;
      case 3: ENSURE(glVertexAttrib3fvARB);
              glVertexAttrib3fvARB(index, SCM_F32VECTOR_ELEMENTS(arg0));
              break;
      case 4: ENSURE(glVertexAttrib4fvARB);
              glVertexAttrib4fvARB(index, SCM_F32VECTOR_ELEMENTS(arg0));
              break;
      default: goto err;
    }
  } else if (SCM_S16VECTORP(arg0)) {
    switch (SCM_S16VECTOR_SIZE(arg0)) {
      case 1: ENSURE(glVertexAttrib1svARB);
              glVertexAttrib1svARB(index, SCM_S16VECTOR_ELEMENTS(arg0));
              break;
      case 2: ENSURE(glVertexAttrib2svARB);
              glVertexAttrib2svARB(index, SCM_S16VECTOR_ELEMENTS(arg0));
              break;
      case 3: ENSURE(glVertexAttrib3svARB);
              glVertexAttrib3svARB(index, SCM_S16VECTOR_ELEMENTS(arg0));
              break;
      case 4: ENSURE(glVertexAttrib4svARB);
              glVertexAttrib4svARB(index, SCM_S16VECTOR_ELEMENTS(arg0));
              break;
      default: goto err;
    }
  } else if (SCM_F64VECTORP(arg0)) {
    switch (SCM_F64VECTOR_SIZE(arg0)) {
      case 1: ENSURE(glVertexAttrib1dvARB);
              glVertexAttrib1dvARB(index, SCM_F64VECTOR_ELEMENTS(arg0));
              break;
      case 2: ENSURE(glVertexAttrib2dvARB);
              glVertexAttrib2dvARB(index, SCM_F64VECTOR_ELEMENTS(arg0));
              break;
      case 3: ENSURE(glVertexAttrib3dvARB);
              glVertexAttrib3dvARB(index, SCM_F64VECTOR_ELEMENTS(arg0));
              break;
      case 4: ENSURE(glVertexAttrib4dvARB);
              glVertexAttrib4dvARB(index, SCM_F64VECTOR_ELEMENTS(arg0));
              break;
      default: goto err;
    }
  } else if (SCM_S8VECTORP(arg0)) {
    switch (SCM_S8VECTOR_SIZE(arg0)) {
      case 4: ENSURE(glVertexAttrib4bvARB);
              glVertexAttrib4bvARB(index, SCM_S8VECTOR_ELEMENTS(arg0));
              break;
      default: goto err;
    }
  } else if (SCM_U8VECTORP(arg0)) {
    switch (SCM_U8VECTOR_SIZE(arg0)) {
      case 4: ENSURE(glVertexAttrib4ubvARB);
              glVertexAttrib4ubvARB(index, SCM_U8VECTOR_ELEMENTS(arg0));
              break;
      default: goto err;
    }
  } else if (SCM_U16VECTORP(arg0)) {
    switch (SCM_U16VECTOR_SIZE(arg0)) {
      case 4: ENSURE(glVertexAttrib4usvARB);
              glVertexAttrib4usvARB(index, SCM_U16VECTOR_ELEMENTS(arg0));
              break;
      default: goto err;
    }
  } else if (SCM_S32VECTORP(arg0)) {
    switch (SCM_S32VECTOR_SIZE(arg0)) {
      case 4: ENSURE(glVertexAttrib4ivARB);
              glVertexAttrib4ivARB(index, SCM_S32VECTOR_ELEMENTS(arg0));
              break;
      default: goto err;
    }
  } else if (SCM_U32VECTORP(arg0)) {
    switch (SCM_U32VECTOR_SIZE(arg0)) {
      case 4: ENSURE(glVertexAttrib4uivARB);
              glVertexAttrib4uivARB(index, SCM_U32VECTOR_ELEMENTS(arg0));
              break;
      default: goto err;
    }
  } else {
    int count = Scm_Length(args) + 1;
    switch (count) {
      case 1: ENSURE(glVertexAttrib1dARB);
              glVertexAttrib1dARB(index, Scm_GetDouble(arg0));
              break;
      case 2: ENSURE(glVertexAttrib2dARB);
              glVertexAttrib2dARB(index, Scm_GetDouble(arg0),
                                  Scm_GetDouble(SCM_CAR(args)));
              break;
      case 3: ENSURE(glVertexAttrib3dARB);
              glVertexAttrib3dARB(index, Scm_GetDouble(arg0),
                                  Scm_GetDouble(SCM_CAR(args)),
                                  Scm_GetDouble(SCM_CADR(args)));
              break;
      case 4: ENSURE(glVertexAttrib4dARB);
              glVertexAttrib4dARB(index, Scm_GetDouble(arg0),
                                  Scm_GetDouble(SCM_CAR(args)),
                                  Scm_GetDouble(SCM_CADR(args)),
                                  Scm_GetDouble(SCM_CAR(SCM_CDDR(args))));
              break;
      default: arg0 = Scm_Cons(arg0, args); goto err;
    }
  }
  SCM_RETURN(SCM_UNDEFINED);
 err:
  Scm_Error(\"bad argument(s) for gl-vertex-attrib-arb: %S\", arg0);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-vertex-attrib-4n-arb (index::<uint> arg0 &rest args)
  "if (SCM_POINT4FP(arg0) || SCM_VECTOR4FP(arg0)) {
    ENSURE(glVertexAttrib4fvARB);
    glVertexAttrib4fvARB(index, SCM_VECTOR4F_D(arg0));
  } else if (SCM_S16VECTORP(arg0)) {
    switch (SCM_S16VECTOR_SIZE(arg0)) {
      case 4: ENSURE(glVertexAttrib4NsvARB);
              glVertexAttrib4NsvARB(index, SCM_S16VECTOR_ELEMENTS(arg0));
              break;
      default: goto err;
    }
  } else if (SCM_S8VECTORP(arg0)) {
    switch (SCM_S8VECTOR_SIZE(arg0)) {
      case 4: ENSURE(glVertexAttrib4NbvARB);
              glVertexAttrib4NbvARB(index, SCM_S8VECTOR_ELEMENTS(arg0));
              break;
      default: goto err;
    }
  } else if (SCM_U8VECTORP(arg0)) {
    switch (SCM_U8VECTOR_SIZE(arg0)) {
      case 4: ENSURE(glVertexAttrib4NubvARB);
              glVertexAttrib4NubvARB(index, SCM_U8VECTOR_ELEMENTS(arg0));
              break;
      default: goto err;
    }
  } else if (SCM_U16VECTORP(arg0)) {
    switch (SCM_U16VECTOR_SIZE(arg0)) {
      case 4: ENSURE(glVertexAttrib4NusvARB);
              glVertexAttrib4NusvARB(index, SCM_U16VECTOR_ELEMENTS(arg0));
              break;
      default: goto err;
    }
  } else if (SCM_S32VECTORP(arg0)) {
    switch (SCM_S32VECTOR_SIZE(arg0)) {
      case 4: ENSURE(glVertexAttrib4NivARB);
              glVertexAttrib4NivARB(index, SCM_S32VECTOR_ELEMENTS(arg0));
              break;
      default: goto err;
    }
  } else if (SCM_U32VECTORP(arg0)) {
    switch (SCM_U32VECTOR_SIZE(arg0)) {
      case 4: ENSURE(glVertexAttrib4NuivARB);
              glVertexAttrib4NuivARB(index, SCM_U32VECTOR_ELEMENTS(arg0));
              break;
      default: goto err;
    }
  } else {
    int count = Scm_Length(args) + 1;
    switch (count) {
      case 4: ENSURE(glVertexAttrib4NubARB);
              glVertexAttrib4NubARB(index, 
                                    (GLubyte)Scm_GetIntegerU(arg0),
                                    (GLubyte)Scm_GetIntegerU(SCM_CAR(args)),
                                    (GLubyte)Scm_GetIntegerU(SCM_CADR(args)),
                                    (GLubyte)Scm_GetIntegerU(SCM_CAR(SCM_CDDR(args))));
              break;
      default: arg0 = Scm_Cons(arg0, args); goto err;
    }
  }
  SCM_RETURN(SCM_UNDEFINED);
 err:
  Scm_Error(\"bad argument(s) for gl-vertex-attrib-4n-arb: %S\", arg0);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-vertex-attrib-pointer-arb (index::<uint>
                                            size::<int>
                                            vec
                                            &optional
                                            (normalized::<boolean> #f)
                                            (stride::<fixnum> 0)
                                            (offset::<fixnum> 0))
  "if (size < 1 || size > 4) {
     Scm_Error(\"bad argument for size: %d, must be 1, 2, 3 or 4\", size);
   }
   if (SCM_POINT4F_ARRAY_P(vec)) {
     ENSURE(glVertexAttribPointerARB);
     glVertexAttribPointerARB(index, size, GL_FLOAT, normalized, stride,
                              (const GLvoid*)(SCM_POINT4F_ARRAY_D(vec)+offset));
   } else if (SCM_VECTOR4F_ARRAY_P(vec)) {
     ENSURE(glVertexAttribPointerARB);
     glVertexAttribPointerARB(index, size, GL_FLOAT, normalized, stride,
                              (const GLvoid*)(SCM_VECTOR4F_ARRAY_D(vec)+offset));
   } else if (SCM_F32VECTORP(vec)) {
     ENSURE(glVertexAttribPointerARB);
     glVertexAttribPointerARB(index, size, GL_FLOAT, normalized, stride,
                              (const GLvoid*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
   } else if (SCM_F64VECTORP(vec)) {
     ENSURE(glVertexAttribPointerARB);
     glVertexAttribPointerARB(index, size, GL_DOUBLE, normalized, stride,
                              (const GLvoid*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
   } else if (SCM_S32VECTORP(vec)) {
     ENSURE(glVertexAttribPointerARB);
     glVertexAttribPointerARB(index, size, GL_INT, normalized, stride,
                              (const GLvoid*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
   } else if (SCM_U32VECTORP(vec)) {
     ENSURE(glVertexAttribPointerARB);
     glVertexAttribPointerARB(index, size, GL_UNSIGNED_INT, normalized, stride,
                              (const GLvoid*)(SCM_U32VECTOR_ELEMENTS(vec)+offset));
   } else if (SCM_S16VECTORP(vec)) {
     ENSURE(glVertexAttribPointerARB);
     glVertexAttribPointerARB(index, size, GL_SHORT, normalized, stride,
                              (const GLvoid*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
   } else if (SCM_U16VECTORP(vec)) {
     ENSURE(glVertexAttribPointerARB);
     glVertexAttribPointerARB(index, size, GL_UNSIGNED_SHORT, normalized, stride,
                              (const GLvoid*)(SCM_U16VECTOR_ELEMENTS(vec)+offset));
   } else if (SCM_S8VECTORP(vec)) {
     ENSURE(glVertexAttribPointerARB);
     glVertexAttribPointerARB(index, size, GL_BYTE, normalized, stride,
                              (const GLvoid*)(SCM_S8VECTOR_ELEMENTS(vec)+offset));
   } else if (SCM_U8VECTORP(vec)) {
     ENSURE(glVertexAttribPointerARB);
     glVertexAttribPointerARB(index, size, GL_UNSIGNED_BYTE, normalized, stride,
                              (const GLvoid*)(SCM_U8VECTOR_ELEMENTS(vec)+offset));
   } else {
     Scm_Error(\"bad argument for vec: %S, must be an uniform vector, <pointer4f-array> or <vector4f-array>\", vec);
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-is-program-arb (prog-id::<int>)
  "ENSURE(glIsProgramARB);
  SCM_RETURN(SCM_MAKE_BOOL(glIsProgramARB(prog_id)));")

(define-cproc gl-enable-vertex-attrib-array-arb (index::<uint>)
  "ENSURE(glEnableVertexAttribArrayARB);
   glEnableVertexAttribArrayARB(index);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-disable-vertex-attrib-array-arb (index::<uint>)
  "ENSURE(glDisableVertexAttribArrayARB);
   glDisableVertexAttribArrayARB(index);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-program-string-arb (target::<int> format::<int> text::<string>)
   "GLint errorPos;
    char* str=(char*)SCM_STRING_START(text);
    ENSURE(glProgramStringARB);
    glProgramStringARB(target, format, strlen(str), str);
    glGetIntegerv(GL_PROGRAM_ERROR_POSITION_ARB, &errorPos);
    if(errorPos!=-1) {
        Scm_Error(\"Error in shader: %s\", glGetString(GL_PROGRAM_ERROR_STRING_ARB));
    }
    SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-bind-program-arb (target::<int> id::<int>)
  "ENSURE(glBindProgramARB);
   glBindProgramARB(target, id);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-delete-programs-arb (arg0)
  "if(SCM_INTEGERP(arg0)) {
     GLuint prog = Scm_GetInteger(arg0);
     ENSURE(glDeleteProgramsARB);
     glDeleteProgramsARB(1,&prog);
   } else if(SCM_U32VECTORP(arg0)) {
     ENSURE(glDeleteProgramsARB);
     glDeleteProgramsARB(SCM_S32VECTOR_SIZE(arg0), SCM_U32VECTOR_ELEMENTS(arg0));
   }
   SCM_RETURN(SCM_UNDEFINED); ")

(define-cproc gl-gen-programs-arb (n::<int>)
  "ScmU32Vector *v = SCM_U32VECTOR(Scm_MakeU32Vector(n, 0));
  ENSURE(glGenProgramsARB);
  glGenProgramsARB(n, SCM_U32VECTOR_ELEMENTS(v));
  SCM_RETURN(SCM_OBJ(v));")

; target should be GL_FRAGMENT_PROGRAM_ARB or GL_VERTEX_PROGRAM_ARB
(define-cproc gl-program-env-parameter-arb 
  (target::<int> param-id::<int> arg0 &rest args)
  "if(SCM_VECTOR4FP(arg0)) {
    ENSURE(glProgramEnvParameter4fvARB);
    glProgramEnvParameter4fvARB(target, param_id, SCM_VECTOR4F_D(arg0));
  }
  else if(SCM_F32VECTORP(arg0)) {
    if(SCM_F32VECTOR_SIZE(arg0)!=4) { goto err; }
    ENSURE(glProgramEnvParameter4fvARB);
    glProgramEnvParameter4fvARB(target, param_id, SCM_F32VECTOR_ELEMENTS(arg0));
  }
  else if(SCM_F64VECTORP(arg0)) {
    if(SCM_F64VECTOR_SIZE(arg0)!=4) { goto err; }
    ENSURE(glProgramEnvParameter4dvARB);
    glProgramEnvParameter4dvARB(target, param_id, SCM_F64VECTOR_ELEMENTS(arg0));
  } 
  else {
    if(1+Scm_Length(args)!=4) { goto err; }
    ENSURE(glProgramEnvParameter4dARB);
    glProgramEnvParameter4dARB(target, param_id, 
      Scm_GetDouble(arg0),
      Scm_GetDouble(SCM_CAR(args)),
      Scm_GetDouble(SCM_CADR(args)),
      Scm_GetDouble(SCM_CAR(SCM_CDDR(args))));
  }
  SCM_RETURN(SCM_UNDEFINED);
 err:
  Scm_Error(\"bad arguments for gl-program-env-parameter-arb: %S\", arg0);
  SCM_RETURN(SCM_UNDEFINED);")

; target should be GL_FRAGMENT_PROGRAM_ARB or GL_VERTEX_PROGRAM_ARB
(define-cproc gl-program-local-parameter-arb
  (target::<int> param-id::<int> arg0 &rest args)
  "if(SCM_VECTOR4FP(arg0)) {
    ENSURE(glProgramLocalParameter4fvARB);
    glProgramLocalParameter4fvARB(target, param_id, SCM_VECTOR4F_D(arg0));
  }
  else if(SCM_F32VECTORP(arg0)) {
    if(SCM_F32VECTOR_SIZE(arg0)!=4) { goto err; }
    ENSURE(glProgramLocalParameter4fvARB);
    glProgramLocalParameter4fvARB(target, param_id, SCM_F32VECTOR_ELEMENTS(arg0));
  }
  else if(SCM_F64VECTORP(arg0)) {
    if(SCM_F64VECTOR_SIZE(arg0)!=4) { goto err; }
    ENSURE(glProgramLocalParameter4dvARB);
    glProgramLocalParameter4dvARB(target, param_id, SCM_F64VECTOR_ELEMENTS(arg0));
  } else {
    if(1+Scm_Length(args)!=4) { goto err; }
    ENSURE(glProgramLocalParameter4dARB);
    glProgramLocalParameter4dARB(target, param_id, 
      Scm_GetDouble(arg0),
      Scm_GetDouble(SCM_CAR(args)),
      Scm_GetDouble(SCM_CADR(args)),
      Scm_GetDouble(SCM_CAR(SCM_CDDR(args))));
  }
  SCM_RETURN(SCM_UNDEFINED);
 err:
  Scm_Error(\"bad arguments for gl-program-local-parameter-arb: %S\", arg0);
  SCM_RETURN(SCM_UNDEFINED);")

; gl-get-program-env-parameter-arb
; gl-get-program-local-parameter-arb
; gl-get-program-arb
; gl-get-program-string-arb
; gl-get-vertex-attrib-arb
; gl-get-vertex-attrib-pointer-arb

;;=============================================================
;; GL_ARB_vertex_shader
;;

(define-cproc gl-bind-attrib-location-arb (program::<gl-handle>
                                           index::<uint>
                                           name::<string>)
  "ENSURE(glBindAttribLocationARB);
   glBindAttribLocationARB(program, index, Scm_GetStringConst(name));
   SCM_RETURN(SCM_UNDEFINED);")

;; returns three values: size, type and name
(define-cproc gl-get-active-attrib-arb (program::<gl-handle>
                                        index::<uint>)
  "
#define MAXNAMEBUFLEN 1024 /* NB: should be dynamically adjusted, using GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB */
  GLcharARB namebuf[MAXNAMEBUFLEN];
  GLint attrsize = 0; GLenum attrtype = 0;
  ENSURE(glGetActiveAttribARB);
  glGetActiveAttribARB(program, index, MAXNAMEBUFLEN-1, NULL,
                       &attrsize, &attrtype, namebuf);
  SCM_RETURN(Scm_Values3(Scm_MakeInteger(attrsize), Scm_MakeInteger(attrtype),
                         SCM_MAKE_STR_COPYING(namebuf)));
#undef MAXNAMEBUFLEN
   ")

(define-cproc gl-get-attrib-location-arb (program::<gl-handle>
                                          name::<string>)
  "GLint r;
   ENSURE(glGetAttribLocationARB);
   r = glGetAttribLocationARB(program, Scm_GetStringConst(name));
   SCM_RETURN(Scm_MakeInteger(r));")

;;=============================================================
;; GL_ARB_window_pos
;;

(define-cproc gl-window-pos-arb (arg0 &rest args)
  "if (SCM_F32VECTORP(arg0)) {
    switch (SCM_F32VECTOR_SIZE(arg0)) {
     case 2: ENSURE(glWindowPos2fvARB);
             glWindowPos2fvARB(SCM_F32VECTOR_ELEMENTS(arg0)); break;
     case 3: ENSURE(glWindowPos3fvARB); 
             glWindowPos3fvARB(SCM_F32VECTOR_ELEMENTS(arg0)); break;
     default: goto err;
    }
  } else if (SCM_S32VECTORP(arg0)) {
    switch (SCM_S32VECTOR_SIZE(arg0)) {
     case 2: ENSURE(glWindowPos2ivARB);
             glWindowPos2ivARB(SCM_S32VECTOR_ELEMENTS(arg0)); break;
     case 3: ENSURE(glWindowPos3ivARB);
             glWindowPos3ivARB(SCM_S32VECTOR_ELEMENTS(arg0)); break;
     default: goto err;
    }
  } else if (SCM_S16VECTORP(arg0)) {
    switch (SCM_S16VECTOR_SIZE(arg0)) {
     case 2: ENSURE(glWindowPos2svARB);
             glWindowPos2svARB(SCM_S16VECTOR_ELEMENTS(arg0)); break;
     case 3: ENSURE(glWindowPos3svARB);
             glWindowPos3svARB(SCM_S16VECTOR_ELEMENTS(arg0)); break;
     default: goto err;
    }
  } else if (SCM_F64VECTORP(arg0)) {
    switch (SCM_F64VECTOR_SIZE(arg0)) {
     case 2: ENSURE(glWindowPos2dvARB);
             glWindowPos2dvARB(SCM_F64VECTOR_ELEMENTS(arg0)); break;
     case 3: ENSURE(glWindowPos3dvARB);
             glWindowPos3dvARB(SCM_F64VECTOR_ELEMENTS(arg0)); break;
     default: goto err;
    }
  } else {
    int len = Scm_Length(args) + 1;
    switch (len) {
     case 2: ENSURE(glWindowPos2dARB);
             glWindowPos2dARB(Scm_GetDouble(arg0), 
                              Scm_GetDouble(SCM_CAR(args)));
             break;
     case 3: ENSURE(glWindowPos3dARB);
             glWindowPos3dARB(Scm_GetDouble(arg0), 
                              Scm_GetDouble(SCM_CAR(args)),
                              Scm_GetDouble(SCM_CADR(args)));
             break;
     default: arg0 = Scm_Cons(arg0, args); goto err;
    }
  }
  SCM_RETURN(SCM_UNDEFINED);
 err:
  Scm_Error(\"bad arguments for gl-window-pos: %S\", arg0);
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; GL_ATI_texture_float
;;

;;=============================================================
;; GL_ATI_draw_buffers
;;

(define-cproc gl-draw-buffers-ati (bufs::<s32vector>)
  "ENSURE(glDrawBuffersATI);
   glDrawBuffersATI(SCM_S32VECTOR_SIZE(bufs), 
                    (const GLenum *)SCM_S32VECTOR_ELEMENTS(bufs));
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; GL_EXT_422_pixels
;;

;;=============================================================
;; GL_EXT_abgr
;;

;;=============================================================
;; GL_EXT_bgra
;;

;;=============================================================
;; GL_EXT_blend_color
;;

(define-cproc gl-blend-color-ext (red::<float> green::<float>
                                  blue::<float> alpha::<float>)
  "ENSURE(glBlendColorEXT);
   glBlendColorEXT(red, green, blue, alpha);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; GL_EXT_blend_equation_separate
;;

(define-cproc gl-blend-equation-separate-ext (mode-rgb::<int>
                                              mode-alpha::<int>)
  "ENSURE(glBlendEquationSeparateEXT);
   glBlendEquationSeparateEXT(mode_rgb, mode_alpha);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; GL_EXT_blend_func_separate
;;

(define-cproc gl-blend-func-separate-ext (sfactor-rgb::<int>
                                          dfactor-rgb::<int>
                                          sfactor-alpha::<int>
                                          dfactor-alpha::<int>)
  "ENSURE(glBlendFuncSeparateEXT);
   glBlendFuncSeparateEXT(sfactor_rgb, dfactor_rgb, sfactor_alpha, dfactor_alpha);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; GL_EXT_blend_logic_op
;;

;;=============================================================
;; GL_EXT_blend_minmax
;;

(define-cproc gl-blend-equation-ext (mode::<int>)
  "ENSURE(glBlendEquationEXT);
   glBlendEquationEXT(mode);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; GL_EXT_blend_subtract
;;

;;=============================================================
;; GL_EXT_Cg_shader
;;

;;=============================================================
;; GL_EXT_polygon_offset
;;

;;=============================================================
;; GL_EXT_clip_volume_hint
;;

;;=============================================================
;; GL_EXT_cmyka
;;

;;=============================================================
;; GL_EXT_color_subtable
;;

;;=============================================================
;; GL_EXT_compiled_vertex_array
;;

(define-cproc gl-lock-arrays-ext (first::<int> count::<uint>)
  "ENSURE(glLockArraysEXT);
   glLockArraysEXT(first, count);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-unlock-arrays-ext ()
  "ENSURE(glUnlockArraysEXT);
   glUnlockArraysEXT();
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; GL_EXT_convolution
;;

;;=============================================================
;; GL_EXT_copy_texture
;;

;;=============================================================
;; GL_EXT_cull_vertex
;;

;;=============================================================
;; GL_EXT_depth_bounds_test
;;

(define-cproc gl-depth-bounds-ext (zmin::<double> zmax::<double>)
  "ENSURE(glDepthBoundsEXT);
   glDepthBoundsEXT(zmin, zmax);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; GL_EXT_draw_range_elements
;;

; gl-draw-range-elements-ext

;;=============================================================
;; GL_EXT_fog_coord
;;

; gl-fog-coord-ext
; gl-fog-coord-pointer-ext

;;=============================================================
;; GL_EXT_histogram
;;

;;=============================================================
;; GL_EXT_misc_attribute
;;

;;=============================================================
;; GL_EXT_index_array_formats
;;

;;=============================================================
;; GL_EXT_index_func
;;

;;=============================================================
;; GL_EXT_index_material
;;

;;=============================================================
;; GL_EXT_index_texture
;;

;;=============================================================
;; GL_EXT_light_texture
;;

;;=============================================================
;; GL_EXT_multi_draw_arrays
;;

; gl-multi-draw-arrays-ext
; gl-multi-draw-elements-ext

;;=============================================================
;; GL_EXT_packed_pixels
;;

;;=============================================================
;; GL_EXT_paletted_texture
;;

; gl-color-table-ext
; gl-color-sub-table-ext
; gl-get-color-table-ext
; gl-get-color-table-parameter-ext

;;=============================================================
;; GL_EXT_pixel_buffer_object
;;

;;=============================================================
;; GL_EXT_pixel_transform
;;

;;=============================================================
;; GL_EXT_pixel_transform_color_table
;;

;;=============================================================
;; GL_EXT_point_parameters
;;

; gl-point-parameter-ext

;;=============================================================
;; GL_EXT_rescale_normal
;;

;;=============================================================
;; GL_EXT_secondary_color
;;

;;=============================================================
;; GL_EXT_separate_specular_color
;;

;;=============================================================
;; GL_EXT_shadow_funcs
;;

;;=============================================================
;; GL_EXT_shared_texture_palette
;;

;;=============================================================
;; GL_EXT_stencil_two_side
;;

;;=============================================================
;; GL_EXT_stencil_wrap
;;

;;=============================================================
;; GL_EXT_subtexture
;;

;;=============================================================
;; GL_EXT_texture
;;

;;=============================================================
;; GL_EXT_texture_compression_s3tc
;;

;;=============================================================
;; GL_EXT_texture_cube_map
;;

;;=============================================================
;; GL_EXT_coordinate_frame
;;

;;=============================================================
;; GL_EXT_texture_edge_clamp
;;

;;=============================================================
;; GL_EXT_texture_env_add
;;

;;=============================================================
;; GL_EXT_texture_env_combine
;;

;;=============================================================
;; GL_EXT_texture_env_dot3
;;

;;=============================================================
;; GL_EXT_texture_filter_anisotropic
;;

;;=============================================================
;; GL_EXT_texture_lod_bias
;;

;;=============================================================
;; GL_EXT_texture_object
;;

;;=============================================================
;; GL_EXT_texture_perturb_normal
;;

;;=============================================================
;; GL_EXT_texture3D
;;

;;=============================================================
;; GL_EXT_texture_rectangle
;;

;;=============================================================
;; GL_EXT_vertex_array
;;

;;=============================================================
;; GL_EXT_vertex_weighting
;;

;;=============================================================
;; GL_NV_blend_square
;;

;;=============================================================
;; GL_NV_copy_depth_to_color
;;

;;=============================================================
;; GL_NV_depth_clamp
;;

;;=============================================================
;; GL_NV_element_array
;;

;;=============================================================
;; GL_NV_fence
;;

;;=============================================================
;; GL_NV_float_buffer
;;

;;=============================================================
;; GL_NV_fog_distance
;;

;;=============================================================
;; GL_NV_fragment_program
;;

;;=============================================================
;; GL_NV_fragment_program2
;;

;;=============================================================
;; GL_NV_half_float
;;

;;=============================================================
;; GL_NV_light_max_exponent
;;

;;=============================================================
;; GL_NV_multisample_filter_hint
;;

;;=============================================================
;; GL_NV_occlusion_query
;;

;;=============================================================
;; GL_NV_packed_depth_stencil
;;

;;=============================================================
;; GL_NV_pixel_buffer_object
;;

;;=============================================================
;; GL_NV_pixel_data_range
;;

;;=============================================================
;; GL_NV_point_sprite
;;

;;=============================================================
;; GL_NV_primitive_restart
;;

;;=============================================================
;; GL_NV_register_combiners
;;

;;=============================================================
;; GL_NV_register_combiners2
;;

;;=============================================================
;; GL_NV_stencil_two_side
;;

;;=============================================================
;; GL_NV_texgen_emboss
;;

;;=============================================================
;; GL_NV_texgen_reflection
;;

;;=============================================================
;; GL_NV_texture_compression_vtc
;;

;;=============================================================
;; GL_NV_texture_env_combine4
;;

;;=============================================================
;; GL_NV_texture_expand_normal
;;

;;=============================================================
;; GL_NV_texture_rectangle
;;

;;=============================================================
;; GL_NV_texture_shader
;;

;;=============================================================
;; GL_NV_texture_shader2
;;

;;=============================================================
;; GL_NV_texture_shader3
;;

;;=============================================================
;; GL_NV_vertex_array_range
;;

;;=============================================================
;; GL_NV_vertex_array_range2
;;

;;=============================================================
;; GL_NV_vertex_program
;;

;;=============================================================
;; GL_NV_vertex_program1_1
;;

;;=============================================================
;; GL_NV_vertex_program2
;;

;;=============================================================
;; GL_NV_vertex_program2_option
;;

;;=============================================================
;; GL_NV_vertex_program3
;;

;; Local variables:
;; mode: scheme
;; end:
