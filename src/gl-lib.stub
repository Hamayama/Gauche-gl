;;;
;;; gl-lib.stub - glue functions for GL
;;;
;;;  Copyright(C) 2001-2002 by Shiro Kawai (shiro@acm.org)
;;;
;;;  Permission to use, copy, modify, distribute this software and
;;;  accompanying documentation for any purpose is hereby granted,
;;;  provided that existing copyright notices are retained in all
;;;  copies and that this notice is included verbatim in all
;;;  distributions.
;;;  This software is provided as is, without express or implied
;;;  warranty.  In no circumstances the author(s) shall be liable
;;;  for any damages arising out of the use of this software.
;;;
;;;  $Id: gl-lib.stub,v 1.15 2002-07-19 02:33:27 shirok Exp $
;;;

"
#include \"gauche-gl.h\"
"

;; The functions are ordered in the same way as Mesa's header file.

"#define CHECK_ERROR(msg__)                            \\
  do {                                                 \\
    GLenum e = glGetError();                           \\
    if (e != GL_NO_ERROR) {                            \\
      Scm_Error(\"%s: %s\", msg__, gluErrorString(e)); \\
    }                                                  \\
  } while (0)
"
;;=============================================================
;; Miscellaneous
;;

(define-cproc gl-clear-index (c)
  (assert (real? c))
  "glClearIndex((GLfloat)c);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-clear-color (r g b a)
  (assert (real? r))
  (assert (real? g))
  (assert (real? b))
  (assert (real? a))
  "glClearColor((GLclampf)r, (GLclampf)g, (GLclampf)b, (GLclampf)a);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-clear (mask)
  "glClear((GLbitfield)Scm_GetUInteger(mask));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-index-mask (mask)
  "glIndexMask((GLuint)Scm_GetUInteger(mask));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-color-mask (r g b a)
  "glColorMask(!SCM_FALSEP(r), !SCM_FALSEP(g), !SCM_FALSEP(b), !SCM_FALSEP(a));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-alpha-func (func ref)
  (assert (small-integer? func))
  (assert (real? ref))
  "glAlphaFunc((GLenum)func, (GLclampf)ref);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-blend-func (func factor)
  (assert (small-integer? func))
  (assert (real? factor))
  "glBlendFunc((GLenum)func, (GLclampf)factor);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-logic-op (opcode)
  (assert (small-integer? opcode))
  "glLogicOp((GLenum)opcode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-cull-face (mode)
  (assert (small-integer? mode))
  "glCullFace((GLenum)mode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-front-face (mode)
  (assert (small-integer? mode))
  "glFrontFace((GLenum)mode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-point-size (size)
  (assert (real? size))
  "glPointSize((GLfloat)size);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-line-width (width)
  (assert (real? width))
  "glLineWidth((GLfloat)width);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-line-stipple (factor pat)
  (assert (small-integer? factor))
  (assert (small-integer? pat))
  "glLineStipple((GLint)factor, (GLushort)pat);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-polygon-mode (face mode)
  (assert (small-integer? face))
  (assert (small-integer? mode))
  "glPolygonMode((GLenum)face, (GLenum)mode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-polygon-stipple (mask)
  "  if (!SCM_U8VECTORP(mask) || SCM_U8VECTOR_SIZE(mask) != 128) {
    Scm_Error(\"u8vector of size 128 required, but got %S\", mask);
  }
  glPolygonStipple(SCM_U8VECTOR_ELEMENTS(mask));
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-edge-flag (flag)
  "glEdgeFlag(!SCM_FALSEP(flag));
   SCM_RETURN(SCM_UNDEFINED);")

;; glEdgeFlagv

(define-cproc gl-scissor (x y width height)
  (assert (exact? x))
  (assert (exact? y))
  (assert (exact? width))
  (assert (exact? height))
  "glScissor((GLint)x, (GLint)y, (GLsizei)width, (GLsizei)height);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-clip-plane (plane equation)
  (assert (small-integer? plane))
  "if (!SCM_F64VECTORP(equation) || SCM_F64VECTOR_SIZE(equation) != 4) {
   Scm_Error(\"f64vector of size 4 required for EQUATION, but got %S\", equation);
  }
  glClipPlane(plane, SCM_F64VECTOR_ELEMENTS(equation));
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-clip-plane (plane)
  (assert (small-integer? plane))
  "  ScmF64Vector *v = SCM_F64VECTOR(Scm_MakeF64Vector(4, 0.0));
  glGetClipPlane(plane, SCM_F64VECTOR_ELEMENTS(v));
  SCM_RETURN(SCM_OBJ(v));")

(define-cproc gl-draw-buffer (mode)
  (assert (small-integer? mode))
  "glDrawBuffer((GLenum)mode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-read-buffer (mode)
  (assert (small-integer? mode))
  "glReadBuffer((GLenum)mode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-enable (cap)
  (assert (small-integer? cap))
  "glEnable((GLenum)cap);
   SCM_RETURN(SCM_UNDEFINED);")
  
(define-cproc gl-disable (cap)
  (assert (small-integer? cap))
  "glDisable((GLenum)cap);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-is-enabled (cap)
  (assert (small-integer? cap))
  "SCM_RETURN(SCM_MAKE_BOOL(glIsEnabled((GLenum)cap)));")

(define-cproc gl-enable-client-state (cap)
  (assert (small-integer? cap))
  "glEnableClientState((GLenum)cap);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-disable-client-state (cap)
  (assert (small-integer? cap))
  "glDisableClientState((GLenum)cap);
   SCM_RETURN(SCM_UNDEFINED);")

;; Gauche-gl specific
(define-cproc gl-state-vector-size (state)
  (assert (small-integer? state))
  "SCM_RETURN(Scm_MakeInteger(Scm_GLStateInfoSize(state)));")

(define-cproc gl-get-boolean (state)
  (assert (small-integer? state))
  "int vsize = Scm_GLStateInfoSize(state);
  if (vsize <= 0)
    Scm_Error(\"you can't query state %x by glGetBooleanv\", state);
  if (vsize == 1) {
    GLboolean b;
    glGetBooleanv((GLenum)state, &b);
    SCM_RETURN(SCM_MAKE_INT(b));
  } else {
    ScmU8Vector *v = SCM_U8VECTOR(Scm_MakeU8Vector(vsize, 0));
    glGetBooleanv((GLenum)state, SCM_U8VECTOR_ELEMENTS(v));
    SCM_RETURN(SCM_OBJ(v));
  }")

(define-cproc gl-get-boolean! (vec state)
  (assert (small-integer? state))
  "int vsize;
  if (!SCM_U8VECTORP(vec)) Scm_Error(\"u8vector required, but got %S\", vec);
  vsize = Scm_GLStateInfoSize(state);
  if (vsize != SCM_U8VECTOR_SIZE(vec))
    Scm_Error(\"state %x needs a vector of size %d, but got %S\",
               state, vsize, vec);
  glGetBooleanv((GLenum)state, SCM_U8VECTOR_ELEMENTS(vec));
  SCM_RETURN(SCM_OBJ(vec));")

(define-cproc gl-get-integer (state)
  (assert (small-integer? state))
  "int vsize = Scm_GLStateInfoSize(state);
  if (vsize <= 0)
    Scm_Error(\"you can't query state %x by glGetIntegerv\", state);
  if (vsize == 1) {
    GLint i;
    glGetIntegerv((GLenum)state, &i);
    SCM_RETURN(Scm_MakeInteger(i));
  } else {
    ScmS32Vector *v = SCM_S32VECTOR(Scm_MakeS32Vector(vsize, 0));
    glGetIntegerv((GLenum)state, SCM_S32VECTOR_ELEMENTS(v));
    SCM_RETURN(SCM_OBJ(v));
  }")

(define-cproc gl-get-integer! (vec state)
  (assert (small-integer? state))
  "int vsize;
  if (!SCM_S32VECTORP(vec)) Scm_Error(\"s32vector required, but got %S\", vec);
  vsize = Scm_GLStateInfoSize(state);
  if (vsize != SCM_S32VECTOR_SIZE(vec))
    Scm_Error(\"state %x needs a vector of size %d, but got %S\",
               state, vsize, vec);
  glGetIntegerv((GLenum)state, SCM_S32VECTOR_ELEMENTS(vec));
  SCM_RETURN(SCM_OBJ(vec));")

(define-cproc gl-get-float (state)
  (assert (small-integer? state))
  "int vsize = Scm_GLStateInfoSize(state);
  if (vsize <= 0)
    Scm_Error(\"you can't query state %x by glGetFloatv\", state);
  if (vsize == 1) {
    GLfloat v;
    glGetFloatv((GLenum)state, &v);
    SCM_RETURN(Scm_MakeFlonum((double)v));
  } else {
    ScmF32Vector *v = SCM_F32VECTOR(Scm_MakeF32Vector(vsize, 0));
    glGetFloatv((GLenum)state, SCM_F32VECTOR_ELEMENTS(v));
    SCM_RETURN(SCM_OBJ(v));
  }")

(define-cproc gl-get-float! (vec state)
  (assert (small-integer? state))
  "int vsize;
  if (!SCM_F32VECTORP(vec)) Scm_Error(\"s32vector required, but got %S\", vec);
  vsize = Scm_GLStateInfoSize(state);
  if (vsize != SCM_F32VECTOR_SIZE(vec))
    Scm_Error(\"state %x needs a vector of size %d, but got %S\",
               state, vsize, vec);
  glGetFloatv((GLenum)state, SCM_F32VECTOR_ELEMENTS(vec));
  SCM_RETURN(SCM_OBJ(vec));")

(define-cproc gl-get-double (state)
  (assert (small-integer? state))
  "int vsize = Scm_GLStateInfoSize(state);
  if (vsize <= 0)
    Scm_Error(\"you can't query state %x by glGetDoublev\", state);
  if (vsize == 1) {
    GLdouble v;
    glGetDoublev((GLenum)state, &v);
    SCM_RETURN(Scm_MakeFlonum(v));
  } else {
    ScmF64Vector *v = SCM_F64VECTOR(Scm_MakeF64Vector(vsize, 0));
    glGetDoublev((GLenum)state, SCM_F64VECTOR_ELEMENTS(v));
    SCM_RETURN(SCM_OBJ(v));
  }")

(define-cproc gl-get-double! (vec state)
  (assert (small-integer? state))
  "int vsize;
  if (!SCM_F64VECTORP(vec)) Scm_Error(\"s32vector required, but got %S\", vec);
  vsize = Scm_GLStateInfoSize(state);
  if (vsize != SCM_F64VECTOR_SIZE(vec))
    Scm_Error(\"state %x needs a vector of size %d, but got %S\",
               state, vsize, vec);
  glGetDoublev((GLenum)state, SCM_F64VECTOR_ELEMENTS(vec));
  SCM_RETURN(SCM_OBJ(vec));")

;; glGetPointerv

(define-cproc gl-push-attrib (mask)
  "glPushAttrib((GLbitfield)Scm_GetUInteger(mask));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-pop-attrib ()
  "glPopAttrib();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-push-client-attrib (mask)
  "glPushClientAttrib((GLbitfield)Scm_GetUInteger(mask));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-pop-client-attrib ()
  "glPopClientAttrib();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-render-mode (mode)
  (assert (small-integer? mode))
  "SCM_RETURN(Scm_MakeInteger(glRenderMode((GLenum)mode)));")

(define-cproc gl-get-error ()
  "SCM_RETURN(Scm_MakeInteger(glGetError()));")

(define-cproc gl-get-string (name)
  (assert (small-integer? name))
  "SCM_RETURN(Scm_MakeString(glGetString(name), -1, -1, 0));")

(define-cproc gl-flush ()
  "glFlush();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-finish ()
  "glFinish();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-hint (target mode)
  (assert (exact? target))
  (assert (exact? mode))
  "glHint(target, mode);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Depth Buffer
;;

(define-cproc gl-clear-depth (depth)
  (assert (real? depth))
  "glClearDepth((GLclampd)depth);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-depth-func (func)
  (assert (small-integer? func))
  "glDepthFunc((GLenum)func);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-depth-mask (flag)
  "glDepthMask(!SCM_FALSEP(flag));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-depth-range (nearv farv)
  (assert (real? nearv))
  (assert (real? farv))
  "glDepthRange((GLclampd)nearv, (GLclampd)farv);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Accumulation Buffer
;;

(define-cproc gl-clear-accum (r g b a)
  (assert (real? r))
  (assert (real? g))
  (assert (real? b))
  (assert (real? a))
  "glClearAccum((GLfloat)r, (GLfloat)g, (GLfloat)b, (GLfloat)a);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-accum (op value)
  (assert (small-integer? op))
  (assert (real? value))
  "glAccum((GLenum)op, (GLfloat)value);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Transformation
;;

(define-cproc gl-matrix-mode (mode)
  (assert (small-integer? mode))
  "glMatrixMode(mode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-ortho (left right bottom top nearv farv)
  (assert (real? left))
  (assert (real? right))
  (assert (real? bottom))
  (assert (real? top))
  (assert (real? nearv))
  (assert (real? farv))
  "glOrtho((GLdouble)left, (GLdouble)right,
           (GLdouble)bottom, (GLdouble)top,
           (GLdouble)nearv, (GLdouble)farv);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-frustum (left right bottom top nearv farv)
  (assert (real? left))
  (assert (real? right))
  (assert (real? bottom))
  (assert (real? top))
  (assert (real? nearv))
  (assert (real? farv))
  "glFrustum((GLdouble)left, (GLdouble)right,
             (GLdouble)bottom, (GLdouble)top,
             (GLdouble)nearv, (GLdouble)farv);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-viewport (x y width height)
  (assert (small-integer? x))
  (assert (small-integer? y))
  (assert (small-integer? width))
  (assert (small-integer? height))
  "glViewport((GLint)x, (GLint)y, (GLsizei)width, (GLsizei)height);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-push-matrix ()
  "glPushMatrix();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-pop-matrix ()
  "glPopMatrix();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-load-identity ()
  "glLoadIdentity();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-load-matrix (m)
  "if (SCM_F32VECTORP(m) && SCM_F32VECTOR_SIZE(m) == 16) {
     glLoadMatrixf(SCM_F32VECTOR_ELEMENTS(m));
  } else if (SCM_F64VECTORP(m) && SCM_F64VECTOR_SIZE(m) == 16) {
     glLoadMatrixd(SCM_F64VECTOR_ELEMENTS(m));
  } else {
     Scm_Error(\"f32vector or f64vector of length 16 is required, but got %S\",
               m);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-rotate (angle x y z)
  (assert (real? angle))
  (assert (real? x))
  (assert (real? y))
  (assert (real? z))
  "glRotated((GLdouble)angle, (GLdouble)x, (GLdouble)y, (GLdouble)z);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-scale (x y z)
  (assert (real? x))
  (assert (real? y))
  (assert (real? z))
  "glScaled((GLdouble)x, (GLdouble)y, (GLdouble)z);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-translate (x y z)
  (assert (real? x))
  (assert (real? y))
  (assert (real? z))
  "glTranslated((GLdouble)x, (GLdouble)y, (GLdouble)z);
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Display lists
;;

(define-cproc gl-is-list (list)
  (assert (exact? list))
  "SCM_RETURN(SCM_MAKE_BOOL(glIsList(list)));")

(define-cproc gl-delete-lists (list range)
  (assert (exact? list))
  (assert (exact? range))
  "glDeleteLists((GLuint)list, (GLsizei)range);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-gen-lists (range)
  (assert (exact? range))
  "GLuint r = glGenLists(range);
   SCM_RETURN(Scm_MakeIntegerFromUI(r));")

(define-cproc gl-new-list (list mode)
  (assert (exact? list))
  (assert (exact? mode))
  "glNewList(list, mode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-end-list ()
  "glEndList();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-call-list (list)
  (assert (exact? list))
  "glCallList(list);
   SCM_RETURN(SCM_UNDEFINED);")

;; glCallLists  

(define-cproc gl-list-base (base)
  (assert (exact? base))
  "glListBase(base);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Drawing functions
;;

(define-cproc gl-begin (mode)
  (assert (small-integer? mode))
  "glBegin(mode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-end ()
  "glEnd();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-vertex (v &rest args)
  "if (SCM_F32VECTORP(v)) {
     switch (SCM_F32VECTOR_SIZE(v)) {
       case 3: glVertex3fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 2: glVertex2fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 4: glVertex4fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_F64VECTORP(v)) {
     switch (SCM_F64VECTOR_SIZE(v)) {
       case 3: glVertex3dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 2: glVertex2dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 4: glVertex4dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S32VECTORP(v)) {
     switch (SCM_S32VECTOR_SIZE(v)) {
       case 3: glVertex3iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       case 2: glVertex2iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       case 4: glVertex4iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S16VECTORP(v)) {
     switch (SCM_S16VECTOR_SIZE(v)) {
       case 3: glVertex3sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 2: glVertex2sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 4: glVertex4sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else {
     double val[4];
     int nvals = Scm_GLGetDoubles(v, args, val, 4, 2);
     switch (nvals) {
       case 3: glVertex3dv(val); break;
       case 2: glVertex2dv(val); break;
       case 4: glVertex4dv(val); break;
     }
  }
  SCM_RETURN(SCM_UNDEFINED);
 badarg:
  Scm_Error(\"bad argument for v: %S, must be one of f32, f64, s32 or s16 vector of length 2, 3, or 4.\", v);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-normal (v &rest args)
  "if (SCM_F32VECTORP(v) && SCM_F32VECTOR_SIZE(v) == 3) {
     glNormal3fv(SCM_F32VECTOR_ELEMENTS(v));
  } else if (SCM_F64VECTORP(v) && SCM_F64VECTOR_SIZE(v) == 3) {
     glNormal3dv(SCM_F64VECTOR_ELEMENTS(v));
  } else if (SCM_S32VECTORP(v) && SCM_S32VECTOR_SIZE(v) == 3) {
     glNormal3iv(SCM_S32VECTOR_ELEMENTS(v));
  } else if (SCM_S16VECTORP(v) && SCM_S16VECTOR_SIZE(v) == 3) {
     glNormal3sv(SCM_S16VECTOR_ELEMENTS(v));
  } else {
     double val[3];
     Scm_GLGetDoubles(v, args, val, 3, 3);
     glNormal3dv(val);
  }
  SCM_RETURN(SCM_UNDEFINED);")

;; glIndex*

(define-cproc gl-color (v &rest args)
  "if (SCM_F32VECTORP(v)) {
     switch (SCM_F32VECTOR_SIZE(v)) {
       case 3: glColor3fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 4: glColor4fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_F64VECTORP(v)) {
     switch (SCM_F64VECTOR_SIZE(v)) {
       case 3: glColor3dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 4: glColor4dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_U8VECTORP(v)) {
     switch (SCM_U8VECTOR_SIZE(v)) {
       case 3: glColor3ubv(SCM_U8VECTOR_ELEMENTS(v)); break;
       case 4: glColor4ubv(SCM_U8VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_U16VECTORP(v)) {
     switch (SCM_U16VECTOR_SIZE(v)) {
       case 3: glColor3usv(SCM_U16VECTOR_ELEMENTS(v)); break;
       case 4: glColor4usv(SCM_U16VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_U32VECTORP(v)) {
     switch (SCM_U32VECTOR_SIZE(v)) {
       case 3: glColor3uiv(SCM_U32VECTOR_ELEMENTS(v)); break;
       case 4: glColor4uiv(SCM_U32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S8VECTORP(v)) {
     switch (SCM_S8VECTOR_SIZE(v)) {
       case 3: glColor3bv(SCM_S8VECTOR_ELEMENTS(v)); break;
       case 4: glColor4bv(SCM_S8VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S16VECTORP(v)) {
     switch (SCM_S16VECTOR_SIZE(v)) {
       case 3: glColor3sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 4: glColor4sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S32VECTORP(v)) {
     switch (SCM_S32VECTOR_SIZE(v)) {
       case 3: glColor3iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       case 4: glColor4iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else {
     double val[4];
     int nvals = Scm_GLGetDoubles(v, args, val, 4, 3);
     switch (nvals) {
       case 3: glColor3dv(val); break;
       case 4: glColor4dv(val); break;
     }
  }
  SCM_RETURN(SCM_UNDEFINED);
 badarg:
  Scm_Error(\"bad argument for color: %S, must be an uniform vector of length 3 or 4\", v);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-coord (v &rest args)
  "if (SCM_F32VECTORP(v)) {
     switch (SCM_F32VECTOR_SIZE(v)) {
       case 2: glTexCoord2fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 1: glTexCoord1fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 3: glTexCoord3fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 4: glTexCoord4fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_F64VECTORP(v)) {
     switch (SCM_F64VECTOR_SIZE(v)) {
       case 2: glTexCoord2dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 1: glTexCoord1dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 3: glTexCoord3dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 4: glTexCoord4dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S32VECTORP(v)) {
     switch (SCM_S32VECTOR_SIZE(v)) {
       case 2: glTexCoord2iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       case 1: glTexCoord2iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       case 3: glTexCoord3iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       case 4: glTexCoord4iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S16VECTORP(v)) {
     switch (SCM_S16VECTOR_SIZE(v)) {
       case 2: glTexCoord2sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 1: glTexCoord1sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 3: glTexCoord3sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 4: glTexCoord4sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else {
     double val[4];
     int nvals = Scm_GLGetDoubles(v, args, val, 4, 1);
     switch (nvals) {
       case 2: glTexCoord2dv(val); break;
       case 1: glTexCoord1dv(val); break;
       case 3: glTexCoord3dv(val); break;
       case 4: glTexCoord4dv(val); break;
     }
  }
  SCM_RETURN(SCM_UNDEFINED);
 badarg:
  Scm_Error(\"bad argument for v: %S, must be one of f32, f64, s32 or s16 vector of length 1, 2, 3, or 4.\", v);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-raster-pos (v &rest args)
  "if (SCM_F32VECTORP(v)) {
     switch (SCM_F32VECTOR_SIZE(v)) {
       case 3: glRasterPos3fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 2: glRasterPos2fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 4: glRasterPos4fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_F64VECTORP(v)) {
     switch (SCM_F64VECTOR_SIZE(v)) {
       case 3: glRasterPos3dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 2: glRasterPos2dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 4: glRasterPos4dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S32VECTORP(v)) {
     switch (SCM_S32VECTOR_SIZE(v)) {
       case 3: glRasterPos3iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       case 2: glRasterPos2iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       case 4: glRasterPos4iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S16VECTORP(v)) {
     switch (SCM_S16VECTOR_SIZE(v)) {
       case 3: glRasterPos3sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 2: glRasterPos2sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 4: glRasterPos4sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else {
     double val[4];
     int nvals = Scm_GLGetDoubles(v, args, val, 4, 2);
     switch (nvals) {
       case 3: glRasterPos3dv(val); break;
       case 2: glRasterPos2dv(val); break;
       case 4: glRasterPos4dv(val); break;
     }
  }
  SCM_RETURN(SCM_UNDEFINED);
 badarg:
  Scm_Error(\"bad argument for v: %S, must be one of f32, f64, s32 or s16 vector of length 2, 3, or 4.\", v);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-rect (v1 v2 &rest args)
  "if (SCM_F32VECTORP(v1)) {
     if (SCM_F32VECTOR_SIZE(v1) != 2) goto badarg1;
     if (!SCM_F32VECTORP(v2) || SCM_F32VECTOR_SIZE(v2) != 2) goto badarg2;
     glRectfv(SCM_F32VECTOR_ELEMENTS(v1), SCM_F32VECTOR_ELEMENTS(v2));
  } else if (SCM_F64VECTORP(v1)) {
     if (SCM_F64VECTOR_SIZE(v1) != 2) goto badarg1;
     if (!SCM_F64VECTORP(v2) || SCM_F64VECTOR_SIZE(v2) != 2) goto badarg2;
     glRectdv(SCM_F64VECTOR_ELEMENTS(v1), SCM_F64VECTOR_ELEMENTS(v2));
  } else if (SCM_S32VECTORP(v1)) {
     if (SCM_S32VECTOR_SIZE(v1) != 2) goto badarg1;
     if (!SCM_S32VECTORP(v2) || SCM_S32VECTOR_SIZE(v2) != 2) goto badarg2;
     glRectiv(SCM_S32VECTOR_ELEMENTS(v1), SCM_S32VECTOR_ELEMENTS(v2));
  } else if (SCM_S16VECTORP(v1)) {
     if (SCM_S16VECTOR_SIZE(v1) != 2) goto badarg1;
     if (!SCM_S16VECTORP(v2) || SCM_S16VECTOR_SIZE(v2) != 2) goto badarg2;
     glRectsv(SCM_S16VECTOR_ELEMENTS(v1), SCM_S16VECTOR_ELEMENTS(v2));
  } else {
     double val[4];
     Scm_GLGetDoubles(v1, Scm_Cons(v2, args), val, 4, 4);
     glRectd(val[0], val[1], val[2], val[3]);
  }
  SCM_RETURN(SCM_UNDEFINED);
 badarg1:
  Scm_Error(\"bad argument for v1: %S, must be one of f32, f64, s32 or s16 vector of length 2\", v1);
  SCM_RETURN(SCM_UNDEFINED);
 badarg2:
  Scm_Error(\"bad argument for v2: %S, must be one of f32, f64, s32 or s16 vector of length 2\", v2);
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Vertex Arrays
;;

;; NOTE: it is caller's responsibility to guarantee VEC has enough length.
;; GL doesn't have interface to specify the boundary, so I can't detect
;; invalid length vector.

;; Scheme version doesn't have TYPE - it's derived from vector type.
;; STRIDE argument refers to the # of elements, rather than bytes.

(define-cproc gl-vertex-pointer (size vec &optional (stride 0) (offset 0))
  (assert (small-integer? size))
  (assert (small-integer? stride))
  (assert (small-integer? offset))
  "  if (size < 2 || size > 4) {
    Scm_Error(\"bad argument for size: %d, must be 2, 3 or 4\", size);
  }
  if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_F32VECTORP(vec)) {
    glVertexPointer(size, GL_FLOAT, stride*sizeof(GLfloat),
                    (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glVertexPointer(size, GL_DOUBLE, stride*sizeof(GLdouble),
                    (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S32VECTORP(vec)) {
    glVertexPointer(size, GL_INT, stride*sizeof(GLint),
                    (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glVertexPointer(size, GL_SHORT, stride*sizeof(GLshort),
                    (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, s32 or s16vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-normal-pointer (vec &optional (stride 0) (offset 0))
  (assert (small-integer? stride))
  (assert (small-integer? offset))
  "if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_F32VECTORP(vec)) {
    glNormalPointer(GL_FLOAT, stride*sizeof(GLfloat),
                    (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glNormalPointer(GL_DOUBLE, stride*sizeof(GLdouble),
                    (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S32VECTORP(vec)) {
    glNormalPointer(GL_INT, stride*sizeof(GLint),
                    (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glNormalPointer(GL_SHORT, stride*sizeof(GLshort),
                    (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S8VECTORP(vec)) {
    glNormalPointer(GL_BYTE, stride*sizeof(GLbyte),
                    (void*)(SCM_S8VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, s8, s16 or s32vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-color-pointer (size vec &optional (stride 0) (offset 0))
  (assert (small-integer? size))
  (assert (small-integer? stride))
  (assert (small-integer? offset))
  "  if (size < 3 || size > 4) {
    Scm_Error(\"bad argument for size: %d, must be 2, 3 or 4\", size);
  }
  if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_F32VECTORP(vec)) {
    glColorPointer(size, GL_FLOAT, stride*sizeof(GLfloat),
                  (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glColorPointer(size, GL_DOUBLE, stride*sizeof(GLdouble),
                   (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_U32VECTORP(vec)) {
    glColorPointer(size, GL_UNSIGNED_INT, stride*sizeof(GLuint),
                   (void*)(SCM_U32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_U16VECTORP(vec)) {
    glColorPointer(size, GL_UNSIGNED_SHORT, stride*sizeof(GLushort),
                   (void*)(SCM_U16VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_U8VECTORP(vec)) {
    glColorPointer(size, GL_UNSIGNED_BYTE, stride*sizeof(GLubyte),
                   (void*)(SCM_U8VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S32VECTORP(vec)) {
    glColorPointer(size, GL_INT, stride*sizeof(GLint),
                   (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glColorPointer(size, GL_SHORT, stride*sizeof(GLshort),
                   (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S8VECTORP(vec)) {
    glColorPointer(size, GL_BYTE, stride*sizeof(GLbyte),
                   (void*)(SCM_S8VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, s8, u8, s16, u16, s32 or u32vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-index-pointer (vec &optional (stride 0) (offset 0))
  (assert (small-integer? stride))
  (assert (small-integer? offset))
  "if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_S32VECTORP(vec)) {
    glNormalPointer(GL_INT, stride*sizeof(GLint),
                    (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glNormalPointer(GL_SHORT, stride*sizeof(GLshort),
                    (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_U8VECTORP(vec)) {
    glNormalPointer(GL_UNSIGNED_BYTE, stride*sizeof(GLubyte),
                    (void*)(SCM_U8VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F32VECTORP(vec)) {
    glNormalPointer(GL_FLOAT, stride*sizeof(GLfloat),
                    (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glNormalPointer(GL_DOUBLE, stride*sizeof(GLdouble),
                    (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, u8, s16 or s32 vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-coord-pointer (size vec &optional (stride 0) (offset 0))
  (assert (small-integer? size))
  (assert (small-integer? stride))
  (assert (small-integer? offset))
  "  if (size < 1 || size > 4) {
    Scm_Error(\"bad argument for size: %d, must be 1, 2, 3 or 4\", size);
  }
  if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_F32VECTORP(vec)) {
    glColorPointer(size, GL_FLOAT, stride*sizeof(GLfloat),
                  (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glColorPointer(size, GL_DOUBLE, stride*sizeof(GLdouble),
                   (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S32VECTORP(vec)) {
    glColorPointer(size, GL_INT, stride*sizeof(GLint),
                   (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glColorPointer(size, GL_SHORT, stride*sizeof(GLshort),
                   (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, s16 or s32vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

;; glEdgeFlagPointer - GLboolean vector maps u8vector
(define-cproc gl-edge-flag-pointer (vec &optional (stride 0) (offset 0))
  (assert (small-integer? stride))
  (assert (small-integer? offset))
  "if (!SCM_U8VECTORP(vec)) {
     Scm_Error(\"u8vector required for vec, but got %S\", vec);
   }
   glEdgeFlagPointer(stride, SCM_U8VECTOR_ELEMENTS(vec) + offset);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-array-element (ith)
  (assert (small-integer? ith))
  "glArrayElement(ith);
   SCM_RETURN(SCM_UNDEFINED);")

;; count and type is derived from indices vector
(define-cproc gl-draw-elements (mode indices)
  (assert (small-integer? mode))
  "if (SCM_U8VECTORP(indices)) {
    glDrawElements(mode, SCM_U8VECTOR_SIZE(indices), GL_UNSIGNED_BYTE,
                   SCM_U8VECTOR_ELEMENTS(indices));
  } else if (SCM_U16VECTORP(indices)) {
    glDrawElements(mode, SCM_U16VECTOR_SIZE(indices), GL_UNSIGNED_SHORT,
                   SCM_U16VECTOR_ELEMENTS(indices));
  } else if (SCM_U32VECTORP(indices)) {
    glDrawElements(mode, SCM_U32VECTOR_SIZE(indices), GL_UNSIGNED_INT,
                   SCM_U32VECTOR_ELEMENTS(indices));
  } else {
    Scm_Error(\"bad argument for indices: %S, must be u8, u16 or u32vector\", indices);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-draw-arrays (mode first count)
  (assert (small-integer? mode))
  (assert (small-integer? first))
  (assert (small-integer? count))
  "glDrawArrays(mode, first, count);
   SCM_RETURN(SCM_UNDEFINED);")

;; Note: we don't allow non-uniform vector for the interleaved arrays, so
;; the color component must be float.
(define-cproc gl-interleaved-arrays (format vec &optional (stride 0) (offset 0))
  (assert (small-integer? format))
  (assert (small-integer? stride))
  (assert (small-integer? offset))
  "  switch (format) {
     case GL_C4UB_V2F:; case GL_C4UB_V3F:; case GL_T2F_C4UB_V3F:
       Scm_Error(\"interleaved arrays with integer color component is not supported.\");
  }
  if (!SCM_F32VECTORP(vec)) {
    Scm_Error(\"bad argument for vec: %S, must be f32vector.\", vec);
  }
  glInterleavedArrays(format, stride * sizeof(GLfloat),
                      SCM_F32VECTOR_ELEMENTS(vec));
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Lighting
;;

(define-cproc gl-shade-model (mode)
  (assert (small-integer? mode))
  "glShadeModel(mode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-light (light pname param)
  (assert (small-integer? light))
  (assert (small-integer? pname))
  "switch (pname) {
   case GL_AMBIENT:; case GL_DIFFUSE:; case GL_SPECULAR:; case GL_POSITION:;
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
       glLightfv(light, pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
       glLightiv(light, pname, SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32 vector of length 4\", param);
     }
     break;
   case GL_SPOT_DIRECTION:
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 3) {
       glLightfv(light, pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 3) {
       glLightiv(light, pname, SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32 vector of length 3\", param);
     }
     break;
   default:
     if (SCM_EXACTP(param)) {
       glLighti(light, pname, (GLint)Scm_GetInteger(param));
     } else if (SCM_REALP(param)) {
       glLightf(light, pname, (GLfloat)Scm_GetDouble(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be a real number.\", param);
     }
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-light (light pname)
  (assert (small-integer? light))
  (assert (small-integer? pname))
  "switch (pname) {
   case GL_AMBIENT:; case GL_DIFFUSE:; case GL_SPECULAR:; case GL_POSITION:
     {
       ScmF32Vector *v = SCM_F32VECTOR(Scm_MakeF32Vector(4, 0.0));
       glGetLightfv(light, pname, SCM_F32VECTOR_ELEMENTS(v));
       SCM_RETURN(SCM_OBJ(v));
     }
   case GL_SPOT_DIRECTION:
     {
       ScmF32Vector *v = SCM_F32VECTOR(Scm_MakeF32Vector(3, 0.0));
       glGetLightfv(light, pname, SCM_F32VECTOR_ELEMENTS(v));
       SCM_RETURN(SCM_OBJ(v));
     }
   default:
     {
       float v;
       glGetLightfv(light, pname, &v);
       SCM_RETURN(Scm_MakeFlonum((double)v));
     }
   }")

(define-cproc gl-light-model (pname param)
  (assert (small-integer? pname))
  "switch (pname) {
    case GL_LIGHT_MODEL_AMBIENT:
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
       glLightModelfv(pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
       glLightModeliv(pname, SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32 vector of length 4\", param);
     }
     break;
    default:
     glLightModeli(pname, !SCM_FALSEP(param));
     break;
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-material (face pname param)
  (assert (small-integer? face))
  (assert (small-integer? pname))
  "switch (pname) {
   case GL_AMBIENT:; case GL_DIFFUSE:; case GL_SPECULAR:; case GL_EMISSION:;
   case GL_AMBIENT_AND_DIFFUSE:;
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
       glMaterialfv(face, pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
       glMaterialiv(face, pname, SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32 vector of length 4\", param);
     }
     break;
   case GL_COLOR_INDEXES:
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 3) {
       glMaterialfv(face, pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 3) {
       glMaterialiv(face, pname, SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32vector of length 3\", param);
     }
     break;
   default:
     if (SCM_REALP(param)) {
       glMaterialf(face, pname, (GLfloat)Scm_GetDouble(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be a real number.\", param);
     }
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-material (face pname)
  (assert (small-integer? face))
  (assert (small-integer? pname))
  "switch (pname) {
   case GL_AMBIENT:; case GL_DIFFUSE:; case GL_SPECULAR:; case GL_EMISSION:;
     {
       ScmF32Vector *v = SCM_F32VECTOR(Scm_MakeF32Vector(4, 0.0));
       glGetMaterialfv(face, pname, SCM_F32VECTOR_ELEMENTS(v));
       SCM_RETURN(SCM_OBJ(v));
     }
   case GL_COLOR_INDEXES:
     {
       ScmS32Vector *v = SCM_S32VECTOR(Scm_MakeS32Vector(3, 0.0));
       glGetMaterialiv(face, pname, SCM_S32VECTOR_ELEMENTS(v));
       SCM_RETURN(SCM_OBJ(v));
     }
   case GL_SHININESS:
     {
       float v;
       glGetMaterialfv(face, pname, &v);
       SCM_RETURN(Scm_MakeFlonum((double)v));
     }
   default:
     Scm_Error(\"bad pname: %d\", pname);
     SCM_RETURN(SCM_UNDEFINED);
   }")

(define-cproc gl-color-material (face mode)
  (assert (small-integer? face))
  (assert (small-integer? mode))
  "glColorMaterial(face, mode);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Raster functions
;;

(define-cproc gl-pixel-zoom (xfactor yfactor)
  (assert (real? xfactor))
  (assert (real? yfactor))
  "glPixelZoom(xfactor, yfactor);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-pixel-store (pname param)
  (assert (small-integer? pname))
  "if (SCM_EXACTP(param)) {
     glPixelStorei(pname, Scm_GetInteger(param));
   } else if (SCM_FLONUMP(param)) {
     glPixelStoref(pname, (float)SCM_FLONUM_VALUE(param));
   } else {
     Scm_Error(\"real number required for param, but got %S\", param);
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-pixel-map (map values)
  (assert (small-integer? map))
  "if (SCM_U32VECTORP(values)) {
    glPixelMapuiv(map, SCM_U32VECTOR_SIZE(values),
                  SCM_U32VECTOR_ELEMENTS(values));
  } else if (SCM_U16VECTORP(values)) {
    glPixelMapusv(map, SCM_U16VECTOR_SIZE(values),
                  SCM_U16VECTOR_ELEMENTS(values));
  } else if (SCM_F32VECTORP(values)) {
    glPixelMapfv(map, SCM_F32VECTOR_SIZE(values),
                 SCM_F32VECTOR_ELEMENTS(values));
  } else {
     Scm_Error(\"map value vector must be u16, u32 or f32 vector, but got %S\",
               values);
  }
   SCM_RETURN(SCM_UNDEFINED);")

;; values must have enough size
(define-cproc gl-get-pixel-map! (map values)
  (assert (small-integer? map))
  "if (SCM_U32VECTORP(values)) {
    glGetPixelMapuiv(map, SCM_U32VECTOR_ELEMENTS(values));
  } else if (SCM_U16VECTORP(values)) {
    glGetPixelMapusv(map, SCM_U16VECTOR_ELEMENTS(values));
  } else if (SCM_F32VECTORP(values)) {
    glGetPixelMapfv(map, SCM_F32VECTOR_ELEMENTS(values));
  } else {
     Scm_Error(\"map value vector must be u16, u32 or f32 vector, but got %S\",
               values);
  }
  SCM_RETURN(values);")

;; allocate the vector in it.  type can be a class 
;; <u32vector> (default), <u16vector> or <f32vector>
(define-cproc gl-get-pixel-map (map &optional type)
  (assert (small-integer? map))
  " int size; ScmObj vec = SCM_UNDEFINED;
  glGetIntegerv(map, &size);
  CHECK_ERROR(\"couldn't get pixel map size\");
  SCM_ASSERT(size >= 0);
  if (SCM_UNBOUNDP(type) || type == SCM_OBJ(SCM_CLASS_U32VECTOR)) {
    vec = Scm_MakeU32Vector(size, 0);
    glGetPixelMapuiv(map, SCM_U32VECTOR_ELEMENTS(vec));
  } else if (type == SCM_OBJ(SCM_CLASS_U16VECTOR)) {
    vec = Scm_MakeU16Vector(size, 0);
    glGetPixelMapusv(map, SCM_U16VECTOR_ELEMENTS(vec));
  } else if (type == SCM_OBJ(SCM_CLASS_F32VECTOR)) {
    vec = Scm_MakeF32Vector(size, 0);
    glGetPixelMapfv(map, SCM_F32VECTOR_ELEMENTS(vec));
  } else {
     Scm_Error(\"pixel map vector class must be either <u32vector>, <u16vector> or <f32vector>, but got %S\", type);
  }
  SCM_RETURN(vec);")

(define-cproc gl-bitmap (width height xbo ybo xbi ybi bitmap)
  (assert (exact? width))
  (assert (exact? height))
  (assert (exact? xbo))
  (assert (exact? ybo))
  (assert (exact? xbi))
  (assert (exact? ybi))
  "if (!SCM_U8VECTORP(bitmap)) {
    Scm_Error(\"bitmap must be an u8vector, but got %S\", bitmap);
  }
  if (SCM_U8VECTOR_SIZE(bitmap) != ((width+7)/8)*height) {
    Scm_Error(\"size (width=%d, height=%d) doesn't match bitmap vector %S\",
              width, height, bitmap);
  }
  glBitmap(width, height, xbo, ybo, xbi, ybi, SCM_U8VECTOR_ELEMENTS(bitmap));
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-read-pixels (x y width height format type)
  (assert (small-integer? x))
  (assert (small-integer? y))
  (assert (small-integer? width))
  (assert (small-integer? height))
  (assert (small-integer? format))
  (assert (small-integer? type))
  "  int elttype, size, packed; ScmObj vec = SCM_UNDEFINED;
  size = Scm_GLPixelDataSize(width, height, format, type, &elttype, &packed);
  switch (elttype) {
    case SCM_GL_BYTE:
      vec = Scm_MakeS8Vector(size, 0);
      glReadPixels(x, y, width, height, format, type,
                   SCM_S8VECTOR_ELEMENTS(vec));
      break;
    case SCM_GL_UBYTE:
      vec = Scm_MakeU8Vector(size, 0);
      glReadPixels(x, y, width, height, format, type,
                   SCM_U8VECTOR_ELEMENTS(vec));
      break;
    case SCM_GL_SHORT:
      vec = Scm_MakeS16Vector(size, 0);
      glReadPixels(x, y, width, height, format, type,
                   SCM_S16VECTOR_ELEMENTS(vec));
      break;
    case SCM_GL_USHORT:
      vec = Scm_MakeU16Vector(size, 0);
      glReadPixels(x, y, width, height, format, type,
                   SCM_U16VECTOR_ELEMENTS(vec));
      break;
    case SCM_GL_INT:
      vec = Scm_MakeS32Vector(size, 0);
      glReadPixels(x, y, width, height, format, type,
                   SCM_S32VECTOR_ELEMENTS(vec));
      break;
    case SCM_GL_UINT:
      vec = Scm_MakeU32Vector(size, 0);
      glReadPixels(x, y, width, height, format, type,
                   SCM_U32VECTOR_ELEMENTS(vec));
      break;
    case SCM_GL_FLOAT:
      vec = Scm_MakeF32Vector(size, 0);
      glReadPixels(x, y, width, height, format, type,
                   SCM_F32VECTOR_ELEMENTS(vec));
      break;
  }
  SCM_RETURN(vec);")

; gl-read-pixels!

(define-cproc gl-draw-pixels (width height format type pixels)
  (assert (small-integer? width))
  (assert (small-integer? height))
  (assert (small-integer? format))
  (assert (small-integer? type))
  "  int elttype, size, packed; ScmObj vec = SCM_UNDEFINED;
  size = Scm_GLPixelDataSize(width, height, format, type, &elttype, &packed);
  switch (elttype) {
    case SCM_GL_BYTE:
      if (!SCM_S8VECTORP(pixels)) {
        Scm_Error(\"s8vector required, but got %S\", pixels);
      }
      glDrawPixels(width, height, format, type,
                   SCM_S8VECTOR_ELEMENTS(pixels));
      break;
    case SCM_GL_UBYTE:
      if (!SCM_U8VECTORP(pixels)) {
        Scm_Error(\"u8vector required, but got %S\", pixels);
      }
      glDrawPixels(width, height, format, type,
                   SCM_U8VECTOR_ELEMENTS(pixels));
      break;

    case SCM_GL_SHORT:
      if (!SCM_S16VECTORP(pixels)) {
        Scm_Error(\"s16vector required, but got %S\", pixels);
      }
      glDrawPixels(width, height, format, type,
                   SCM_S16VECTOR_ELEMENTS(pixels));
      break;
    case SCM_GL_USHORT:
      if (!SCM_U16VECTORP(pixels)) {
        Scm_Error(\"u16vector required, but got %S\", pixels);
      }
      glDrawPixels(width, height, format, type,
                   SCM_U16VECTOR_ELEMENTS(pixels));
      break;

    case SCM_GL_INT:
      if (!SCM_S32VECTORP(pixels)) {
        Scm_Error(\"s32vector required, but got %S\", pixels);
      }
      glDrawPixels(width, height, format, type,
                   SCM_S32VECTOR_ELEMENTS(pixels));
      break;
    case SCM_GL_UINT:
      if (!SCM_U32VECTORP(pixels)) {
        Scm_Error(\"u32vector required, but got %S\", pixels);
      }
      glDrawPixels(width, height, format, type,
                   SCM_U32VECTOR_ELEMENTS(pixels));
      break;

    case SCM_GL_FLOAT:
      if (!SCM_F32VECTORP(pixels)) {
        Scm_Error(\"f32vector required, but got %S\", pixels);
      }
      glDrawPixels(width, height, format, type,
                   SCM_F32VECTOR_ELEMENTS(pixels));
      break;
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-copy-pixels (x y width height type)
  (assert (small-integer? x))
  (assert (small-integer? y))
  (assert (small-integer? width))
  (assert (small-integer? height))
  (assert (small-integer? type))
  "glCopyPixels(x, y, width, height, type);
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Stenciling
;;

(define-cproc gl-stencil-func (func ref mask)
  (assert (small-integer? func))
  (assert (exact? ref))
  (assert (exact? mask))
  "glStencilFunc((GLenum)func, (GLint)ref, (GLuint)mask);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-stencil-mask (mask)
  (assert (exact? mask))
  "glStencilMask((GLuint)mask);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-stencil-op (func zfail zpass)
  (assert (small-integer? func))
  (assert (small-integer? zfail))
  (assert (small-integer? zpass))
  "glStencilFunc((GLenum)func, (GLenum)zfail, (GLenum)zpass); 
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-clear-stencil (s)
  (assert (exact? s))
  "glClearStencil((GLint)s);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Texture mapping
;;

(define-cproc gl-tex-gen (coord pname param)
  (assert (small-integer? coord))
  (assert (small-integer? pname))
  "switch (pname) {
    case GL_TEXTURE_GEN_MODE:
      if (!SCM_INTP(param)) {
        Scm_Error(\"integer parameter required for GL_TEXTURE_GEN_MODE, but got %S\", param);
      }
      glTexGeni(coord, pname, SCM_INT_VALUE(param));
      break;
    case GL_OBJECT_PLANE:;
    case GL_EYE_PLANE:;
      if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
        glTexGenfv(coord, pname, SCM_F32VECTOR_ELEMENTS(param));
      } else if (SCM_F64VECTORP(param) && SCM_F64VECTOR_SIZE(param) == 4) {
        glTexGendv(coord, pname, SCM_F64VECTOR_ELEMENTS(param));
      } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
        glTexGeniv(coord, pname, SCM_S32VECTOR_ELEMENTS(param));
      } else {
        Scm_Error(\"s32, f32 or f64 vector of size 4 is required for parameter, but got %S\", param);
      }
      break;
     default:
      Scm_Error(\"unknown or unsupported glTexGen pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-env (target pname param)
  (assert (small-integer? target))
  (assert (small-integer? pname))
  "switch (pname) {
    case GL_TEXTURE_ENV_MODE:
      if (SCM_INTP(param)) {
        glTexEnvi(target, pname, SCM_INT_VALUE(param));
      } else {
        Scm_Error(\"integer parameter required for GL_TEXTURE_ENV_MODE, but got %S\", param);
      }
      break;
    case GL_TEXTURE_ENV_COLOR:
      if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
        glTexEnvfv(target, pname, SCM_F32VECTOR_ELEMENTS(param));
      } else {
        Scm_Error(\"f32 vector of size 4 is required for GL_TEXTURE_ENV_COLOR parameter, but got %S\", param);
      }
      break;
    default:
      Scm_Error(\"unknown or unsupported glTexEnv pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-parameter (target pname param)
  (assert (small-integer? target))
  (assert (small-integer? pname))
  "switch (pname) {
     case GL_TEXTURE_WRAP_S:;
     case GL_TEXTURE_WRAP_T:;
     case GL_TEXTURE_WRAP_R:;
     case GL_TEXTURE_MAG_FILTER:;
     case GL_TEXTURE_MIN_FILTER:;
     case GL_TEXTURE_BASE_LEVEL:;
     case GL_TEXTURE_MAX_LEVEL:;
       if (SCM_INTP(param)) {
         glTexParameteri(target, pname, Scm_GetInteger(param));
       } else {
         Scm_Error(\"integer parameter required, but got %S\", param);
       }
       break;
     case GL_TEXTURE_PRIORITY:;
     case GL_TEXTURE_MIN_LOD:;
     case GL_TEXTURE_MAX_LOD:;
       if (SCM_REALP(param)) {
         glTexParameterf(target, pname, (GLfloat)Scm_GetDouble(param));
       } else {
         Scm_Error(\"real parameter required, but got %S\", param);
       }
       break;
     case GL_TEXTURE_BORDER_COLOR:
       if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
         glTexParameterfv(target, pname, SCM_F32VECTOR_ELEMENTS(param));
       } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
         glTexParameteriv(target, pname, SCM_S32VECTOR_ELEMENTS(param));
       } else {
         Scm_Error(\"f32 or s32 vector parameter of size 4 required, but got %S\", param);
       }
       break;
     default:
       Scm_Error(\"unknown or unsupported glTexParameter pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-tex-parameter (target pname)
  (assert (small-integer? target))
  (assert (small-integer? pname))
  " ScmObj vec; GLint i; GLfloat f;
  switch (pname) {
     case GL_TEXTURE_WRAP_S:;
     case GL_TEXTURE_WRAP_T:;
     case GL_TEXTURE_WRAP_R:;
     case GL_TEXTURE_MAG_FILTER:;
     case GL_TEXTURE_MIN_FILTER:;
     case GL_TEXTURE_BASE_LEVEL:;
     case GL_TEXTURE_MAX_LEVEL:;
       glGetTexParameteriv(target, pname, &i);
       SCM_RETURN(Scm_MakeInteger(i));
     case GL_TEXTURE_PRIORITY:;
     case GL_TEXTURE_MIN_LOD:;
     case GL_TEXTURE_MAX_LOD:;
       glGetTexParameterfv(target, pname, &f);
       SCM_RETURN(Scm_MakeFlonum((double)f));
     case GL_TEXTURE_BORDER_COLOR:
       vec = Scm_MakeF32Vector(4, 0.0);
       glGetTexParameterfv(target, pname, SCM_F32VECTOR_ELEMENTS(vec));
       SCM_RETURN(vec);
     default:
       Scm_Error(\"unknown or unsupported glTexParameter pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

; gl-get-tex-level-parameter

;; caller must ensure vector has enough length
(define-cproc gl-tex-image-1d (target level internalformat
                               width border format type texels)
  (assert (small-integer? target))
  (assert (small-integer? level))
  (assert (small-integer? internalformat))
  (assert (small-integer? width))
  (assert (small-integer? border))
  (assert (small-integer? format))
  (assert (small-integer? type))
  "int datatype = Scm_GLPixelDataType(type, NULL);
  switch (datatype) {
    case SCM_GL_BYTE:
      if (!SCM_S8VECTORP(texels)) {
        Scm_Error(\"s8vector texels required, but got %S\", texels);
      }
      glTexImage1D(target, level, internalformat, width, border, format, type, SCM_S8VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_UBYTE:
      if (!SCM_U8VECTORP(texels)) {
        Scm_Error(\"u8vector texels required, but got %S\", texels);
      }
      glTexImage1D(target, level, internalformat, width, border, format, type, SCM_U8VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_SHORT:
      if (!SCM_S16VECTORP(texels)) {
        Scm_Error(\"s16vector texels required, but got %S\", texels);
      }
      glTexImage1D(target, level, internalformat, width, border, format, type, SCM_S16VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_USHORT:
      if (!SCM_U16VECTORP(texels)) {
        Scm_Error(\"u16vector texels required, but got %S\", texels);
      }
      glTexImage1D(target, level, internalformat, width, border, format, type, SCM_U16VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_INT:
      if (!SCM_S32VECTORP(texels)) {
        Scm_Error(\"s32vector texels required, but got %S\", texels);
      }
      glTexImage1D(target, level, internalformat, width, border, format, type, SCM_S32VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_UINT:
      if (!SCM_U32VECTORP(texels)) {
        Scm_Error(\"u32vector texels required, but got %S\", texels);
      }
      glTexImage1D(target, level, internalformat, width, border, format, type, SCM_U32VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_FLOAT:
      if (!SCM_F32VECTORP(texels)) {
        Scm_Error(\"f32vector texels required, but got %S\", texels);
      }
      glTexImage1D(target, level, internalformat, width, border, format, type, SCM_F32VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_FLOAT_OR_INT:
      if (SCM_F32VECTORP(texels)) {
        glTexImage1D(target, level, internalformat, width, border, format, type, SCM_F32VECTOR_ELEMENTS(texels));
      } else if (SCM_S32VECTORP(texels)) {
        glTexImage1D(target, level, internalformat, width, border, format, type, SCM_S32VECTOR_ELEMENTS(texels));
      } else {
        Scm_Error(\"s32vector or f64vector texels required, but got %S\", texels);
      }
      break;
  }
  SCM_RETURN(SCM_UNDEFINED);")


;; caller must ensure vector has enough length
(define-cproc gl-tex-image-2d (target level internalformat
                               width height border format type texels)
  (assert (small-integer? target))
  (assert (small-integer? level))
  (assert (small-integer? internalformat))
  (assert (small-integer? width))
  (assert (small-integer? height))
  (assert (small-integer? border))
  (assert (small-integer? format))
  (assert (small-integer? type))
  "int datatype = Scm_GLPixelDataType(type, NULL);
  switch (datatype) {
    case SCM_GL_BYTE:
      if (!SCM_S8VECTORP(texels)) {
        Scm_Error(\"s8vector texels required, but got %S\", texels);
      }
      glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_S8VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_UBYTE:
      if (!SCM_U8VECTORP(texels)) {
        Scm_Error(\"u8vector texels required, but got %S\", texels);
      }
      glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_U8VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_SHORT:
      if (!SCM_S16VECTORP(texels)) {
        Scm_Error(\"s16vector texels required, but got %S\", texels);
      }
      glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_S16VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_USHORT:
      if (!SCM_U16VECTORP(texels)) {
        Scm_Error(\"u16vector texels required, but got %S\", texels);
      }
      glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_U16VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_INT:
      if (!SCM_S32VECTORP(texels)) {
        Scm_Error(\"s32vector texels required, but got %S\", texels);
      }
      glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_S32VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_UINT:
      if (!SCM_U32VECTORP(texels)) {
        Scm_Error(\"u32vector texels required, but got %S\", texels);
      }
      glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_U32VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_FLOAT:
      if (!SCM_F32VECTORP(texels)) {
        Scm_Error(\"f32vector texels required, but got %S\", texels);
      }
      glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_F32VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_FLOAT_OR_INT:
      if (SCM_F32VECTORP(texels)) {
        glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_F32VECTOR_ELEMENTS(texels));
      } else if (SCM_S32VECTORP(texels)) {
        glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_S32VECTOR_ELEMENTS(texels));
      } else {
        Scm_Error(\"s32vector or f64vector texels required, but got %S\", texels);
      }
      break;
  }
  SCM_RETURN(SCM_UNDEFINED);")

; gl-get-tex-image

(define-cproc gl-gen-textures (size)
  (assert (small-integer? size))
  "ScmObj vec;
  if (size <= 0) Scm_Error(\"size must be a positive integer, but got %d\", size);
  vec = Scm_MakeU32Vector(size, 0);
  glGenTextures(size, SCM_U32VECTOR_ELEMENTS(vec));
  SCM_RETURN(vec);")

(define-cproc gl-delete-textures (names)
  "if (!SCM_U32VECTORP(names)) Scm_Error(\"texture names must be an u32vector, but got %S\", names);
  glDeleteTextures(SCM_U32VECTOR_SIZE(names), SCM_U32VECTOR_ELEMENTS(names));")

(define-cproc gl-bind-texture (target name)
  (assert (small-integer? target))
  (assert (exact? name))
  "glBindTexture(target, name);
  SCM_RETURN(SCM_UNDEFINED);")

; gl-prioritize-textures

; gl-are-textures-resident 

(define-cproc gl-is-texture (name)
  (assert (exact? name))
  "SCM_RETURN(SCM_MAKE_INT(glIsTexture(name)));")

; gl-tex-sub-image-1d

; gl-tex-sub-image-2d

; gl-copy-tex-image-1d

; gl-copy-tex-image-2d

; gl-copy-tex-sub-image-1d

; gl-copy-tex-sub-image-2d


;;=============================================================
;; Fog
;;

(define-cproc gl-fog (pname param)
  (assert (small-integer? pname))
  "switch (pname) {
    case GL_FOG_MODE:;
    case GL_FOG_INDEX:;
      if (SCM_INTP(param)) {
        glFogi(pname, SCM_INT_VALUE(param));
      } else {
        Scm_Error(\"integer parameter required, but got %S\", param);
      }
      break;
    case GL_FOG_DENSITY:;
    case GL_FOG_START:;
    case GL_FOG_END:;
      if (SCM_REALP(param)) {
        glFogf(pname, (GLfloat)Scm_GetDouble(param));
      } else {
        Scm_Error(\"real number parameter required, but got %S\", param);
      }
      break;
    case GL_FOG_COLOR:
      if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
        glFogfv(pname, SCM_F32VECTOR_ELEMENTS(param));
      } else {
        Scm_Error(\"f32 vector of size 4 is required, but got %S\", param);
      }
      break;
    default:
      Scm_Error(\"unknown or unsupported glFog pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Selection and feedback
;;

; gl-feedback-buffer
; gl-select-buffer

(define-cproc gl-pass-through (token)
  (assert (real? token))
  "glPassThrough((GLfloat)token);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-init-names ()
  "glInitNames();
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-load-name (name)
  (assert (exact? name))
  "glLoadName(name);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-push-name (name)
  (assert (exact? name))
  "glPushName(name);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-pop-name ()
  "glPopName();
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Extensions
;;



;; Local variables:
;; mode: scheme
;; end:
