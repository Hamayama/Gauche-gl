;;;
;;; gl-lib.stub - glue functions for GL
;;;
;;;  Copyright(C) 2001-2002 by Shiro Kawai (shiro@acm.org)
;;;
;;;  Permission to use, copy, modify, distribute this software and
;;;  accompanying documentation for any purpose is hereby granted,
;;;  provided that existing copyright notices are retained in all
;;;  copies and that this notice is included verbatim in all
;;;  distributions.
;;;  This software is provided as is, without express or implied
;;;  warranty.  In no circumstances the author(s) shall be liable
;;;  for any damages arising out of the use of this software.
;;;
;;;  $Id: gl-lib.stub,v 1.20 2002-08-18 09:12:49 shirok Exp $
;;;

"
#include \"gauche-gl.h\"
"

;; The functions are ordered in the same way as Mesa's header file.

"#define CHECK_ERROR(msg__)                            \\
  do {                                                 \\
    GLenum e = glGetError();                           \\
    if (e != GL_NO_ERROR) {                            \\
      Scm_Error(\"%s: %s\", msg__, gluErrorString(e)); \\
    }                                                  \\
  } while (0)
"
;;=============================================================
;; Miscellaneous
;;

(define-cproc gl-clear-index (c::<float>)
  (return <void> "glClearIndex"))

(define-cproc gl-clear-color (r::<float> g::<float> b::<float> a::<float>)
  (return <void> "glClearColor"))

(define-cproc gl-clear (mask::<uint>)
  (return <void> "glClear"))

(define-cproc gl-index-mask (mask::<uint>)
  (return <void> "glIndexMask"))

(define-cproc gl-color-mask (r::<boolean> g::<boolean> b::<boolean> a::<boolean>)
  (return <void> "glColorMask"))

(define-cproc gl-alpha-func (func::<fixnum> ref::<float>)
  (return <void> "glAlphaFunc"))

(define-cproc gl-blend-func (func::<fixnum> factor::<float>)
  (return <void> "glBlendFunc"))

(define-cproc gl-logic-op (opcode::<fixnum>)
  (return <void> "glLogicOp"))

(define-cproc gl-cull-face (mode::<fixnum>)
  (return <void> "glCullFace"))

(define-cproc gl-front-face (mode::<fixnum>)
  (return <void> "glFrontFace"))

(define-cproc gl-point-size (size::<float>)
  (return <void> "glPointSize"))

(define-cproc gl-line-width (width::<float>)
  (return <void> "glLineWidth"))

(define-cproc gl-line-stipple (factor::<fixnum> pat::<ushort>)
  (return <void> "glLineStipple"))

(define-cproc gl-polygon-mode (face::<fixnum> mode::<fixnum>)
  "glPolygonMode((GLenum)face, (GLenum)mode);
   SCM_RETURN(SCM_UNDEFINED);")

(if "defined(GL_VERSION_1_1)"
    (define-cproc gl-polygon-offset (factor::<float> units::<float>)
      (return <void> "glPolygonOffset"))
    )

(define-cproc gl-polygon-stipple (mask)
  "  if (!SCM_U8VECTORP(mask) || SCM_U8VECTOR_SIZE(mask) != 128) {
    Scm_Error(\"u8vector of size 128 required, but got %S\", mask);
  }
  glPolygonStipple(SCM_U8VECTOR_ELEMENTS(mask));
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-edge-flag (flag::<boolean>)
  "glEdgeFlag(flag);
   SCM_RETURN(SCM_UNDEFINED);")

;; glEdgeFlagv

(define-cproc gl-scissor (x::<int> y::<int> width::<int> height::<int>)
  "glScissor((GLint)x, (GLint)y, (GLsizei)width, (GLsizei)height);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-clip-plane (plane::<fixnum> equation)
  "if (!SCM_F64VECTORP(equation) || SCM_F64VECTOR_SIZE(equation) != 4) {
   Scm_Error(\"f64vector of size 4 required for EQUATION, but got %S\", equation);
  }
  glClipPlane(plane, SCM_F64VECTOR_ELEMENTS(equation));
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-clip-plane (plane::<fixnum>)
  "  ScmF64Vector *v = SCM_F64VECTOR(Scm_MakeF64Vector(4, 0.0));
  glGetClipPlane(plane, SCM_F64VECTOR_ELEMENTS(v));
  SCM_RETURN(SCM_OBJ(v));")

(define-cproc gl-draw-buffer (mode::<fixnum>)
  "glDrawBuffer((GLenum)mode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-read-buffer (mode::<fixnum>)
  "glReadBuffer((GLenum)mode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-enable (cap::<fixnum>)
  "glEnable((GLenum)cap);
   SCM_RETURN(SCM_UNDEFINED);")
  
(define-cproc gl-disable (cap::<fixnum>)
  "glDisable((GLenum)cap);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-is-enabled (cap::<fixnum>)
  "SCM_RETURN(SCM_MAKE_BOOL(glIsEnabled((GLenum)cap)));")

(define-cproc gl-enable-client-state (cap::<fixnum>)
  "glEnableClientState((GLenum)cap);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-disable-client-state (cap::<fixnum>)
  "glDisableClientState((GLenum)cap);
   SCM_RETURN(SCM_UNDEFINED);")

;; Gauche-gl specific
(define-cproc gl-state-vector-size (state::<fixnum>)
  "SCM_RETURN(Scm_MakeInteger(Scm_GLStateInfoSize(state)));")

(define-cproc gl-get-boolean (state::<fixnum>)
  "int vsize = Scm_GLStateInfoSize(state);
  if (vsize <= 0)
    Scm_Error(\"you can't query state %x by glGetBooleanv\", state);
  if (vsize == 1) {
    GLboolean b;
    glGetBooleanv((GLenum)state, &b);
    SCM_RETURN(SCM_MAKE_INT(b));
  } else {
    ScmU8Vector *v = SCM_U8VECTOR(Scm_MakeU8Vector(vsize, 0));
    glGetBooleanv((GLenum)state, SCM_U8VECTOR_ELEMENTS(v));
    SCM_RETURN(SCM_OBJ(v));
  }")

(define-cproc gl-get-boolean! (vec state::<fixnum>)
  "int vsize;
  if (!SCM_U8VECTORP(vec)) Scm_Error(\"u8vector required, but got %S\", vec);
  vsize = Scm_GLStateInfoSize(state);
  if (vsize != SCM_U8VECTOR_SIZE(vec))
    Scm_Error(\"state %x needs a vector of size %d, but got %S\",
               state, vsize, vec);
  glGetBooleanv((GLenum)state, SCM_U8VECTOR_ELEMENTS(vec));
  SCM_RETURN(SCM_OBJ(vec));")

(define-cproc gl-get-integer (state::<fixnum>)
  "int vsize = Scm_GLStateInfoSize(state);
  if (vsize <= 0)
    Scm_Error(\"you can't query state %x by glGetIntegerv\", state);
  if (vsize == 1) {
    GLint i;
    glGetIntegerv((GLenum)state, &i);
    SCM_RETURN(Scm_MakeInteger(i));
  } else {
    ScmS32Vector *v = SCM_S32VECTOR(Scm_MakeS32Vector(vsize, 0));
    glGetIntegerv((GLenum)state, SCM_S32VECTOR_ELEMENTS(v));
    SCM_RETURN(SCM_OBJ(v));
  }")

(define-cproc gl-get-integer! (vec state::<fixnum>)
  "int vsize;
  if (!SCM_S32VECTORP(vec)) Scm_Error(\"s32vector required, but got %S\", vec);
  vsize = Scm_GLStateInfoSize(state);
  if (vsize != SCM_S32VECTOR_SIZE(vec))
    Scm_Error(\"state %x needs a vector of size %d, but got %S\",
               state, vsize, vec);
  glGetIntegerv((GLenum)state, SCM_S32VECTOR_ELEMENTS(vec));
  SCM_RETURN(SCM_OBJ(vec));")

(define-cproc gl-get-float (state::<fixnum>)
  "int vsize = Scm_GLStateInfoSize(state);
  if (vsize <= 0)
    Scm_Error(\"you can't query state %x by glGetFloatv\", state);
  if (vsize == 1) {
    GLfloat v;
    glGetFloatv((GLenum)state, &v);
    SCM_RETURN(Scm_MakeFlonum((double)v));
  } else {
    ScmF32Vector *v = SCM_F32VECTOR(Scm_MakeF32Vector(vsize, 0));
    glGetFloatv((GLenum)state, SCM_F32VECTOR_ELEMENTS(v));
    SCM_RETURN(SCM_OBJ(v));
  }")

(define-cproc gl-get-float! (vec state::<fixnum>)
  "int vsize;
  if (!SCM_F32VECTORP(vec)) Scm_Error(\"s32vector required, but got %S\", vec);
  vsize = Scm_GLStateInfoSize(state);
  if (vsize != SCM_F32VECTOR_SIZE(vec))
    Scm_Error(\"state %x needs a vector of size %d, but got %S\",
               state, vsize, vec);
  glGetFloatv((GLenum)state, SCM_F32VECTOR_ELEMENTS(vec));
  SCM_RETURN(SCM_OBJ(vec));")

(define-cproc gl-get-double (state::<fixnum>)
  "int vsize = Scm_GLStateInfoSize(state);
  if (vsize <= 0)
    Scm_Error(\"you can't query state %x by glGetDoublev\", state);
  if (vsize == 1) {
    GLdouble v;
    glGetDoublev((GLenum)state, &v);
    SCM_RETURN(Scm_MakeFlonum(v));
  } else {
    ScmF64Vector *v = SCM_F64VECTOR(Scm_MakeF64Vector(vsize, 0));
    glGetDoublev((GLenum)state, SCM_F64VECTOR_ELEMENTS(v));
    SCM_RETURN(SCM_OBJ(v));
  }")

(define-cproc gl-get-double! (vec state::<fixnum>)
  "int vsize;
  if (!SCM_F64VECTORP(vec)) Scm_Error(\"s32vector required, but got %S\", vec);
  vsize = Scm_GLStateInfoSize(state);
  if (vsize != SCM_F64VECTOR_SIZE(vec))
    Scm_Error(\"state %x needs a vector of size %d, but got %S\",
               state, vsize, vec);
  glGetDoublev((GLenum)state, SCM_F64VECTOR_ELEMENTS(vec));
  SCM_RETURN(SCM_OBJ(vec));")

;; glGetPointerv

(define-cproc gl-push-attrib (mask)
  "glPushAttrib((GLbitfield)Scm_GetUInteger(mask));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-pop-attrib ()
  "glPopAttrib();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-push-client-attrib (mask)
  "glPushClientAttrib((GLbitfield)Scm_GetUInteger(mask));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-pop-client-attrib ()
  "glPopClientAttrib();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-render-mode (mode::<fixnum>)
  "SCM_RETURN(Scm_MakeInteger(glRenderMode((GLenum)mode)));")

(define-cproc gl-get-error ()
  "SCM_RETURN(Scm_MakeInteger(glGetError()));")

(define-cproc gl-get-string (name::<fixnum>)
  "SCM_RETURN(Scm_MakeString(glGetString(name), -1, -1, 0));")

(define-cproc gl-flush ()
  "glFlush();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-finish ()
  "glFinish();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-hint (target::<int> mode::<int>)
  "glHint(target, mode);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Depth Buffer
;;

(define-cproc gl-clear-depth (depth::<real>)
  "glClearDepth((GLclampd)depth);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-depth-func (func::<fixnum>)
  "glDepthFunc((GLenum)func);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-depth-mask (flag::<boolean>)
  "glDepthMask(flag);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-depth-range (nearv::<real> farv::<real>)
  "glDepthRange((GLclampd)nearv, (GLclampd)farv);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Accumulation Buffer
;;

(define-cproc gl-clear-accum (r::<real> g::<real> b::<real> a::<real>)
  "glClearAccum((GLfloat)r, (GLfloat)g, (GLfloat)b, (GLfloat)a);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-accum (op::<fixnum> value::<real>)
  "glAccum((GLenum)op, (GLfloat)value);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Transformation
;;

(define-cproc gl-matrix-mode (mode::<fixnum>)
  "glMatrixMode(mode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-ortho (left::<real> right::<real>
                        bottom::<real> top::<real>
                        nearv::<real> farv::<real>)
  "glOrtho((GLdouble)left, (GLdouble)right,
           (GLdouble)bottom, (GLdouble)top,
           (GLdouble)nearv, (GLdouble)farv);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-frustum (left::<real> right::<real>
                          bottom::<real> top::<real>
                          nearv::<real> farv::<real>)
  "glFrustum((GLdouble)left, (GLdouble)right,
             (GLdouble)bottom, (GLdouble)top,
             (GLdouble)nearv, (GLdouble)farv);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-viewport (x::<fixnum> y::<fixnum>
                           width::<fixnum> height::<fixnum>)
  "glViewport((GLint)x, (GLint)y, (GLsizei)width, (GLsizei)height);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-push-matrix ()
  "glPushMatrix();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-pop-matrix ()
  "glPopMatrix();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-load-identity ()
  "glLoadIdentity();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-load-matrix (m)
  "if (SCM_F32VECTORP(m) && SCM_F32VECTOR_SIZE(m) == 16) {
     glLoadMatrixf(SCM_F32VECTOR_ELEMENTS(m));
  } else if (SCM_F64VECTORP(m) && SCM_F64VECTOR_SIZE(m) == 16) {
     glLoadMatrixd(SCM_F64VECTOR_ELEMENTS(m));
  } else {
     Scm_Error(\"f32vector or f64vector of length 16 is required, but got %S\",
               m);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-rotate (angle::<real> x::<real> y::<real> z::<real>)
  "glRotated((GLdouble)angle, (GLdouble)x, (GLdouble)y, (GLdouble)z);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-scale (x::<real> y::<real> z::<real>)
  "glScaled((GLdouble)x, (GLdouble)y, (GLdouble)z);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-translate (x::<real> y::<real> z::<real>)
  "glTranslated((GLdouble)x, (GLdouble)y, (GLdouble)z);
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Display lists
;;

(define-cproc gl-is-list (list::<int>)
  "SCM_RETURN(SCM_MAKE_BOOL(glIsList(list)));")

(define-cproc gl-delete-lists (list::<int> range::<int>)
  "glDeleteLists((GLuint)list, (GLsizei)range);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-gen-lists (range::<int>)
  "GLuint r = glGenLists(range);
   SCM_RETURN(Scm_MakeIntegerFromUI(r));")

(define-cproc gl-new-list (list::<int> mode::<int>)
  "glNewList(list, mode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-end-list ()
  "glEndList();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-call-list (list::<int>)
  "glCallList(list);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-call-lists (list::<int> type::<int> lists)
  "switch (type) {
  case GL_BYTE:
    if (!SCM_S8VECTORP(lists)) {
      Scm_Error(\"s8vector required, but got %S\", lists);
    }
    glCallLists(list, type, SCM_S8VECTOR_ELEMENTS(lists));
    break;
  case GL_UNSIGNED_BYTE:
    if (!SCM_U8VECTORP(lists)) {
      Scm_Error(\"u8vector required, but got %S\", lists);
    }
    glCallLists(list, type, SCM_U8VECTOR_ELEMENTS(lists));
    break;
  case GL_SHORT:
    if (!SCM_S16VECTORP(lists)) {
      Scm_Error(\"s16vector required, but got %S\", lists);
    }
    glCallLists(list, type, SCM_S16VECTOR_ELEMENTS(lists));
    break;
  case GL_UNSIGNED_SHORT:
    if (!SCM_U16VECTORP(lists)) {
      Scm_Error(\"u16vector required, but got %S\", lists);
    }
    glCallLists(list, type, SCM_U16VECTOR_ELEMENTS(lists));
    break;
  case GL_INT:
    if (!SCM_S32VECTORP(lists)) {
      Scm_Error(\"s32vector required, but got %S\", lists);
    }
    glCallLists(list, type, SCM_S32VECTOR_ELEMENTS(lists));
    break;
  case GL_UNSIGNED_INT:
    if (!SCM_U32VECTORP(lists)) {
      Scm_Error(\"u32vector required, but got %S\", lists);
    }
    glCallLists(list, type, SCM_U32VECTOR_ELEMENTS(lists));
    break;
  case GL_FLOAT:
    if (!SCM_F32VECTORP(lists)) {
      Scm_Error(\"f32vector required, but got %S\", lists);
    }
    glCallLists(list, type, SCM_F32VECTOR_ELEMENTS(lists));
    break;
  case GL_2_BYTES:
    if (!SCM_U8VECTORP(lists)) {
      Scm_Error(\"u8vector required, but got %S\", lists);
    }
    glCallLists(list, type, SCM_U8VECTOR_ELEMENTS(lists));
    break;
  case GL_3_BYTES:
    if (!SCM_U8VECTORP(lists)) {
      Scm_Error(\"u8vector required, but got %S\", lists);
    }
    glCallLists(list, type, SCM_U8VECTOR_ELEMENTS(lists));
    break;
  case GL_4_BYTES:
    if (!SCM_U8VECTORP(lists)) {
      Scm_Error(\"u8vector required, but got %S\", lists);
    }
    glCallLists(list, type, SCM_U8VECTOR_ELEMENTS(lists));
    break;
  default:
    Scm_Error(\"bad value %d for type argument\", type);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-list-base (base::<int>)
  "glListBase(base);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Drawing functions
;;

(define-cproc gl-begin (mode::<int>)
  "glBegin(mode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-end ()
  "glEnd();
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-vertex (v &rest args)
  "if (SCM_F32VECTORP(v)) {
     switch (SCM_F32VECTOR_SIZE(v)) {
       case 3: glVertex3fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 2: glVertex2fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 4: glVertex4fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_F64VECTORP(v)) {
     switch (SCM_F64VECTOR_SIZE(v)) {
       case 3: glVertex3dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 2: glVertex2dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 4: glVertex4dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S32VECTORP(v)) {
     switch (SCM_S32VECTOR_SIZE(v)) {
       case 3: glVertex3iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       case 2: glVertex2iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       case 4: glVertex4iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S16VECTORP(v)) {
     switch (SCM_S16VECTOR_SIZE(v)) {
       case 3: glVertex3sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 2: glVertex2sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 4: glVertex4sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else {
     double val[4];
     int nvals = Scm_GLGetDoubles(v, args, val, 4, 2);
     switch (nvals) {
       case 3: glVertex3dv(val); break;
       case 2: glVertex2dv(val); break;
       case 4: glVertex4dv(val); break;
     }
  }
  SCM_RETURN(SCM_UNDEFINED);
 badarg:
  Scm_Error(\"bad argument for v: %S, must be one of f32, f64, s32 or s16 vector of length 2, 3, or 4.\", v);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-normal (v &rest args)
  "if (SCM_F32VECTORP(v) && SCM_F32VECTOR_SIZE(v) == 3) {
     glNormal3fv(SCM_F32VECTOR_ELEMENTS(v));
  } else if (SCM_F64VECTORP(v) && SCM_F64VECTOR_SIZE(v) == 3) {
     glNormal3dv(SCM_F64VECTOR_ELEMENTS(v));
  } else if (SCM_S32VECTORP(v) && SCM_S32VECTOR_SIZE(v) == 3) {
     glNormal3iv(SCM_S32VECTOR_ELEMENTS(v));
  } else if (SCM_S16VECTORP(v) && SCM_S16VECTOR_SIZE(v) == 3) {
     glNormal3sv(SCM_S16VECTOR_ELEMENTS(v));
  } else {
     double val[3];
     Scm_GLGetDoubles(v, args, val, 3, 3);
     glNormal3dv(val);
  }
  SCM_RETURN(SCM_UNDEFINED);")

;; glIndex*

(define-cproc gl-color (v &rest args)
  "if (SCM_F32VECTORP(v)) {
     switch (SCM_F32VECTOR_SIZE(v)) {
       case 3: glColor3fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 4: glColor4fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_F64VECTORP(v)) {
     switch (SCM_F64VECTOR_SIZE(v)) {
       case 3: glColor3dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 4: glColor4dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_U8VECTORP(v)) {
     switch (SCM_U8VECTOR_SIZE(v)) {
       case 3: glColor3ubv(SCM_U8VECTOR_ELEMENTS(v)); break;
       case 4: glColor4ubv(SCM_U8VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_U16VECTORP(v)) {
     switch (SCM_U16VECTOR_SIZE(v)) {
       case 3: glColor3usv(SCM_U16VECTOR_ELEMENTS(v)); break;
       case 4: glColor4usv(SCM_U16VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_U32VECTORP(v)) {
     switch (SCM_U32VECTOR_SIZE(v)) {
       case 3: glColor3uiv(SCM_U32VECTOR_ELEMENTS(v)); break;
       case 4: glColor4uiv(SCM_U32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S8VECTORP(v)) {
     switch (SCM_S8VECTOR_SIZE(v)) {
       case 3: glColor3bv(SCM_S8VECTOR_ELEMENTS(v)); break;
       case 4: glColor4bv(SCM_S8VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S16VECTORP(v)) {
     switch (SCM_S16VECTOR_SIZE(v)) {
       case 3: glColor3sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 4: glColor4sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S32VECTORP(v)) {
     switch (SCM_S32VECTOR_SIZE(v)) {
       case 3: glColor3iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       case 4: glColor4iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else {
     double val[4];
     int nvals = Scm_GLGetDoubles(v, args, val, 4, 3);
     switch (nvals) {
       case 3: glColor3dv(val); break;
       case 4: glColor4dv(val); break;
     }
  }
  SCM_RETURN(SCM_UNDEFINED);
 badarg:
  Scm_Error(\"bad argument for color: %S, must be an uniform vector of length 3 or 4\", v);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-coord (v &rest args)
  "if (SCM_F32VECTORP(v)) {
     switch (SCM_F32VECTOR_SIZE(v)) {
       case 2: glTexCoord2fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 1: glTexCoord1fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 3: glTexCoord3fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 4: glTexCoord4fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_F64VECTORP(v)) {
     switch (SCM_F64VECTOR_SIZE(v)) {
       case 2: glTexCoord2dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 1: glTexCoord1dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 3: glTexCoord3dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 4: glTexCoord4dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S32VECTORP(v)) {
     switch (SCM_S32VECTOR_SIZE(v)) {
       case 2: glTexCoord2iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       case 1: glTexCoord2iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       case 3: glTexCoord3iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       case 4: glTexCoord4iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S16VECTORP(v)) {
     switch (SCM_S16VECTOR_SIZE(v)) {
       case 2: glTexCoord2sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 1: glTexCoord1sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 3: glTexCoord3sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 4: glTexCoord4sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else {
     double val[4];
     int nvals = Scm_GLGetDoubles(v, args, val, 4, 1);
     switch (nvals) {
       case 2: glTexCoord2dv(val); break;
       case 1: glTexCoord1dv(val); break;
       case 3: glTexCoord3dv(val); break;
       case 4: glTexCoord4dv(val); break;
     }
  }
  SCM_RETURN(SCM_UNDEFINED);
 badarg:
  Scm_Error(\"bad argument for v: %S, must be one of f32, f64, s32 or s16 vector of length 1, 2, 3, or 4.\", v);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-raster-pos (v &rest args)
  "if (SCM_F32VECTORP(v)) {
     switch (SCM_F32VECTOR_SIZE(v)) {
       case 3: glRasterPos3fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 2: glRasterPos2fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 4: glRasterPos4fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_F64VECTORP(v)) {
     switch (SCM_F64VECTOR_SIZE(v)) {
       case 3: glRasterPos3dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 2: glRasterPos2dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 4: glRasterPos4dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S32VECTORP(v)) {
     switch (SCM_S32VECTOR_SIZE(v)) {
       case 3: glRasterPos3iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       case 2: glRasterPos2iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       case 4: glRasterPos4iv(SCM_S32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S16VECTORP(v)) {
     switch (SCM_S16VECTOR_SIZE(v)) {
       case 3: glRasterPos3sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 2: glRasterPos2sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 4: glRasterPos4sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else {
     double val[4];
     int nvals = Scm_GLGetDoubles(v, args, val, 4, 2);
     switch (nvals) {
       case 3: glRasterPos3dv(val); break;
       case 2: glRasterPos2dv(val); break;
       case 4: glRasterPos4dv(val); break;
     }
  }
  SCM_RETURN(SCM_UNDEFINED);
 badarg:
  Scm_Error(\"bad argument for v: %S, must be one of f32, f64, s32 or s16 vector of length 2, 3, or 4.\", v);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-rect (v1 v2 &rest args)
  "if (SCM_F32VECTORP(v1)) {
     if (SCM_F32VECTOR_SIZE(v1) != 2) goto badarg1;
     if (!SCM_F32VECTORP(v2) || SCM_F32VECTOR_SIZE(v2) != 2) goto badarg2;
     glRectfv(SCM_F32VECTOR_ELEMENTS(v1), SCM_F32VECTOR_ELEMENTS(v2));
  } else if (SCM_F64VECTORP(v1)) {
     if (SCM_F64VECTOR_SIZE(v1) != 2) goto badarg1;
     if (!SCM_F64VECTORP(v2) || SCM_F64VECTOR_SIZE(v2) != 2) goto badarg2;
     glRectdv(SCM_F64VECTOR_ELEMENTS(v1), SCM_F64VECTOR_ELEMENTS(v2));
  } else if (SCM_S32VECTORP(v1)) {
     if (SCM_S32VECTOR_SIZE(v1) != 2) goto badarg1;
     if (!SCM_S32VECTORP(v2) || SCM_S32VECTOR_SIZE(v2) != 2) goto badarg2;
     glRectiv(SCM_S32VECTOR_ELEMENTS(v1), SCM_S32VECTOR_ELEMENTS(v2));
  } else if (SCM_S16VECTORP(v1)) {
     if (SCM_S16VECTOR_SIZE(v1) != 2) goto badarg1;
     if (!SCM_S16VECTORP(v2) || SCM_S16VECTOR_SIZE(v2) != 2) goto badarg2;
     glRectsv(SCM_S16VECTOR_ELEMENTS(v1), SCM_S16VECTOR_ELEMENTS(v2));
  } else {
     double val[4];
     Scm_GLGetDoubles(v1, Scm_Cons(v2, args), val, 4, 4);
     glRectd(val[0], val[1], val[2], val[3]);
  }
  SCM_RETURN(SCM_UNDEFINED);
 badarg1:
  Scm_Error(\"bad argument for v1: %S, must be one of f32, f64, s32 or s16 vector of length 2\", v1);
  SCM_RETURN(SCM_UNDEFINED);
 badarg2:
  Scm_Error(\"bad argument for v2: %S, must be one of f32, f64, s32 or s16 vector of length 2\", v2);
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Vertex Arrays
;;

;; NOTE: it is caller's responsibility to guarantee VEC has enough length.
;; GL doesn't have interface to specify the boundary, so I can't detect
;; invalid length vector.

;; Scheme version doesn't have TYPE - it's derived from vector type.
;; STRIDE argument refers to the # of elements, rather than bytes.

(define-cproc gl-vertex-pointer (size::<fixnum> vec
                                 &optional (stride::<fixnum> 0)
                                           (offset::<fixnum> 0))
  "  if (size < 2 || size > 4) {
    Scm_Error(\"bad argument for size: %d, must be 2, 3 or 4\", size);
  }
  if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_F32VECTORP(vec)) {
    glVertexPointer(size, GL_FLOAT, stride*sizeof(GLfloat),
                    (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glVertexPointer(size, GL_DOUBLE, stride*sizeof(GLdouble),
                    (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S32VECTORP(vec)) {
    glVertexPointer(size, GL_INT, stride*sizeof(GLint),
                    (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glVertexPointer(size, GL_SHORT, stride*sizeof(GLshort),
                    (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, s32 or s16vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-normal-pointer (vec
                                 &optional (stride::<fixnum> 0)
                                           (offset::<fixnum> 0))
  "if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_F32VECTORP(vec)) {
    glNormalPointer(GL_FLOAT, stride*sizeof(GLfloat),
                    (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glNormalPointer(GL_DOUBLE, stride*sizeof(GLdouble),
                    (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S32VECTORP(vec)) {
    glNormalPointer(GL_INT, stride*sizeof(GLint),
                    (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glNormalPointer(GL_SHORT, stride*sizeof(GLshort),
                    (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S8VECTORP(vec)) {
    glNormalPointer(GL_BYTE, stride*sizeof(GLbyte),
                    (void*)(SCM_S8VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, s8, s16 or s32vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-color-pointer (size::<fixnum> vec
                                &optional (stride::<fixnum> 0)
                                          (offset::<fixnum> 0))
  "  if (size < 3 || size > 4) {
    Scm_Error(\"bad argument for size: %d, must be 2, 3 or 4\", size);
  }
  if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_F32VECTORP(vec)) {
    glColorPointer(size, GL_FLOAT, stride*sizeof(GLfloat),
                  (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glColorPointer(size, GL_DOUBLE, stride*sizeof(GLdouble),
                   (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_U32VECTORP(vec)) {
    glColorPointer(size, GL_UNSIGNED_INT, stride*sizeof(GLuint),
                   (void*)(SCM_U32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_U16VECTORP(vec)) {
    glColorPointer(size, GL_UNSIGNED_SHORT, stride*sizeof(GLushort),
                   (void*)(SCM_U16VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_U8VECTORP(vec)) {
    glColorPointer(size, GL_UNSIGNED_BYTE, stride*sizeof(GLubyte),
                   (void*)(SCM_U8VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S32VECTORP(vec)) {
    glColorPointer(size, GL_INT, stride*sizeof(GLint),
                   (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glColorPointer(size, GL_SHORT, stride*sizeof(GLshort),
                   (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S8VECTORP(vec)) {
    glColorPointer(size, GL_BYTE, stride*sizeof(GLbyte),
                   (void*)(SCM_S8VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, s8, u8, s16, u16, s32 or u32vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-index-pointer (vec
                                &optional (stride::<fixnum> 0)
                                          (offset::<fixnum> 0))
  "if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_S32VECTORP(vec)) {
    glNormalPointer(GL_INT, stride*sizeof(GLint),
                    (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glNormalPointer(GL_SHORT, stride*sizeof(GLshort),
                    (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_U8VECTORP(vec)) {
    glNormalPointer(GL_UNSIGNED_BYTE, stride*sizeof(GLubyte),
                    (void*)(SCM_U8VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F32VECTORP(vec)) {
    glNormalPointer(GL_FLOAT, stride*sizeof(GLfloat),
                    (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glNormalPointer(GL_DOUBLE, stride*sizeof(GLdouble),
                    (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, u8, s16 or s32 vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-coord-pointer (size::<fixnum> vec
                                    &optional (stride::<fixnum> 0)
                                              (offset::<fixnum> 0))
  "  if (size < 1 || size > 4) {
    Scm_Error(\"bad argument for size: %d, must be 1, 2, 3 or 4\", size);
  }
  if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_F32VECTORP(vec)) {
    glColorPointer(size, GL_FLOAT, stride*sizeof(GLfloat),
                  (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glColorPointer(size, GL_DOUBLE, stride*sizeof(GLdouble),
                   (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S32VECTORP(vec)) {
    glColorPointer(size, GL_INT, stride*sizeof(GLint),
                   (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glColorPointer(size, GL_SHORT, stride*sizeof(GLshort),
                   (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, s16 or s32vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

;; glEdgeFlagPointer - GLboolean vector maps u8vector
(define-cproc gl-edge-flag-pointer (vec
                                    &optional (stride::<fixnum> 0)
                                              (offset::<fixnum> 0))
  "if (!SCM_U8VECTORP(vec)) {
     Scm_Error(\"u8vector required for vec, but got %S\", vec);
   }
   glEdgeFlagPointer(stride, SCM_U8VECTOR_ELEMENTS(vec) + offset);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-array-element (ith::<fixnum>)
  "glArrayElement(ith);
   SCM_RETURN(SCM_UNDEFINED);")

;; count and type is derived from indices vector
(define-cproc gl-draw-elements (mode::<fixnum> indices)
  "if (SCM_U8VECTORP(indices)) {
    glDrawElements(mode, SCM_U8VECTOR_SIZE(indices), GL_UNSIGNED_BYTE,
                   SCM_U8VECTOR_ELEMENTS(indices));
  } else if (SCM_U16VECTORP(indices)) {
    glDrawElements(mode, SCM_U16VECTOR_SIZE(indices), GL_UNSIGNED_SHORT,
                   SCM_U16VECTOR_ELEMENTS(indices));
  } else if (SCM_U32VECTORP(indices)) {
    glDrawElements(mode, SCM_U32VECTOR_SIZE(indices), GL_UNSIGNED_INT,
                   SCM_U32VECTOR_ELEMENTS(indices));
  } else {
    Scm_Error(\"bad argument for indices: %S, must be u8, u16 or u32vector\", indices);
  }
  SCM_RETURN(SCM_UNDEFINED);")


(define-cproc gl-draw-arrays (mode::<fixnum> first::<fixnum> count::<fixnum>)
  "glDrawArrays(mode, first, count);
   SCM_RETURN(SCM_UNDEFINED);")

;; Note: we don't allow non-uniform vector for the interleaved arrays, so
;; the color component must be float.
(define-cproc gl-interleaved-arrays (format::<fixnum> vec
                                     &optional (stride::<fixnum> 0)
                                               (offset::<fixnum> 0))
  "  switch (format) {
     case GL_C4UB_V2F:; case GL_C4UB_V3F:; case GL_T2F_C4UB_V3F:
       Scm_Error(\"interleaved arrays with integer color component is not supported.\");
  }
  if (!SCM_F32VECTORP(vec)) {
    Scm_Error(\"bad argument for vec: %S, must be f32vector.\", vec);
  }
  glInterleavedArrays(format, stride * sizeof(GLfloat),
                      SCM_F32VECTOR_ELEMENTS(vec));
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Lighting
;;

(define-cproc gl-shade-model (mode::<fixnum>)
  "glShadeModel(mode);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-light (light::<fixnum> pname::<fixnum> param)
  "switch (pname) {
   case GL_AMBIENT:; case GL_DIFFUSE:; case GL_SPECULAR:; case GL_POSITION:;
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
       glLightfv(light, pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
       glLightiv(light, pname, SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32 vector of length 4\", param);
     }
     break;
   case GL_SPOT_DIRECTION:
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 3) {
       glLightfv(light, pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 3) {
       glLightiv(light, pname, SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32 vector of length 3\", param);
     }
     break;
   default:
     if (SCM_EXACTP(param)) {
       glLighti(light, pname, (GLint)Scm_GetInteger(param));
     } else if (SCM_REALP(param)) {
       glLightf(light, pname, (GLfloat)Scm_GetDouble(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be a real number.\", param);
     }
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-light (light::<fixnum> pname::<fixnum>)
  "switch (pname) {
   case GL_AMBIENT:; case GL_DIFFUSE:; case GL_SPECULAR:; case GL_POSITION:
     {
       ScmF32Vector *v = SCM_F32VECTOR(Scm_MakeF32Vector(4, 0.0));
       glGetLightfv(light, pname, SCM_F32VECTOR_ELEMENTS(v));
       SCM_RETURN(SCM_OBJ(v));
     }
   case GL_SPOT_DIRECTION:
     {
       ScmF32Vector *v = SCM_F32VECTOR(Scm_MakeF32Vector(3, 0.0));
       glGetLightfv(light, pname, SCM_F32VECTOR_ELEMENTS(v));
       SCM_RETURN(SCM_OBJ(v));
     }
   default:
     {
       float v;
       glGetLightfv(light, pname, &v);
       SCM_RETURN(Scm_MakeFlonum((double)v));
     }
   }")

(define-cproc gl-light-model (pname::<fixnum> param)
  "switch (pname) {
    case GL_LIGHT_MODEL_AMBIENT:
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
       glLightModelfv(pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
       glLightModeliv(pname, SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32 vector of length 4\", param);
     }
     break;
    default:
     glLightModeli(pname, !SCM_FALSEP(param));
     break;
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-material (face::<fixnum> pname::<fixnum> param)
  "switch (pname) {
   case GL_AMBIENT:; case GL_DIFFUSE:; case GL_SPECULAR:; case GL_EMISSION:;
   case GL_AMBIENT_AND_DIFFUSE:;
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
       glMaterialfv(face, pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
       glMaterialiv(face, pname, SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32 vector of length 4\", param);
     }
     break;
   case GL_COLOR_INDEXES:
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 3) {
       glMaterialfv(face, pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 3) {
       glMaterialiv(face, pname, SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32vector of length 3\", param);
     }
     break;
   default:
     if (SCM_REALP(param)) {
       glMaterialf(face, pname, (GLfloat)Scm_GetDouble(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be a real number.\", param);
     }
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-material (face::<fixnum> pname::<fixnum>)
  "switch (pname) {
   case GL_AMBIENT:; case GL_DIFFUSE:; case GL_SPECULAR:; case GL_EMISSION:;
     {
       ScmF32Vector *v = SCM_F32VECTOR(Scm_MakeF32Vector(4, 0.0));
       glGetMaterialfv(face, pname, SCM_F32VECTOR_ELEMENTS(v));
       SCM_RETURN(SCM_OBJ(v));
     }
   case GL_COLOR_INDEXES:
     {
       ScmS32Vector *v = SCM_S32VECTOR(Scm_MakeS32Vector(3, 0.0));
       glGetMaterialiv(face, pname, SCM_S32VECTOR_ELEMENTS(v));
       SCM_RETURN(SCM_OBJ(v));
     }
   case GL_SHININESS:
     {
       float v;
       glGetMaterialfv(face, pname, &v);
       SCM_RETURN(Scm_MakeFlonum((double)v));
     }
   default:
     Scm_Error(\"bad pname: %d\", pname);
     SCM_RETURN(SCM_UNDEFINED);
   }")

(define-cproc gl-color-material (face::<fixnum> mode::<fixnum>)
  "glColorMaterial(face, mode);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Raster functions
;;

(define-cproc gl-pixel-zoom (xfactor::<real> yfactor::<real>)
  "glPixelZoom(xfactor, yfactor);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-pixel-store (pname::<fixnum> param)
  "if (SCM_EXACTP(param)) {
     glPixelStorei(pname, Scm_GetInteger(param));
   } else if (SCM_FLONUMP(param)) {
     glPixelStoref(pname, (float)SCM_FLONUM_VALUE(param));
   } else {
     Scm_Error(\"real number required for param, but got %S\", param);
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-pixel-map (map::<fixnum> values)
  "if (SCM_U32VECTORP(values)) {
    glPixelMapuiv(map, SCM_U32VECTOR_SIZE(values),
                  SCM_U32VECTOR_ELEMENTS(values));
  } else if (SCM_U16VECTORP(values)) {
    glPixelMapusv(map, SCM_U16VECTOR_SIZE(values),
                  SCM_U16VECTOR_ELEMENTS(values));
  } else if (SCM_F32VECTORP(values)) {
    glPixelMapfv(map, SCM_F32VECTOR_SIZE(values),
                 SCM_F32VECTOR_ELEMENTS(values));
  } else {
     Scm_Error(\"map value vector must be u16, u32 or f32 vector, but got %S\",
               values);
  }
   SCM_RETURN(SCM_UNDEFINED);")

;; values must have enough size
(define-cproc gl-get-pixel-map! (map::<fixnum> values)
  "if (SCM_U32VECTORP(values)) {
    glGetPixelMapuiv(map, SCM_U32VECTOR_ELEMENTS(values));
  } else if (SCM_U16VECTORP(values)) {
    glGetPixelMapusv(map, SCM_U16VECTOR_ELEMENTS(values));
  } else if (SCM_F32VECTORP(values)) {
    glGetPixelMapfv(map, SCM_F32VECTOR_ELEMENTS(values));
  } else {
     Scm_Error(\"map value vector must be u16, u32 or f32 vector, but got %S\",
               values);
  }
  SCM_RETURN(values);")

;; allocate the vector in it.  type can be a class 
;; <u32vector> (default), <u16vector> or <f32vector>
(define-cproc gl-get-pixel-map (map::<fixnum> &optional type)
  " int size; ScmObj vec = SCM_UNDEFINED;
  glGetIntegerv(map, &size);
  CHECK_ERROR(\"couldn't get pixel map size\");
  SCM_ASSERT(size >= 0);
  if (SCM_UNBOUNDP(type) || type == SCM_OBJ(SCM_CLASS_U32VECTOR)) {
    vec = Scm_MakeU32Vector(size, 0);
    glGetPixelMapuiv(map, SCM_U32VECTOR_ELEMENTS(vec));
  } else if (type == SCM_OBJ(SCM_CLASS_U16VECTOR)) {
    vec = Scm_MakeU16Vector(size, 0);
    glGetPixelMapusv(map, SCM_U16VECTOR_ELEMENTS(vec));
  } else if (type == SCM_OBJ(SCM_CLASS_F32VECTOR)) {
    vec = Scm_MakeF32Vector(size, 0);
    glGetPixelMapfv(map, SCM_F32VECTOR_ELEMENTS(vec));
  } else {
     Scm_Error(\"pixel map vector class must be either <u32vector>, <u16vector> or <f32vector>, but got %S\", type);
  }
  SCM_RETURN(vec);")

(define-cproc gl-bitmap (width::<int> height::<int>
                         xbo::<float> ybo::<float>
                         xbi::<float> ybi::<float> bitmap)
  "if (!SCM_U8VECTORP(bitmap)) {
    Scm_Error(\"bitmap must be an u8vector, but got %S\", bitmap);
  }
  if (SCM_U8VECTOR_SIZE(bitmap) != ((width+7)/8)*height) {
    Scm_Error(\"size (width=%d, height=%d) doesn't match bitmap vector %S\",
              width, height, bitmap);
  }
  glBitmap(width, height, xbo, ybo, xbi, ybi, SCM_U8VECTOR_ELEMENTS(bitmap));
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-read-pixels (x::<fixnum> y::<fixnum>
                              width::<fixnum> height::<fixnum>
                              format::<fixnum> type::<fixnum>)
  "  int elttype, size, packed; ScmObj vec = SCM_UNDEFINED;
  size = Scm_GLPixelDataSize(width, height, format, type, &elttype, &packed);
  switch (elttype) {
    case SCM_GL_BYTE:
      vec = Scm_MakeS8Vector(size, 0);
      glReadPixels(x, y, width, height, format, type,
                   SCM_S8VECTOR_ELEMENTS(vec));
      break;
    case SCM_GL_UBYTE:
      vec = Scm_MakeU8Vector(size, 0);
      glReadPixels(x, y, width, height, format, type,
                   SCM_U8VECTOR_ELEMENTS(vec));
      break;
    case SCM_GL_SHORT:
      vec = Scm_MakeS16Vector(size, 0);
      glReadPixels(x, y, width, height, format, type,
                   SCM_S16VECTOR_ELEMENTS(vec));
      break;
    case SCM_GL_USHORT:
      vec = Scm_MakeU16Vector(size, 0);
      glReadPixels(x, y, width, height, format, type,
                   SCM_U16VECTOR_ELEMENTS(vec));
      break;
    case SCM_GL_INT:
      vec = Scm_MakeS32Vector(size, 0);
      glReadPixels(x, y, width, height, format, type,
                   SCM_S32VECTOR_ELEMENTS(vec));
      break;
    case SCM_GL_UINT:
      vec = Scm_MakeU32Vector(size, 0);
      glReadPixels(x, y, width, height, format, type,
                   SCM_U32VECTOR_ELEMENTS(vec));
      break;
    case SCM_GL_FLOAT:
      vec = Scm_MakeF32Vector(size, 0);
      glReadPixels(x, y, width, height, format, type,
                   SCM_F32VECTOR_ELEMENTS(vec));
      break;
  }
  SCM_RETURN(vec);")

; gl-read-pixels!

(define-cproc gl-draw-pixels (width::<fixnum> height::<fixnum>
                              format::<fixnum> type::<fixnum> pixels)
  "  int elttype, size, packed; ScmObj vec = SCM_UNDEFINED;
  size = Scm_GLPixelDataSize(width, height, format, type, &elttype, &packed);
  switch (elttype) {
    case SCM_GL_BYTE:
      if (!SCM_S8VECTORP(pixels)) {
        Scm_Error(\"s8vector required, but got %S\", pixels);
      }
      glDrawPixels(width, height, format, type,
                   SCM_S8VECTOR_ELEMENTS(pixels));
      break;
    case SCM_GL_UBYTE:
      if (!SCM_U8VECTORP(pixels)) {
        Scm_Error(\"u8vector required, but got %S\", pixels);
      }
      glDrawPixels(width, height, format, type,
                   SCM_U8VECTOR_ELEMENTS(pixels));
      break;

    case SCM_GL_SHORT:
      if (!SCM_S16VECTORP(pixels)) {
        Scm_Error(\"s16vector required, but got %S\", pixels);
      }
      glDrawPixels(width, height, format, type,
                   SCM_S16VECTOR_ELEMENTS(pixels));
      break;
    case SCM_GL_USHORT:
      if (!SCM_U16VECTORP(pixels)) {
        Scm_Error(\"u16vector required, but got %S\", pixels);
      }
      glDrawPixels(width, height, format, type,
                   SCM_U16VECTOR_ELEMENTS(pixels));
      break;

    case SCM_GL_INT:
      if (!SCM_S32VECTORP(pixels)) {
        Scm_Error(\"s32vector required, but got %S\", pixels);
      }
      glDrawPixels(width, height, format, type,
                   SCM_S32VECTOR_ELEMENTS(pixels));
      break;
    case SCM_GL_UINT:
      if (!SCM_U32VECTORP(pixels)) {
        Scm_Error(\"u32vector required, but got %S\", pixels);
      }
      glDrawPixels(width, height, format, type,
                   SCM_U32VECTOR_ELEMENTS(pixels));
      break;

    case SCM_GL_FLOAT:
      if (!SCM_F32VECTORP(pixels)) {
        Scm_Error(\"f32vector required, but got %S\", pixels);
      }
      glDrawPixels(width, height, format, type,
                   SCM_F32VECTOR_ELEMENTS(pixels));
      break;
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-copy-pixels (x::<fixnum> y::<fixnum>
                              width::<fixnum> height::<fixnum> type::<fixnum>)
  "glCopyPixels(x, y, width, height, type);
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Stenciling
;;

(define-cproc gl-stencil-func (func::<fixnum> ref::<int> mask::<uint>)
  "glStencilFunc((GLenum)func, (GLint)ref, (GLuint)mask);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-stencil-mask (mask::<uint>)
  "glStencilMask((GLuint)mask);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-stencil-op (func::<fixnum> zfail::<fixnum> zpass::<fixnum>)
  "glStencilFunc((GLenum)func, (GLenum)zfail, (GLenum)zpass); 
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-clear-stencil (s::<int>)
  "glClearStencil((GLint)s);
   SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Texture mapping
;;

(define-cproc gl-tex-gen (coord::<fixnum> pname::<fixnum> param)
  "switch (pname) {
    case GL_TEXTURE_GEN_MODE:
      if (!SCM_INTP(param)) {
        Scm_Error(\"integer parameter required for GL_TEXTURE_GEN_MODE, but got %S\", param);
      }
      glTexGeni(coord, pname, SCM_INT_VALUE(param));
      break;
    case GL_OBJECT_PLANE:;
    case GL_EYE_PLANE:;
      if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
        glTexGenfv(coord, pname, SCM_F32VECTOR_ELEMENTS(param));
      } else if (SCM_F64VECTORP(param) && SCM_F64VECTOR_SIZE(param) == 4) {
        glTexGendv(coord, pname, SCM_F64VECTOR_ELEMENTS(param));
      } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
        glTexGeniv(coord, pname, SCM_S32VECTOR_ELEMENTS(param));
      } else {
        Scm_Error(\"s32, f32 or f64 vector of size 4 is required for parameter, but got %S\", param);
      }
      break;
     default:
      Scm_Error(\"unknown or unsupported glTexGen pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-env (target::<fixnum> pname::<fixnum> param)
  "switch (pname) {
    case GL_TEXTURE_ENV_MODE:
      if (SCM_INTP(param)) {
        glTexEnvi(target, pname, SCM_INT_VALUE(param));
      } else {
        Scm_Error(\"integer parameter required for GL_TEXTURE_ENV_MODE, but got %S\", param);
      }
      break;
    case GL_TEXTURE_ENV_COLOR:
      if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
        glTexEnvfv(target, pname, SCM_F32VECTOR_ELEMENTS(param));
      } else {
        Scm_Error(\"f32 vector of size 4 is required for GL_TEXTURE_ENV_COLOR parameter, but got %S\", param);
      }
      break;
    default:
      Scm_Error(\"unknown or unsupported glTexEnv pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-parameter (target::<fixnum> pname::<fixnum> param)
  "switch (pname) {
     case GL_TEXTURE_WRAP_S:;
     case GL_TEXTURE_WRAP_T:;
     case GL_TEXTURE_WRAP_R:;
     case GL_TEXTURE_MAG_FILTER:;
     case GL_TEXTURE_MIN_FILTER:;
     case GL_TEXTURE_BASE_LEVEL:;
     case GL_TEXTURE_MAX_LEVEL:;
       if (SCM_INTP(param)) {
         glTexParameteri(target, pname, Scm_GetInteger(param));
       } else {
         Scm_Error(\"integer parameter required, but got %S\", param);
       }
       break;
     case GL_TEXTURE_PRIORITY:;
     case GL_TEXTURE_MIN_LOD:;
     case GL_TEXTURE_MAX_LOD:;
       if (SCM_REALP(param)) {
         glTexParameterf(target, pname, (GLfloat)Scm_GetDouble(param));
       } else {
         Scm_Error(\"real parameter required, but got %S\", param);
       }
       break;
     case GL_TEXTURE_BORDER_COLOR:
       if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
         glTexParameterfv(target, pname, SCM_F32VECTOR_ELEMENTS(param));
       } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
         glTexParameteriv(target, pname, SCM_S32VECTOR_ELEMENTS(param));
       } else {
         Scm_Error(\"f32 or s32 vector parameter of size 4 required, but got %S\", param);
       }
       break;
     default:
       Scm_Error(\"unknown or unsupported glTexParameter pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-tex-parameter (target::<fixnum> pname::<fixnum>)
  " ScmObj vec; GLint i; GLfloat f;
  switch (pname) {
     case GL_TEXTURE_WRAP_S:;
     case GL_TEXTURE_WRAP_T:;
     case GL_TEXTURE_WRAP_R:;
     case GL_TEXTURE_MAG_FILTER:;
     case GL_TEXTURE_MIN_FILTER:;
     case GL_TEXTURE_BASE_LEVEL:;
     case GL_TEXTURE_MAX_LEVEL:;
       glGetTexParameteriv(target, pname, &i);
       SCM_RETURN(Scm_MakeInteger(i));
     case GL_TEXTURE_PRIORITY:;
     case GL_TEXTURE_MIN_LOD:;
     case GL_TEXTURE_MAX_LOD:;
       glGetTexParameterfv(target, pname, &f);
       SCM_RETURN(Scm_MakeFlonum((double)f));
     case GL_TEXTURE_BORDER_COLOR:
       vec = Scm_MakeF32Vector(4, 0.0);
       glGetTexParameterfv(target, pname, SCM_F32VECTOR_ELEMENTS(vec));
       SCM_RETURN(vec);
     default:
       Scm_Error(\"unknown or unsupported glTexParameter pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

; gl-get-tex-level-parameter

;; caller must ensure vector has enough length
(define-cproc gl-tex-image-1d (target::<fixnum> level::<fixnum>
                               internalformat::<fixnum>
                               width::<fixnum> border::<fixnum>
                               format::<fixnum> type::<fixnum> texels)
  "int datatype = Scm_GLPixelDataType(type, NULL);
  switch (datatype) {
    case SCM_GL_BYTE:
      if (!SCM_S8VECTORP(texels)) {
        Scm_Error(\"s8vector texels required, but got %S\", texels);
      }
      glTexImage1D(target, level, internalformat, width, border, format, type, SCM_S8VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_UBYTE:
      if (!SCM_U8VECTORP(texels)) {
        Scm_Error(\"u8vector texels required, but got %S\", texels);
      }
      glTexImage1D(target, level, internalformat, width, border, format, type, SCM_U8VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_SHORT:
      if (!SCM_S16VECTORP(texels)) {
        Scm_Error(\"s16vector texels required, but got %S\", texels);
      }
      glTexImage1D(target, level, internalformat, width, border, format, type, SCM_S16VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_USHORT:
      if (!SCM_U16VECTORP(texels)) {
        Scm_Error(\"u16vector texels required, but got %S\", texels);
      }
      glTexImage1D(target, level, internalformat, width, border, format, type, SCM_U16VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_INT:
      if (!SCM_S32VECTORP(texels)) {
        Scm_Error(\"s32vector texels required, but got %S\", texels);
      }
      glTexImage1D(target, level, internalformat, width, border, format, type, SCM_S32VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_UINT:
      if (!SCM_U32VECTORP(texels)) {
        Scm_Error(\"u32vector texels required, but got %S\", texels);
      }
      glTexImage1D(target, level, internalformat, width, border, format, type, SCM_U32VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_FLOAT:
      if (!SCM_F32VECTORP(texels)) {
        Scm_Error(\"f32vector texels required, but got %S\", texels);
      }
      glTexImage1D(target, level, internalformat, width, border, format, type, SCM_F32VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_FLOAT_OR_INT:
      if (SCM_F32VECTORP(texels)) {
        glTexImage1D(target, level, internalformat, width, border, format, type, SCM_F32VECTOR_ELEMENTS(texels));
      } else if (SCM_S32VECTORP(texels)) {
        glTexImage1D(target, level, internalformat, width, border, format, type, SCM_S32VECTOR_ELEMENTS(texels));
      } else {
        Scm_Error(\"s32vector or f64vector texels required, but got %S\", texels);
      }
      break;
  }
  SCM_RETURN(SCM_UNDEFINED);")


;; caller must ensure vector has enough length
(define-cproc gl-tex-image-2d (target::<fixnum> level::<fixnum>
                               internalformat::<fixnum>
                               width::<fixnum> height::<fixnum>
                               border::<fixnum> format::<fixnum>
                               type::<fixnum> texels)
  "int datatype = Scm_GLPixelDataType(type, NULL);
  switch (datatype) {
    case SCM_GL_BYTE:
      if (!SCM_S8VECTORP(texels)) {
        Scm_Error(\"s8vector texels required, but got %S\", texels);
      }
      glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_S8VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_UBYTE:
      if (!SCM_U8VECTORP(texels)) {
        Scm_Error(\"u8vector texels required, but got %S\", texels);
      }
      glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_U8VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_SHORT:
      if (!SCM_S16VECTORP(texels)) {
        Scm_Error(\"s16vector texels required, but got %S\", texels);
      }
      glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_S16VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_USHORT:
      if (!SCM_U16VECTORP(texels)) {
        Scm_Error(\"u16vector texels required, but got %S\", texels);
      }
      glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_U16VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_INT:
      if (!SCM_S32VECTORP(texels)) {
        Scm_Error(\"s32vector texels required, but got %S\", texels);
      }
      glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_S32VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_UINT:
      if (!SCM_U32VECTORP(texels)) {
        Scm_Error(\"u32vector texels required, but got %S\", texels);
      }
      glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_U32VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_FLOAT:
      if (!SCM_F32VECTORP(texels)) {
        Scm_Error(\"f32vector texels required, but got %S\", texels);
      }
      glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_F32VECTOR_ELEMENTS(texels));
      break;
    case SCM_GL_FLOAT_OR_INT:
      if (SCM_F32VECTORP(texels)) {
        glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_F32VECTOR_ELEMENTS(texels));
      } else if (SCM_S32VECTORP(texels)) {
        glTexImage2D(target, level, internalformat, width, height, border, format, type, SCM_S32VECTOR_ELEMENTS(texels));
      } else {
        Scm_Error(\"s32vector or f64vector texels required, but got %S\", texels);
      }
      break;
  }
  SCM_RETURN(SCM_UNDEFINED);")

; gl-get-tex-image

(define-cproc gl-gen-textures (size::<fixnum>)
  "ScmObj vec;
  if (size <= 0) Scm_Error(\"size must be a positive integer, but got %d\", size);
  vec = Scm_MakeU32Vector(size, 0);
  glGenTextures(size, SCM_U32VECTOR_ELEMENTS(vec));
  SCM_RETURN(vec);")

(define-cproc gl-delete-textures (names)
  "if (!SCM_U32VECTORP(names)) Scm_Error(\"texture names must be an u32vector, but got %S\", names);
  glDeleteTextures(SCM_U32VECTOR_SIZE(names), SCM_U32VECTOR_ELEMENTS(names));")

(define-cproc gl-bind-texture (target::<fixnum> name::<int>)
  "glBindTexture(target, name);
  SCM_RETURN(SCM_UNDEFINED);")

; gl-prioritize-textures

; gl-are-textures-resident 

(define-cproc gl-is-texture (name::<int>)
  "SCM_RETURN(SCM_MAKE_INT(glIsTexture(name)));")

; gl-tex-sub-image-1d

; gl-tex-sub-image-2d

; gl-copy-tex-image-1d

; gl-copy-tex-image-2d

; gl-copy-tex-sub-image-1d

; gl-copy-tex-sub-image-2d


;;=============================================================
;; Fog
;;

(define-cproc gl-fog (pname::<fixnum> param)
  "switch (pname) {
    case GL_FOG_MODE:;
    case GL_FOG_INDEX:;
      if (SCM_INTP(param)) {
        glFogi(pname, SCM_INT_VALUE(param));
      } else {
        Scm_Error(\"integer parameter required, but got %S\", param);
      }
      break;
    case GL_FOG_DENSITY:;
    case GL_FOG_START:;
    case GL_FOG_END:;
      if (SCM_REALP(param)) {
        glFogf(pname, (GLfloat)Scm_GetDouble(param));
      } else {
        Scm_Error(\"real number parameter required, but got %S\", param);
      }
      break;
    case GL_FOG_COLOR:
      if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
        glFogfv(pname, SCM_F32VECTOR_ELEMENTS(param));
      } else {
        Scm_Error(\"f32 vector of size 4 is required, but got %S\", param);
      }
      break;
    default:
      Scm_Error(\"unknown or unsupported glFog pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Selection and feedback
;;

; gl-feedback-buffer
; gl-select-buffer

(define-cproc gl-pass-through (token::<float>)
  (return <void> "glPassThrough"))

(define-cproc gl-init-names ()
  (return <void> "glInitNames"))

(define-cproc gl-load-name (name::<int>)
  (return <void> "glLoadName"))

(define-cproc gl-push-name (name::<int>)
  (return <void> "glPushName"))

(define-cproc gl-pop-name ()
  (return <void> "glPopName"))

;;=============================================================
;; Extensions
;;



;; Local variables:
;; mode: scheme
;; end:
