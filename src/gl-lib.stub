;;;
;;; gl-lib.stub - glue functions for GL
;;;
;;;  Copyright (c) 2001-2008  Shiro Kawai  <shiro@acm.org>
;;;
;;;  Permission to use, copy, modify, distribute this software and
;;;  accompanying documentation for any purpose is hereby granted,
;;;  provided that existing copyright notices are retained in all
;;;  copies and that this notice is included verbatim in all
;;;  distributions.
;;;  This software is provided as is, without express or implied
;;;  warranty.  In no circumstances the author(s) shall be liable
;;;  for any damages arising out of the use of this software.
;;;
;;;  $Id: gl-lib.stub,v 1.47 2008-06-04 11:50:43 shirok Exp $
;;;

(include "glcase.scm")

"
#include \"gauche-gl.h\"
#include \"gl-syms.h\"
"

;; The functions are ordered in the same way as Mesa's header file.

"#define CHECK_ERROR(msg__)                            \\
  do {                                                 \\
    GLenum e = glGetError();                           \\
    if (e != GL_NO_ERROR) {                            \\
      Scm_Error(\"%s: %s\", msg__, gluErrorString(e)); \\
    }                                                  \\
  } while (0)
"

(define-cise-stmt assert-vector-type&size
  [(_ type size var)
   (let* ([TYPE (string-upcase (x->string type))]
          [pred (string->symbol #`"SCM_,|TYPE|P")]
          [getsize (string->symbol #`"SCM_,|TYPE|_SIZE")]
          [msg #`",type of size ,size required,, but got %S"])
     `(when (or (not (,pred ,var)) (!= (,getsize ,var) ,size))
        (Scm_Error ,msg ,var)))])

;; NB: this should be taken care of by genstub.
(define-type <uvector> "ScmUVector*" "uniform vector"
  "SCM_UVECTORP" "SCM_UVECTOR")
(define-type <u32vector> "ScmU32Vector*" "u32vector"
  "SCM_U32VECTORP" "SCM_U32VECTOR")
(define-type <f32vector> "ScmF32Vector*" "f32vector"
  "SCM_F32VECTORP" "SCM_F32VECTOR")
(define-type <gl-boolean-vector> "ScmGLBooleanVector*" "GL boolean vector"
  "SCM_GL_BOOLEAN_VECTOR_P" "SCM_GL_BOOLEAN_VECTOR")

;;=============================================================
;; <gl-boolean-vector> stuff
;;

(define-cproc list->gl-boolean-vector (lis) Scm_ListToGLBooleanVector)
(define-cproc gl-boolean-vector (&rest lis) Scm_ListToGLBooleanVector)
(define-cproc gl-boolean-vector? (obj) ::<boolean> SCM_GL_BOOLEAN_VECTOR_P)

(define-cproc make-gl-boolean-vector (size::<uint>
                                      &optional (init::<boolean> #f))
  Scm_MakeGLBooleanVector)

(define-cproc gl-boolean-vector-copy (bv::<gl-boolean-vector>)
  (result (Scm_MakeGLBooleanVectorFromArray (-> bv size) (-> bv elements))))

(define-cproc gl-boolean-vector-ref (bv::<gl-boolean-vector>
                                     k::<int>
                                     &optional fallback)
  (cond [(or (< k 0) (>= k (-> bv size)))
         (when (SCM_UNBOUNDP fallback)
           (Scm_Error "argument out of bound: %d" k))
         (result fallback)]
        [else
         (result (SCM_MAKE_BOOL (aref (-> bv elements) k)))]))

(define-cproc gl-boolean-vector-set! (bv::<gl-boolean-vector>
                                      k::<int>
                                      value)
  ::<void>
  (if (or (< k 0) (>= k (-> bv size)))
    (Scm_Error "argument out of bound: %d" k)
    (= (aref (-> bv elements) k) (?: (SCM_FALSEP value) GL_FALSE GL_TRUE))))

(define-cproc gl-boolean-vector-length (bv::<gl-boolean-vector>) ::<int>
  (result (-> bv size)))

(define-cproc gl-boolean-vector-fill! (bv::<gl-boolean-vector> fill)
  (let* ([val::GLboolean (?: (SCM_FALSEP fill) GL_FALSE GL_TRUE)])
    (dotimes [i (-> bv size)] (= (aref (-> bv elements) i) val)))
  (result (SCM_OBJ bv)))

;;=============================================================
;; Miscellaneous
;;

(define-cproc gl-clear-index (c::<float>) ::<void> glClearIndex)
(define-cproc gl-clear-color (r::<float> g::<float> b::<float> a::<float>)
  ::<void> glClearColor)
(define-cproc gl-clear (mask::<uint>) ::<void> glClear)
(define-cproc gl-index-mask (mask::<uint>) ::<void> glIndexMask)
(define-cproc gl-color-mask (r::<boolean> g::<boolean> b::<boolean> a::<boolean>)
  ::<void> glColorMask)

(define-cproc gl-alpha-func (func::<fixnum> ref::<float>)
  ::<void> glAlphaFunc)
(define-cproc gl-blend-func (sfactor::<fixnum> dfactor::<fixnum>)
  ::<void> glBlendFunc)
(define-cproc gl-logic-op (opcode::<fixnum>) ::<void> glLogicOp)
(define-cproc gl-cull-face (mode::<fixnum>) ::<void> glCullFace)
(define-cproc gl-front-face (mode::<fixnum>) ::<void> glFrontFace)
(define-cproc gl-point-size (size::<float>) ::<void> glPointSize)
(define-cproc gl-line-width (width::<float>) ::<void> glLineWidth)
(define-cproc gl-line-stipple (factor::<fixnum> pat::<ushort>)
  ::<void> glLineStipple)
(define-cproc gl-polygon-mode (face::<fixnum> mode::<fixnum>)
  ::<void> glPolygonMode)
(define-cproc gl-polygon-offset (factor::<float> units::<float>)
  ::<void> glPolygonOffset)

(define-cproc gl-polygon-stipple (mask) ::<void>
  (assert-vector-type&size u8vector 128 mask)
  (glPolygonStipple (SCM_U8VECTOR_ELEMENTS mask)))

(define-cproc gl-edge-flag (flag) ::<void>
  (if (SCM_GL_BOOLEAN_VECTOR_P flag)
    (glEdgeFlagv (-> (SCM_GL_BOOLEAN_VECTOR flag) elements))
    (glEdgeFlag (not (SCM_FALSEP flag)))))

(define-cproc gl-scissor (x::<int> y::<int> width::<int> height::<int>)
  ::<void> glScissor)

(define-cproc gl-clip-plane (plane::<fixnum> equation) ::<void>
  (assert-vector-type&size f64vector 4 equation)
  (glClipPlane plane (SCM_F64VECTOR_ELEMENTS equation)))

(define-cproc gl-get-clip-plane (plane::<fixnum>)
  (let* ([v::ScmF64Vector* (SCM_F64VECTOR (Scm_MakeF64Vector 4 0.0))])
    (glGetClipPlane plane (SCM_F64VECTOR_ELEMENTS v))
    (result (SCM_OBJ v))))

(define-cproc gl-draw-buffer (mode::<fixnum>) ::<void> glDrawBuffer)
(define-cproc gl-read-buffer (mode::<fixnum>) ::<void> glReadBuffer)

(define-cproc gl-enable (cap::<fixnum>) ::<void> glEnable)
(define-cproc gl-disable (cap::<fixnum>) ::<void> glDisable)
(define-cproc gl-is-enabled (cap::<fixnum>) ::<boolean> glIsEnabled)

(define-cproc gl-enable-client-state (cap::<fixnum>)
  ::<void> glEnableClientState)
(define-cproc gl-disable-client-state (cap::<fixnum>)
  ::<void> glDisableClientState)

;; Gauche-gl specific
(define-cproc gl-state-vector-size (state::<fixnum>)
  ::<int> Scm_GLStateInfoSize)

(define-cise-stmt with-state-info-size
  [(_ var state name . body)
   `(let* ([,var :: int (Scm_GLStateInfoSize ,state)])
      (when (<= ,var 0)
        (Scm_Error ,#`"you can't query state %x by ,name" ,state))
      ,@body)])

(define-cproc gl-get-boolean (state::<fixnum>)
  (with-state-info-size
   vsize state gl-get-boolean
   (if (== vsize 1)
     (let* ([b::GLboolean])
       (glGetBooleanv (cast GLenum state) (& b))
       (result (SCM_MAKE_BOOL b)))
     (let* ([v (Scm_MakeGLBooleanVector vsize GL_FALSE)])
       (glGetBooleanv (cast GLenum state)
                      (-> (SCM_GL_BOOLEAN_VECTOR v) elements))
       (result v)))))

(define-cproc gl-get-boolean! (vec::<gl-boolean-vector> state::<fixnum>)
  (with-state-info-size
   vsize state gl-get-boolean!
   (when (!= vsize (SCM_GL_BOOLEAN_VECTOR_SIZE vec))
      (Scm_Error "state %x needs a vector of size %d, but got %S"
                 state vsize (SCM_OBJ vec)))
   (glGetBooleanv (cast GLenum state) (-> vec elements))
   (result (SCM_OBJ vec))))

(define-cproc gl-get-integer (state::<fixnum>)
  (with-state-info-size
   vsize state gl-get-integer
   (if (== vsize 1)
     (let* ([i::GLint])
       (glGetIntegerv (cast GLenum state) (& i))
       (result (Scm_MakeInteger i)))
     (let* ([v::ScmS32Vector* (SCM_S32VECTOR (Scm_MakeS32Vector vsize 0))])
       (glGetIntegerv (cast GLenum state)
                      (cast GLint* (SCM_S32VECTOR_ELEMENTS v)))
       (result (SCM_OBJ v))))))

(define-cproc gl-get-integer! (vec::<s32vector> state::<fixnum>)
  (with-state-info-size
   vsize state gl-get-integer!
   (when (!= vsize (SCM_S32VECTOR_SIZE vec))
     (Scm_Error "state %x needs a vector of size %d, but got %S"
                state vsize vec))
   (glGetIntegerv (cast GLenum state)
                  (cast GLint* (SCM_S32VECTOR_ELEMENTS vec)))
   (result (SCM_OBJ vec))))

(define-cproc gl-get-float (state::<fixnum>)
  (with-state-info-size
   vsize state gl-get-float
   (if (== vsize 1)
     (let* ([v::GLfloat])
       (glGetFloatv (cast GLenum state) (& v))
       (result (Scm_MakeFlonum (cast double v))))
     (let* ([v::ScmF32Vector* (SCM_F32VECTOR (Scm_MakeF32Vector vsize 0))])
       (glGetFloatv (cast GLenum state) (SCM_F32VECTOR_ELEMENTS v))
       (result (SCM_OBJ v))))))

(define-cproc gl-get-float! (vec::<f32vector> state::<fixnum>)
  (with-state-info-size
   vsize state gl-get-float!
   (when (!= vsize (SCM_F32VECTOR_SIZE vec))
     (Scm_Error "state %x needs a vector of size %d, but got %S"
                state vsize vec))
   (glGetFloatv (cast GLenum state) (SCM_F32VECTOR_ELEMENTS vec))
   (result (SCM_OBJ vec))))

(define-cproc gl-get-double (state::<fixnum>)
  (with-state-info-size
   vsize state gl-get-double
   (if (== vsize 1)
     (let* ([v::GLdouble])
       (glGetDoublev (cast GLenum state) (& v))
       (result (Scm_MakeFlonum v)))
     (let* ([v::ScmF64Vector* (SCM_F64VECTOR (Scm_MakeF64Vector vsize 0))])
       (glGetDoublev (cast GLenum state) (SCM_F64VECTOR_ELEMENTS v))
       (result (SCM_OBJ v))))))

(define-cproc gl-get-double! (vec::<f64vector> state::<fixnum>)
  (with-state-info-size
   vsize state gl-get-double!
   (when (!= vsize (SCM_F64VECTOR_SIZE vec))
     (Scm_Error "state %x needs a vector of size %d, but got %S"
                state vsize vec))
   (glGetDoublev (cast GLenum state) (SCM_F64VECTOR_ELEMENTS vec))
   (result (SCM_OBJ vec))))

;; glGetPointerv

(define-cproc gl-push-attrib (mask::<ulong>)::<void> glPushAttrib)
(define-cproc gl-pop-attrib () ::<void> glPopAttrib)
(define-cproc gl-push-client-attrib (mask::<ulong>)::<void> glPushClientAttrib)
(define-cproc gl-pop-client-attrib () ::<void> glPopClientAttrib)

(define-cproc gl-render-mode (mode::<fixnum>) ::<int> glRenderMode)

(define-cproc gl-get-error () ::<int> glGetError)
(define-cproc gl-get-string (name::<fixnum>)
  (let* ([s::(const GLubyte*) (glGetString name)])
    (if s
      (result (Scm_MakeString (cast (const char*) s) -1 -1 SCM_MAKSTR_COPYING))
      (result SCM_FALSE))))

(define-cproc gl-flush () ::<void> glFlush)
(define-cproc gl-finish () ::<void> glFinish)
(define-cproc gl-hint (target::<int> mode::<int>) ::<void> glHint)

;;=============================================================
;; Depth Buffer
;;

(define-cproc gl-clear-depth (depth::<real>)::<void> glClearDepth)
(define-cproc gl-depth-func (func::<fixnum>)::<void> glDepthFunc)
(define-cproc gl-depth-mask (flag::<boolean>)::<void> glDepthMask)
(define-cproc gl-depth-range (nearv::<real> farv::<real>)::<void> glDepthRange)

;;=============================================================
;; Accumulation Buffer
;;

(define-cproc gl-clear-accum (r::<real> g::<real> b::<real> a::<real>)
  ::<void> glClearAccum)
(define-cproc gl-accum (op::<fixnum> value::<real>) ::<void> glAccum)

;;=============================================================
;; Transformation
;;

(define-cproc gl-matrix-mode (mode::<fixnum>) ::<void> glMatrixMode)

(define-cproc gl-ortho (left::<real> right::<real>
                        bottom::<real> top::<real>
                        nearv::<real> farv::<real>)
  ::<void> glOrtho)

(define-cproc gl-frustum (left::<real> right::<real>
                          bottom::<real> top::<real>
                          nearv::<real> farv::<real>)
  ::<void> glFrustum)

(define-cproc gl-viewport (x::<fixnum> y::<fixnum>
                           width::<fixnum> height::<fixnum>)
  ::<void> glViewport)

(define-cproc gl-push-matrix () ::<void> glPushMatrix)
(define-cproc gl-pop-matrix () ::<void> glPopMatrix)
(define-cproc gl-load-identity () ::<void> glLoadIdentity)

(define-cproc gl-load-matrix (m) ::<void>
  (gl-case (m) "glLoadMatrix~t"
           ((m4f) (f32 16) (f64 16))
           "matrix4f, or f32vector or f64vector of length 16 is required, but got %S"))

(define-cproc gl-mult-matrix (m) ::<void>
  (gl-case (m) "glMultMatrix~t"
           ((m4f) (f32 16) (f64 16))
           "matrix4f, or f32vector or f64vector of length 16 is required, but got %S"))

(define-cproc gl-rotate (angle::<real> x::<real> y::<real> z::<real>)
  ::<void> glRotated)
(define-cproc gl-scale (x::<real> y::<real> z::<real>)
  ::<void> glScaled)
(define-cproc gl-translate (x::<real> y::<real> z::<real>)
  ::<void> glTranslated)

;;=============================================================
;; Display lists
;;

(define-cproc gl-is-list (list::<int>)::<boolean> glIsList)
(define-cproc gl-delete-lists (list::<int> range::<int>) ::<void> glDeleteLists)
(define-cproc gl-gen-lists (range::<int>) ::<ulong> glGenLists)
(define-cproc gl-new-list (list::<int> mode::<int>) ::<void> glNewList)
(define-cproc gl-end-list () ::<void> glEndList)
(define-cproc gl-call-list (list::<int>) ::<void> glCallList)

;; this may be called as
;;  (gl-call-lists array)
;;  (gl-call-lists size array)
;;  (gl-call-lists size type array)
(define-cproc gl-call-lists (arg0 &optional arg1 arg2)
  "GLsizei size = 0;  
   int type = -1;
   ScmObj array, bad;
   if (SCM_UNBOUNDP(arg2)) {
     if (SCM_UNBOUNDP(arg1)) {
       /* single arg case */
       array = arg0;
     } else {
       /* double arg case */
       if (!SCM_INTP(arg0)) {
         bad = arg0; goto badarg;
       }
       size = SCM_INT_VALUE(arg0);
       array = arg1;
     }
   } else {
     /* triple arg case */
     if (!SCM_INTP(arg0)) {
       bad = arg0; goto badarg;
     }
     size = SCM_INT_VALUE(arg0);
     if (!SCM_INTP(arg1)) {
       bad = arg1; goto badarg;
     }
     type = SCM_INT_VALUE(arg1);
     array = arg2;
   }

   if (SCM_U8VECTORP(array)) {
     switch (type) {
       case -1:
         if (size == 0) size = SCM_U8VECTOR_SIZE(array);
         else if (SCM_U8VECTOR_SIZE(array) < size) goto nee;
         glCallLists(size, GL_UNSIGNED_BYTE, SCM_U8VECTOR_ELEMENTS(array));
         break;
       case GL_2_BYTES:
         if (size == 0) size = SCM_U8VECTOR_SIZE(array)/2;
         else if (SCM_U8VECTOR_SIZE(array)/2 < size) goto nee;
         glCallLists(size, GL_2_BYTES, SCM_U8VECTOR_ELEMENTS(array));
         break;
       case GL_3_BYTES:
         if (size == 0) size = SCM_U8VECTOR_SIZE(array)/3;
         else if (SCM_U8VECTOR_SIZE(array)/3 < size) goto nee;
         glCallLists(size, GL_3_BYTES, SCM_U8VECTOR_ELEMENTS(array));
         break;
       case GL_4_BYTES:
         if (size == 0) size = SCM_U8VECTOR_SIZE(array)/4;
         else if (SCM_U8VECTOR_SIZE(array)/4 < size) goto nee;
         glCallLists(size, GL_4_BYTES, SCM_U8VECTOR_ELEMENTS(array));
         break;
       default:
         goto badtype;
     }
   } else if (SCM_STRINGP(array)) {
     if (size == 0) size = SCM_STRING_SIZE(array);
     else if (SCM_STRING_SIZE(array) < size) goto nee;
     glCallLists(size, GL_UNSIGNED_BYTE, SCM_STRING_START(array));
   } else if (SCM_S8VECTORP(array)) {
     if (size == 0) size = SCM_S8VECTOR_SIZE(array);
     else if (SCM_S8VECTOR_SIZE(array) < size) goto nee;
     glCallLists(size, GL_BYTE, SCM_S8VECTOR_ELEMENTS(array));
   } else if (SCM_S16VECTORP(array)) {
     if (size == 0) size = SCM_S16VECTOR_SIZE(array);
     else if (SCM_S16VECTOR_SIZE(array) < size) goto nee;
     glCallLists(size, GL_SHORT, SCM_S16VECTOR_ELEMENTS(array));
   } else if (SCM_U16VECTORP(array)) {
     if (size == 0) size = SCM_U16VECTOR_SIZE(array);
     else if (SCM_U16VECTOR_SIZE(array) < size) goto nee;
     glCallLists(size, GL_UNSIGNED_SHORT, SCM_U16VECTOR_ELEMENTS(array));
   } else if (SCM_S32VECTORP(array)) {
     if (size == 0) size = SCM_S32VECTOR_SIZE(array);
     else if (SCM_S32VECTOR_SIZE(array) < size) goto nee;
     glCallLists(size, GL_INT, SCM_S32VECTOR_ELEMENTS(array));
   } else if (SCM_U32VECTORP(array)) {
     if (size == 0) size = SCM_U32VECTOR_SIZE(array);
     else if (SCM_U32VECTOR_SIZE(array) < size) goto nee;
     glCallLists(size, GL_UNSIGNED_INT, SCM_U32VECTOR_ELEMENTS(array));
   } else if (SCM_F32VECTORP(array)) {
     if (size == 0) size = SCM_F32VECTOR_SIZE(array);
     else if (SCM_F32VECTOR_SIZE(array) < size) goto nee;
     glCallLists(size, GL_INT, SCM_U32VECTOR_ELEMENTS(array));
   }
   SCM_RETURN(SCM_UNDEFINED);
  badarg:
   Scm_Error(\"bad argument to gl-call-lists: %S\", bad);
  nee:
   Scm_Error(\"not enough elements passed to gl-call-lists: %S\", array);
  badtype:
   Scm_Error(\"given type %d doesn't match the passed array (u8vector)\", type);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-list-base (base::<int>) ::<void> glListBase)

;;=============================================================
;; Drawing functions
;;

(define-cproc gl-begin (mode::<int>) ::<void> glBegin)
(define-cproc gl-end () ::<void> glEnd)

(define-cproc gl-vertex (v &rest args)
  (gl-case (v args) "glVertex~n~v"
           ((p4f 3) (v4f 3) (f32 3 2 4) (f64 3 2 4) (s32 3 2 4) (s16 3 2 4)
            (args 3 2 4))
           "bad argument for v: %S, must be one of point4f, vector4f, \
            or f32, f64, s32 or s16 vector of length 2, 3, or 4."))

(define-cproc gl-normal (v &rest args)
  (gl-case (v args) "glNormal3~v"
           ((v4f 3) (f32 3) (f64 3) (s32 3) (s16 3) (args 3))
           "bad argument for v: %S, must be one of vector4f, \
            or f32, f64, s32 or s16 vector of length 3."))

(define-cproc gl-index (v) ::<void>
  (cond
   [(SCM_REALP v)      (glIndexd (Scm_GetDouble v))]
   [(and (SCM_UVECTORP v) (>= (SCM_UVECTOR_SIZE v) 1))
    (gl-case (v) "glIndex~v"
             ((s16) (s32) (f32) (f64))
             "s16, s32, f32, f64 or u8vector is required, but got %S")]
   [else
    (SCM_TYPE_ERROR v "real number or s16, s32, f32, f64 or u8vector of at least one element")]))

(define-cproc gl-color (v &rest args) ::<void>
  (gl-case (v args) "glColor~n~v"
           ((f32 3 4) (f64 3 4) (u8 3 4) (u16 3 4) (u32 3 4)
            (s8 3 4) (s16 3 4) (s32 3 4) (args 3 4))
           "bad argument for color: %S, must be an uniform vector of \
            length 3 or 4"))
            

(define-cproc gl-tex-coord (v &rest args) ::<void>
  (gl-case (v args) "glTexCoord~n~v"
           ((f32 2 1 3 4) (f64 2 1 3 4) (s32 2 1 3 4) (s16 2 1 3 4)
            (args 2 1 3 4))
           "bad argument for v: %S, must be one of f32, f64, s32 or s16 vector of length 1, 2, 3, or 4."))

(define-cproc gl-raster-pos (v &rest args)
  (gl-case (v args) "glRasterPos~n~v"
           ((f32 3 2 4) (f64 3 2 4) (s32 3 2 4) (s16 3 2 4) (args 3 2 4))
           "bad argument for v: %S, must be one of f32, f64, s32 or s16 vector of length 2, 3, or 4."))

(define-cproc gl-rect (v1 v2 &rest args)
  "if (SCM_POINT4FP(v1)) {
     if (!SCM_POINT4FP(v2)) goto badarg2;
     glRectfv(SCM_POINT4F_D(v1), SCM_POINT4F_D(v2));
  } else if (SCM_F32VECTORP(v1)) {
     if (SCM_F32VECTOR_SIZE(v1) != 2) goto badarg1;
     if (!SCM_F32VECTORP(v2) || SCM_F32VECTOR_SIZE(v2) != 2) goto badarg2;
     glRectfv(SCM_F32VECTOR_ELEMENTS(v1), SCM_F32VECTOR_ELEMENTS(v2));
  } else if (SCM_F64VECTORP(v1)) {
     if (SCM_F64VECTOR_SIZE(v1) != 2) goto badarg1;
     if (!SCM_F64VECTORP(v2) || SCM_F64VECTOR_SIZE(v2) != 2) goto badarg2;
     glRectdv(SCM_F64VECTOR_ELEMENTS(v1), SCM_F64VECTOR_ELEMENTS(v2));
  } else if (SCM_S32VECTORP(v1)) {
     if (SCM_S32VECTOR_SIZE(v1) != 2) goto badarg1;
     if (!SCM_S32VECTORP(v2) || SCM_S32VECTOR_SIZE(v2) != 2) goto badarg2;
     glRectiv((GLint*)SCM_S32VECTOR_ELEMENTS(v1), (GLint*)SCM_S32VECTOR_ELEMENTS(v2));
  } else if (SCM_S16VECTORP(v1)) {
     if (SCM_S16VECTOR_SIZE(v1) != 2) goto badarg1;
     if (!SCM_S16VECTORP(v2) || SCM_S16VECTOR_SIZE(v2) != 2) goto badarg2;
     glRectsv(SCM_S16VECTOR_ELEMENTS(v1), SCM_S16VECTOR_ELEMENTS(v2));
  } else {
     double val[4];
     Scm_GLGetDoubles(v1, Scm_Cons(v2, args), val, 4, 4);
     glRectd(val[0], val[1], val[2], val[3]);
  }
  SCM_RETURN(SCM_UNDEFINED);
 badarg1:
  Scm_Error(\"bad argument for v1: %S, must be one of f32, f64, s32 or s16 vector of length 2\", v1);
  SCM_RETURN(SCM_UNDEFINED);
 badarg2:
  Scm_Error(\"bad argument for v2: %S, must be one of f32, f64, s32 or s16 vector of length 2\", v2);
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Vertex Arrays
;;

;; NOTE: it is caller's responsibility to guarantee VEC has enough length.
;; GL doesn't have interface to specify the boundary, so I can't detect
;; invalid length vector.

;; Scheme version doesn't have TYPE - it's derived from vector type.
;; STRIDE argument refers to the # of elements, rather than bytes.

(define-cproc gl-vertex-pointer (size::<fixnum> vec
                                 &optional (stride::<fixnum> 0)
                                           (offset::<fixnum> 0))
  "if (size < 2 || size > 4) {
    Scm_Error(\"bad argument for size: %d, must be 2, 3 or 4\", size);
  }
  if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_POINT4F_ARRAY_P(vec)) {
    glVertexPointer(size, GL_FLOAT, stride*sizeof(GLfloat),
                    (void*)(SCM_POINT4F_ARRAY_D(vec)+offset));
  } else if (SCM_F32VECTORP(vec)) {
    glVertexPointer(size, GL_FLOAT, stride*sizeof(GLfloat),
                    (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glVertexPointer(size, GL_DOUBLE, stride*sizeof(GLdouble),
                    (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S32VECTORP(vec)) {
    glVertexPointer(size, GL_INT, stride*sizeof(GLint),
                    (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glVertexPointer(size, GL_SHORT, stride*sizeof(GLshort),
                    (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, s32 or s16vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-normal-pointer (vec
                                 &optional (stride::<fixnum> 0)
                                           (offset::<fixnum> 0))
  "if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_VECTOR4F_ARRAY_P(vec)) {
    glNormalPointer(GL_FLOAT, stride*sizeof(GLfloat),
                    (void*)(SCM_VECTOR4F_ARRAY_D(vec)+offset));
  } else if (SCM_F32VECTORP(vec)) {
    glNormalPointer(GL_FLOAT, stride*sizeof(GLfloat),
                    (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glNormalPointer(GL_DOUBLE, stride*sizeof(GLdouble),
                    (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S32VECTORP(vec)) {
    glNormalPointer(GL_INT, stride*sizeof(GLint),
                    (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glNormalPointer(GL_SHORT, stride*sizeof(GLshort),
                    (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S8VECTORP(vec)) {
    glNormalPointer(GL_BYTE, stride*sizeof(GLbyte),
                    (void*)(SCM_S8VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, s8, s16 or s32vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-color-pointer (size::<fixnum> vec
                                &optional (stride::<fixnum> 0)
                                          (offset::<fixnum> 0))
  "  if (size < 3 || size > 4) {
    Scm_Error(\"bad argument for size: %d, must be 2, 3 or 4\", size);
  }
  if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_F32VECTORP(vec)) {
    glColorPointer(size, GL_FLOAT, stride*sizeof(GLfloat),
                  (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glColorPointer(size, GL_DOUBLE, stride*sizeof(GLdouble),
                   (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_U32VECTORP(vec)) {
    glColorPointer(size, GL_UNSIGNED_INT, stride*sizeof(GLuint),
                   (void*)(SCM_U32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_U16VECTORP(vec)) {
    glColorPointer(size, GL_UNSIGNED_SHORT, stride*sizeof(GLushort),
                   (void*)(SCM_U16VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_U8VECTORP(vec)) {
    glColorPointer(size, GL_UNSIGNED_BYTE, stride*sizeof(GLubyte),
                   (void*)(SCM_U8VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S32VECTORP(vec)) {
    glColorPointer(size, GL_INT, stride*sizeof(GLint),
                   (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glColorPointer(size, GL_SHORT, stride*sizeof(GLshort),
                   (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S8VECTORP(vec)) {
    glColorPointer(size, GL_BYTE, stride*sizeof(GLbyte),
                   (void*)(SCM_S8VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, s8, u8, s16, u16, s32 or u32vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-index-pointer (vec
                                &optional (stride::<fixnum> 0)
                                          (offset::<fixnum> 0))
  "if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_S32VECTORP(vec)) {
    glIndexPointer(GL_INT, stride*sizeof(GLint),
                   (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glIndexPointer(GL_SHORT, stride*sizeof(GLshort),
                   (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_U8VECTORP(vec)) {
    glIndexPointer(GL_UNSIGNED_BYTE, stride*sizeof(GLubyte),
                   (void*)(SCM_U8VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F32VECTORP(vec)) {
    glIndexPointer(GL_FLOAT, stride*sizeof(GLfloat),
                   (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glIndexPointer(GL_DOUBLE, stride*sizeof(GLdouble),
                   (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, u8, s16 or s32 vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-coord-pointer (size::<fixnum> vec
                                    &optional (stride::<fixnum> 0)
                                              (offset::<fixnum> 0))
  "  if (size < 1 || size > 4) {
    Scm_Error(\"bad argument for size: %d, must be 1, 2, 3 or 4\", size);
  }
  if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_F32VECTORP(vec)) {
    glTexCoordPointer(size, GL_FLOAT, stride*sizeof(GLfloat),
                     (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glTexCoordPointer(size, GL_DOUBLE, stride*sizeof(GLdouble),
                      (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S32VECTORP(vec)) {
    glTexCoordPointer(size, GL_INT, stride*sizeof(GLint),
                      (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glTexCoordPointer(size, GL_SHORT, stride*sizeof(GLshort),
                      (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, s16 or s32vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-edge-flag-pointer (vec
                                    &optional (stride::<fixnum> 0)
                                              (offset::<fixnum> 0))
  "if (SCM_GL_BOOLEAN_VECTOR_P(vec)) {
     glEdgeFlagPointer(stride, SCM_GL_BOOLEAN_VECTOR_ELEMENTS(vec) + offset);
   } else {
     Scm_Error(\"gl-boolean-vector required for vec, but got %S\", vec);
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-array-element (ith::<fixnum>)
  "glArrayElement(ith);
   SCM_RETURN(SCM_UNDEFINED);")

;; count and type is derived from indices vector
(define-cproc gl-draw-elements (mode::<fixnum> indices)
  "if (SCM_U8VECTORP(indices)) {
    glDrawElements(mode, SCM_U8VECTOR_SIZE(indices), GL_UNSIGNED_BYTE,
                   SCM_U8VECTOR_ELEMENTS(indices));
  } else if (SCM_U16VECTORP(indices)) {
    glDrawElements(mode, SCM_U16VECTOR_SIZE(indices), GL_UNSIGNED_SHORT,
                   SCM_U16VECTOR_ELEMENTS(indices));
  } else if (SCM_U32VECTORP(indices)) {
    glDrawElements(mode, SCM_U32VECTOR_SIZE(indices), GL_UNSIGNED_INT,
                   SCM_U32VECTOR_ELEMENTS(indices));
  } else {
    Scm_Error(\"bad argument for indices: %S, must be u8, u16 or u32vector\", indices);
  }
  SCM_RETURN(SCM_UNDEFINED);")


(define-cproc gl-draw-arrays (mode::<fixnum> first::<fixnum> count::<fixnum>)
  ::<void> glDrawArrays)

;; Note: we don't allow non-uniform vector for the interleaved arrays, so
;; the color component must be float.
(define-cproc gl-interleaved-arrays (format::<fixnum> vec
                                     &optional (stride::<fixnum> 0)
                                               (offset::<fixnum> 0))
  "  switch (format) {
     case GL_C4UB_V2F:; case GL_C4UB_V3F:; case GL_T2F_C4UB_V3F:
       Scm_Error(\"interleaved arrays with integer color component is not supported.\");
  }
  if (!SCM_F32VECTORP(vec)) {
    Scm_Error(\"bad argument for vec: %S, must be f32vector.\", vec);
  }
  glInterleavedArrays(format, stride * sizeof(GLfloat),
                      SCM_F32VECTOR_ELEMENTS(vec));
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Lighting
;;

(define-cproc gl-shade-model (mode::<fixnum>) ::<void> glShadeModel)

(define-cproc gl-light (light::<fixnum> pname::<fixnum> param)
  "switch (pname) {
   case GL_AMBIENT:; case GL_DIFFUSE:; case GL_SPECULAR:; case GL_POSITION:;
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
       glLightfv(light, pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
       glLightiv(light, pname, (GLint*)SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32 vector of length 4\", param);
     }
     break;
   case GL_SPOT_DIRECTION:
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 3) {
       glLightfv(light, pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 3) {
       glLightiv(light, pname, (GLint*)SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32 vector of length 3\", param);
     }
     break;
   default:
     if (SCM_REALP(param)) {
       glLightf(light, pname, (GLfloat)Scm_GetDouble(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be a real number.\", param);
     }
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-light (light::<fixnum> pname::<fixnum>)
  "switch (pname) {
   case GL_AMBIENT:; case GL_DIFFUSE:; case GL_SPECULAR:; case GL_POSITION:
     {
       ScmF32Vector *v = SCM_F32VECTOR(Scm_MakeF32Vector(4, 0.0));
       glGetLightfv(light, pname, SCM_F32VECTOR_ELEMENTS(v));
       SCM_RETURN(SCM_OBJ(v));
     }
   case GL_SPOT_DIRECTION:
     {
       ScmF32Vector *v = SCM_F32VECTOR(Scm_MakeF32Vector(3, 0.0));
       glGetLightfv(light, pname, SCM_F32VECTOR_ELEMENTS(v));
       SCM_RETURN(SCM_OBJ(v));
     }
   default:
     {
       float v;
       glGetLightfv(light, pname, &v);
       SCM_RETURN(Scm_MakeFlonum((double)v));
     }
   }")

(define-cproc gl-light-model (pname::<fixnum> param)
  "switch (pname) {
    case GL_LIGHT_MODEL_AMBIENT:
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
       glLightModelfv(pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
       glLightModeliv(pname, (GLint*)SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter for GL_LIGHT_MODEL_AMBIENT: %S, must be f32 or s32 vector of length 4\", param);
     }
     break;
    case GL_LIGHT_MODEL_COLOR_CONTROL:
     if (SCM_INTP(param)) {
       glLightModeli(pname, SCM_INT_VALUE(param));
     } else {
       Scm_Error(\"bad parameter for GL_LIGHT_MODEL_COLOR_CONTROL: %S, must be an exact small integer\", param);
     }
     break;
    default:
     glLightModeli(pname, !SCM_FALSEP(param));
     break;
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-material (face::<fixnum> pname::<fixnum> param)
  "switch (pname) {
   case GL_AMBIENT:; case GL_DIFFUSE:; case GL_SPECULAR:; case GL_EMISSION:;
   case GL_AMBIENT_AND_DIFFUSE:;
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
       glMaterialfv(face, pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
       glMaterialiv(face, pname, (GLint*)SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32 vector of length 4\", param);
     }
     break;
   case GL_COLOR_INDEXES:
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 3) {
       glMaterialfv(face, pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 3) {
       glMaterialiv(face, pname, (GLint*)SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32vector of length 3\", param);
     }
     break;
   default:
     if (SCM_REALP(param)) {
       glMaterialf(face, pname, (GLfloat)Scm_GetDouble(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be a real number.\", param);
     }
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-material (face::<fixnum> pname::<fixnum>)
  "switch (pname) {
   case GL_AMBIENT:; case GL_DIFFUSE:; case GL_SPECULAR:; case GL_EMISSION:;
     {
       ScmF32Vector *v = SCM_F32VECTOR(Scm_MakeF32Vector(4, 0.0));
       glGetMaterialfv(face, pname, SCM_F32VECTOR_ELEMENTS(v));
       SCM_RETURN(SCM_OBJ(v));
     }
   case GL_COLOR_INDEXES:
     {
       ScmS32Vector *v = SCM_S32VECTOR(Scm_MakeS32Vector(3, 0.0));
       glGetMaterialiv(face, pname, (GLint*)SCM_S32VECTOR_ELEMENTS(v));
       SCM_RETURN(SCM_OBJ(v));
     }
   case GL_SHININESS:
     {
       float v;
       glGetMaterialfv(face, pname, &v);
       SCM_RETURN(Scm_MakeFlonum((double)v));
     }
   default:
     Scm_Error(\"bad pname: %d\", pname);
     SCM_RETURN(SCM_UNDEFINED);
   }")

(define-cproc gl-color-material (face::<fixnum> mode::<fixnum>)
  ::<void> glColorMaterial)

;;=============================================================
;; Raster functions
;;

(define-cproc gl-pixel-zoom (xfactor::<real> yfactor::<real>)
  ::<void> glPixelZoom)

(define-cproc gl-pixel-store (pname::<fixnum> param)
  "if (SCM_EXACTP(param)) {
     glPixelStorei(pname, Scm_GetInteger(param));
   } else if (SCM_FLONUMP(param)) {
     glPixelStoref(pname, (float)SCM_FLONUM_VALUE(param));
   } else {
     Scm_Error(\"real number required for param, but got %S\", param);
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-pixel-transfer (pname::<fixnum> param)
  "if (SCM_BOOLP(param)) {
     glPixelTransferi(pname, SCM_BOOL_VALUE(param));
   } else if (SCM_EXACTP(param)) {
     glPixelTransferi(pname, Scm_GetInteger(param));
   } else if (SCM_FLONUMP(param)) {
     glPixelTransferf(pname, (GLfloat)SCM_FLONUM_VALUE(param));
   } else {
     Scm_Error(\"real number or boolean required for param, but got %S\", param);
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-pixel-map (map::<fixnum> values)
  "if (SCM_U32VECTORP(values)) {
    glPixelMapuiv(map, SCM_U32VECTOR_SIZE(values),
                  (GLuint*)SCM_U32VECTOR_ELEMENTS(values));
  } else if (SCM_U16VECTORP(values)) {
    glPixelMapusv(map, SCM_U16VECTOR_SIZE(values),
                  SCM_U16VECTOR_ELEMENTS(values));
  } else if (SCM_F32VECTORP(values)) {
    glPixelMapfv(map, SCM_F32VECTOR_SIZE(values),
                 SCM_F32VECTOR_ELEMENTS(values));
  } else {
     Scm_Error(\"map value vector must be u16, u32 or f32 vector, but got %S\",
               values);
  }
   SCM_RETURN(SCM_UNDEFINED);")

;; values must have enough size
(define-cproc gl-get-pixel-map! (map::<fixnum> values)
  "if (SCM_U32VECTORP(values)) {
    glGetPixelMapuiv(map, (GLuint*)SCM_U32VECTOR_ELEMENTS(values));
  } else if (SCM_U16VECTORP(values)) {
    glGetPixelMapusv(map, SCM_U16VECTOR_ELEMENTS(values));
  } else if (SCM_F32VECTORP(values)) {
    glGetPixelMapfv(map, SCM_F32VECTOR_ELEMENTS(values));
  } else {
     Scm_Error(\"map value vector must be u16, u32 or f32 vector, but got %S\",
               values);
  }
  SCM_RETURN(values);")

;; allocate the vector in it.  type can be a class 
;; <u32vector> (default), <u16vector> or <f32vector>
(define-cproc gl-get-pixel-map (map::<fixnum> &optional type)
  " int size; ScmObj vec = SCM_UNDEFINED;
  glGetIntegerv(map, &size);
  CHECK_ERROR(\"couldn't get pixel map size\");
  SCM_ASSERT(size >= 0);
  if (SCM_UNBOUNDP(type) || type == SCM_OBJ(SCM_CLASS_U32VECTOR)) {
    vec = Scm_MakeU32Vector(size, 0);
    glGetPixelMapuiv(map, (GLuint*)SCM_U32VECTOR_ELEMENTS(vec));
  } else if (type == SCM_OBJ(SCM_CLASS_U16VECTOR)) {
    vec = Scm_MakeU16Vector(size, 0);
    glGetPixelMapusv(map, SCM_U16VECTOR_ELEMENTS(vec));
  } else if (type == SCM_OBJ(SCM_CLASS_F32VECTOR)) {
    vec = Scm_MakeF32Vector(size, 0);
    glGetPixelMapfv(map, SCM_F32VECTOR_ELEMENTS(vec));
  } else {
     Scm_Error(\"pixel map vector class must be either <u32vector>, <u16vector> or <f32vector>, but got %S\", type);
  }
  SCM_RETURN(vec);")

(define-cproc gl-bitmap (width::<int> height::<int>
                         xbo::<float> ybo::<float>
                         xbi::<float> ybi::<float> bitmap)
  "if (!SCM_U8VECTORP(bitmap)) {
    Scm_Error(\"bitmap must be an u8vector, but got %S\", bitmap);
  }
  if (SCM_U8VECTOR_SIZE(bitmap) != ((width+7)/8)*height) {
    Scm_Error(\"size (width=%d, height=%d) doesn't match bitmap vector %S\",
              width, height, bitmap);
  }
  glBitmap(width, height, xbo, ybo, xbi, ybi, SCM_U8VECTOR_ELEMENTS(bitmap));
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-read-pixels (x::<fixnum> y::<fixnum>
                              width::<fixnum> height::<fixnum>
                              format::<fixnum> type::<fixnum>)
  "  int elttype, size, packed; ScmObj vec = SCM_UNDEFINED;
  size = Scm_GLPixelDataSize(width, height, format, type, &elttype, &packed);
  vec = Scm_GLAllocUVector(elttype, size);
  if (!SCM_UVECTORP(vec)) {
    Scm_Error(\"invalid format or type (%S, %S)\", format, type);
  }
  glReadPixels(x, y, width, height, format, type, SCM_UVECTOR_ELEMENTS(vec));
  SCM_RETURN(vec);")

; gl-read-pixels!

(define-cproc gl-draw-pixels (width::<fixnum> height::<fixnum>
                              format::<fixnum> type::<fixnum> pixels)
  ::<void>
  (let* ([elttype::int] [packed::int]
         [size::int (Scm_GLPixelDataSize width height format type
                                         (& elttype) (& packed))])
    (glDrawPixels width height format type
                  (Scm_GLPixelDataCheck pixels elttype size))))

(define-cproc gl-copy-pixels (x::<fixnum> y::<fixnum>
                              width::<fixnum> height::<fixnum> type::<fixnum>)
  ::<void> glCopyPixels)

;;=============================================================
;; Stenciling
;;

(define-cproc gl-stencil-func (func::<fixnum> ref::<int> mask::<uint>)
  ::<void> glStencilFunc)
(define-cproc gl-stencil-mask (mask::<uint>)
  ::<void> glStencilMask)
(define-cproc gl-stencil-op (func::<fixnum> zfail::<fixnum> zpass::<fixnum>)
  ::<void> glStencilOp)
(define-cproc gl-clear-stencil (s::<int>)
  ::<void> glClearStencil)

;;=============================================================
;; Texture mapping
;;

(define-cproc gl-tex-gen (coord::<fixnum> pname::<fixnum> param)
  "switch (pname) {
    case GL_TEXTURE_GEN_MODE:
      if (!SCM_INTP(param)) {
        Scm_Error(\"integer parameter required for GL_TEXTURE_GEN_MODE, but got %S\", param);
      }
      glTexGeni(coord, pname, SCM_INT_VALUE(param));
      break;
    case GL_OBJECT_PLANE:;
    case GL_EYE_PLANE:;
      if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
        glTexGenfv(coord, pname, SCM_F32VECTOR_ELEMENTS(param));
      } else if (SCM_F64VECTORP(param) && SCM_F64VECTOR_SIZE(param) == 4) {
        glTexGendv(coord, pname, SCM_F64VECTOR_ELEMENTS(param));
      } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
        glTexGeniv(coord, pname, (GLint*)SCM_S32VECTOR_ELEMENTS(param));
      } else {
        Scm_Error(\"s32, f32 or f64 vector of size 4 is required for parameter, but got %S\", param);
      }
      break;
     default:
      Scm_Error(\"unknown or unsupported glTexGen pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-env (target::<fixnum> pname::<fixnum> param)
  "switch (pname) {
    case GL_TEXTURE_ENV_MODE:
      if (SCM_INTP(param)) {
        glTexEnvi(target, pname, SCM_INT_VALUE(param));
      } else {
        Scm_Error(\"integer parameter required for GL_TEXTURE_ENV_MODE, but got %S\", param);
      }
      break;
    case GL_TEXTURE_ENV_COLOR:
      if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
        glTexEnvfv(target, pname, SCM_F32VECTOR_ELEMENTS(param));
      } else {
        Scm_Error(\"f32 vector of size 4 is required for GL_TEXTURE_ENV_COLOR parameter, but got %S\", param);
      }
      break;
    default:
      Scm_Error(\"unknown or unsupported glTexEnv pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-parameter (target::<fixnum> pname::<fixnum> param)
  "switch (pname) {
     case GL_TEXTURE_WRAP_S:;
     case GL_TEXTURE_WRAP_T:;
#if !defined(__CYGWIN__)
     case GL_TEXTURE_WRAP_R:;
     case GL_TEXTURE_BASE_LEVEL:;
     case GL_TEXTURE_MAX_LEVEL:;
#endif /*!defined(__CYGWIN__)*/
     case GL_TEXTURE_MAG_FILTER:;
     case GL_TEXTURE_MIN_FILTER:;
       if (SCM_INTP(param)) {
         glTexParameteri(target, pname, Scm_GetInteger(param));
       } else {
         Scm_Error(\"integer parameter required, but got %S\", param);
       }
       break;
     case GL_TEXTURE_PRIORITY:;
#if !defined(__CYGWIN__)
     case GL_TEXTURE_MIN_LOD:;
     case GL_TEXTURE_MAX_LOD:;
#endif /*!defined(__CYGWIN__)*/
       if (SCM_REALP(param)) {
         glTexParameterf(target, pname, (GLfloat)Scm_GetDouble(param));
       } else {
         Scm_Error(\"real parameter required, but got %S\", param);
       }
       break;
     case GL_TEXTURE_BORDER_COLOR:
       if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
         glTexParameterfv(target, pname, SCM_F32VECTOR_ELEMENTS(param));
       } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
         glTexParameteriv(target, pname, (GLint*)SCM_S32VECTOR_ELEMENTS(param));
       } else {
         Scm_Error(\"f32 or s32 vector parameter of size 4 required, but got %S\", param);
       }
       break;
     default:
       Scm_Error(\"unknown or unsupported glTexParameter pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-tex-parameter (target::<fixnum> pname::<fixnum>)
  " ScmObj vec; GLint i; GLfloat f;
  switch (pname) {
     case GL_TEXTURE_WRAP_S:;
     case GL_TEXTURE_WRAP_T:;
     case GL_TEXTURE_WRAP_R:;
     case GL_TEXTURE_BASE_LEVEL:;
     case GL_TEXTURE_MAX_LEVEL:;
     case GL_TEXTURE_MAG_FILTER:;
     case GL_TEXTURE_MIN_FILTER:;
       glGetTexParameteriv(target, pname, &i);
       SCM_RETURN(Scm_MakeInteger(i));
     case GL_TEXTURE_PRIORITY:;
     case GL_TEXTURE_MIN_LOD:;
     case GL_TEXTURE_MAX_LOD:;
       glGetTexParameterfv(target, pname, &f);
       SCM_RETURN(Scm_MakeFlonum((double)f));
     case GL_TEXTURE_BORDER_COLOR:
       vec = Scm_MakeF32Vector(4, 0.0);
       glGetTexParameterfv(target, pname, SCM_F32VECTOR_ELEMENTS(vec));
       SCM_RETURN(vec);
     default:
       Scm_Error(\"unknown or unsupported glTexParameter pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-tex-level-parameter (target::<fixnum> level::<fixnum>
                                          pname::<fixnum>)
  "GLint i;
   switch (pname) {
     case GL_TEXTURE_WIDTH:;
     case GL_TEXTURE_HEIGHT:;
     case GL_TEXTURE_DEPTH:;
     case GL_TEXTURE_BORDER:;
     case GL_TEXTURE_INTERNAL_FORMAT:;
     case GL_TEXTURE_RED_SIZE:;
     case GL_TEXTURE_GREEN_SIZE:;
     case GL_TEXTURE_BLUE_SIZE:;
     case GL_TEXTURE_ALPHA_SIZE:;
     case GL_TEXTURE_LUMINANCE_SIZE:;
     case GL_TEXTURE_INTENSITY_SIZE:;
       glGetTexLevelParameteriv(target, level, pname, &i);
       SCM_RETURN(Scm_MakeInteger(i));
     default:
       Scm_Error(\"unknown or unsupported glTexLevelParameter pname: %d\", pname);
       SCM_RETURN(SCM_UNDEFINED);
   }")

;; Caller must ensure vector has enough length, since we need to get
;; pixel store parameters to check that, which is expensive.
;; We allow #f to TEXELS just to allcate texture area (to be used
;; as a render target via framebuffer object).
(define-cproc gl-tex-image-1d (target::<fixnum> level::<fixnum>
                               internalformat::<fixnum>
                               width::<fixnum> border::<fixnum>
                               format::<fixnum> type::<fixnum> texels)
  "int elttype, size; void *texelptr;
  size = Scm_GLPixelDataSize(width, 1, format, type, &elttype, NULL);
  if (SCM_FALSEP(texels)) {
    texelptr = NULL;
  } else {
    texelptr = Scm_GLPixelDataCheck(texels, elttype, size);
    glTexImage1D(target, level, internalformat, width, border, format, type,
                 texelptr);
  }
  SCM_RETURN(SCM_UNDEFINED);")


;; Caller must ensure vector has enough length, since we need to get
;; pixel store parameters to check that, which is expensive.
;; We allow #f to TEXELS just to allcate texture area (to be used
;; as a render target via framebuffer object).
(define-cproc gl-tex-image-2d (target::<fixnum> level::<fixnum>
                               internalformat::<fixnum>
                               width::<fixnum> height::<fixnum>
                               border::<fixnum> format::<fixnum>
                               type::<fixnum> texels)
  "int elttype, size; void *texelptr;
  size = Scm_GLPixelDataSize(width, height, format, type, &elttype, NULL);
  if (SCM_FALSEP(texels)) {
    texelptr = NULL;
  } else {
    texelptr = Scm_GLPixelDataCheck(texels, elttype, size);
    glTexImage2D(target, level, internalformat, width, height, border, format, type, texelptr);
  }
  SCM_RETURN(SCM_UNDEFINED);")

; gl-get-tex-image

(define-cproc gl-gen-textures (size::<fixnum>)
  (when (<= size 0)
    (Scm_Error "size must be a positive integer, but got %d" size))
  (let* ([vec (Scm_MakeU32Vector size 0)])
    (glGenTextures size (cast GLuint* (SCM_U32VECTOR_ELEMENTS vec)))
    (result vec)))

(define-cproc gl-delete-textures (names::<u32vector>) ::<void>
  (glDeleteTextures (SCM_U32VECTOR_SIZE names)
                    (cast GLuint* (SCM_U32VECTOR_ELEMENTS names))))

(define-cproc gl-bind-texture (target::<fixnum> name::<int>) ::<void>
  glBindTexture)

(define-cproc gl-prioritize-textures (names::<u32vector>
                                      priorities::<f32vector>)
  ::<void>
  (let* ([n::int (SCM_U32VECTOR_SIZE names)])
    (when (!= n (SCM_F32VECTOR_SIZE priorities))
      (Scm_Error "priority vector length doesn't match \
                  the names vector length %d: %S" n priorities))
    (glPrioritizeTextures n (cast GLuint* (SCM_U32VECTOR_ELEMENTS names))
                          (SCM_F32VECTOR_ELEMENTS priorities))))

(define-cproc gl-are-textures-resident! (names::<u32vector>
                                         res::<gl-boolean-vector>)
  ::<boolean>
  (glAreTexturesResident (SCM_U32VECTOR_SIZE names)
                         (cast GLuint* (SCM_U32VECTOR_ELEMENTS names))
                         (SCM_GL_BOOLEAN_VECTOR_ELEMENTS res)))

(define-cproc gl-is-texture (name::<int>) ::<int> glIsTexture)

(define-cproc gl-tex-sub-image-1d (target::<fixnum> level::<fixnum>
                                   xoffset::<fixnum> width::<fixnum>
                                   format::<fixnum> type::<fixnum>
                                   texels)
  ::<void>
  (let* ([elttype::int]
         [size::int (Scm_GLPixelDataSize width 1 format type (& elttype) NULL)]
         [texelptr::void* (Scm_GLPixelDataCheck texels elttype size)])
    (when texelptr
      (glTexSubImage1D target level xoffset width format type texelptr))))

(define-cproc gl-tex-sub-image-2d (target::<fixnum> level::<fixnum>
                                   xoffset::<fixnum> yoffset::<fixnum>
                                   width::<fixnum> height::<fixnum>
                                   format::<fixnum> type::<fixnum>
                                   texels)
  ::<void>
  (let* ([elttype::int]
         [size::int
          (Scm_GLPixelDataSize width height format type (& elttype) NULL)]
         [texelptr::void* (Scm_GLPixelDataCheck texels elttype size)])
    (when texelptr
      (glTexSubImage2D target level xoffset yoffset width height
                       format type texelptr))))

(define-cproc gl-copy-tex-image-1d (target::<fixnum> level::<fixnum>
                                    internal-format::<fixnum>
                                    x::<fixnum> y::<fixnum>
                                    width::<fixnum> border::<fixnum>)
  ::<void> glCopyTexImage1D)

(define-cproc gl-copy-tex-image-2d (target::<fixnum> level::<fixnum>
                                    internal-format::<fixnum>
                                    x::<fixnum> y::<fixnum>
                                    width::<fixnum> height::<fixnum>
                                    border::<fixnum>)
  ::<void> glCopyTexImage2D)

(define-cproc gl-copy-tex-sub-image-1d (target::<fixnum> level::<fixnum>
                                        xoffset::<fixnum> x::<fixnum>
                                        y::<fixnum> width::<fixnum>)
  ::<void> glCopyTexSubImage1D)

(define-cproc gl-copy-tex-sub-image-2d (target::<fixnum> level::<fixnum>
                                        xoffset::<fixnum> yoffset::<fixnum>
                                        x::<fixnum> y::<fixnum>
                                        width::<fixnum> height::<fixnum>)
  ::<void> glCopyTexSubImage2D)

;;=============================================================
;; Evaluators
;;

; gl-map1
; gl-map2
; gl-get-map
; gl-eval-coord1
; gl-eval-coord2
; gl-map-grid
; gl-eval-point1
; gl-eval-point2
; gl-eval-mesh1
; gl-eval-mesh2

;;=============================================================
;; Fog
;;

(define-cproc gl-fog (pname::<fixnum> param) ::<void>
  (case pname
    [(GL_FOG_MODE GL_FOG_INDEX)
     (if (SCM_INTP param)
       (glFogi pname (SCM_INT_VALUE param))
       (Scm_Error "integer parameter required, but got %S" param))]
    [(GL_FOG_DENSITY GL_FOG_START GL_FOG_END)
     (if (SCM_REALP param)
       (glFogf pname (cast GLfloat (Scm_GetDouble param)))
       (Scm_Error "real number parameter required, but got %S" param))]
    [(GL_FOG_COLOR)
     (assert-vector-type&size f32vector 4 param)
     (glFogfv pname (SCM_F32VECTOR_ELEMENTS param))]
    [else (Scm_Error "unknown or unsupported glFog pname: %d" pname)]))

;;=============================================================
;; Selection and feedback
;;

(define-cproc gl-feedback-buffer (type::<fixnum>
                                  buffer::<f32vector>)
  ::<void>
  (glFeedbackBuffer (SCM_F32VECTOR_SIZE buffer) type
                    (SCM_F32VECTOR_ELEMENTS buffer)))

(define-cproc gl-select-buffer (buffer::<u32vector>) ::<void>
  (glSelectBuffer (SCM_U32VECTOR_SIZE buffer)
                  (cast GLuint* (SCM_U32VECTOR_ELEMENTS buffer))))

(define-cproc gl-pass-through (token::<float>) ::<void> glPassThrough)

(define-cproc gl-init-names () ::<void> glInitNames)
(define-cproc gl-load-name (name::<int>) ::<void> glLoadName)
(define-cproc gl-push-name (name::<int>) ::<void> glPushName)
(define-cproc gl-pop-name () ::<void> glPopName)

;; Local variables:
;; mode: scheme
;; end:
