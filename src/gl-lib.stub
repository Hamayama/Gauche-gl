;;;
;;; gl-lib.stub - glue functions for GL
;;;
;;;  Copyright (c) 2001-2008  Shiro Kawai  <shiro@acm.org>
;;;
;;;  Permission to use, copy, modify, distribute this software and
;;;  accompanying documentation for any purpose is hereby granted,
;;;  provided that existing copyright notices are retained in all
;;;  copies and that this notice is included verbatim in all
;;;  distributions.
;;;  This software is provided as is, without express or implied
;;;  warranty.  In no circumstances the author(s) shall be liable
;;;  for any damages arising out of the use of this software.
;;;
;;;  $Id: gl-lib.stub,v 1.47 2008-06-04 11:50:43 shirok Exp $
;;;

"
#include \"gauche-gl.h\"
#include \"gl-syms.h\"
"

;; The functions are ordered in the same way as Mesa's header file.

"#define CHECK_ERROR(msg__)                            \\
  do {                                                 \\
    GLenum e = glGetError();                           \\
    if (e != GL_NO_ERROR) {                            \\
      Scm_Error(\"%s: %s\", msg__, gluErrorString(e)); \\
    }                                                  \\
  } while (0)
"

;; NB: this should be taken care of by genstub.
(define-type <uvector> "ScmUVector*" "uniform vector"
  "SCM_UVECTORP" "SCM_UVECTOR")
(define-type <u32vector> "ScmU32Vector*" "u32vector"
  "SCM_U32VECTORP" "SCM_U32VECTOR")
(define-type <f32vector> "ScmF32Vector*" "f32vector"
  "SCM_F32VECTORP" "SCM_F32VECTOR")
(define-type <gl-boolean-vector> "ScmGLBooleanVector*" "GL boolean vector"
  "SCM_GL_BOOLEAN_VECTOR_P" "SCM_GL_BOOLEAN_VECTOR")

;;=============================================================
;; <gl-boolean-vector> stuff
;;

(define-cproc list->gl-boolean-vector (lis)
  (call "Scm_ListToGLBooleanVector"))

(define-cproc gl-boolean-vector (&rest lis)
  (call "Scm_ListToGLBooleanVector"))

(define-cproc gl-boolean-vector? (obj)
  (call <boolean> "SCM_GL_BOOLEAN_VECTOR_P"))

(define-cproc make-gl-boolean-vector (size::<uint>
                                      &optional (init::<boolean> #f))
  (call "Scm_MakeGLBooleanVector"))

(define-cproc gl-boolean-vector-copy (bv::<gl-boolean-vector>)
  "SCM_RETURN(Scm_MakeGLBooleanVectorFromArray(bv->size, bv->elements));")

(define-cproc gl-boolean-vector-ref (bv::<gl-boolean-vector>
                                     k::<int>
                                     &optional fallback)
  "if (k < 0 || k >= bv->size) {
    if (SCM_UNBOUNDP(fallback)) {
      Scm_Error(\"argument out of bound: %d\", k);
    }
    SCM_RETURN(fallback);
  } else {
    SCM_RETURN(SCM_MAKE_BOOL(bv->elements[k]));
  }")

(define-cproc gl-boolean-vector-set! (bv::<gl-boolean-vector>
                                      k::<int>
                                      value)
  "if (k < 0 || k >= bv->size) {
    Scm_Error(\"argument out of bound: %d\", k);
  } else {
    bv->elements[k] = SCM_FALSEP(value)? GL_FALSE : GL_TRUE;
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-boolean-vector-length (bv::<gl-boolean-vector>)
  "SCM_RETURN(SCM_MAKE_INT(bv->size));")

(define-cproc gl-boolean-vector-fill! (bv::<gl-boolean-vector> fill)
  "int i;
  GLboolean val = SCM_FALSEP(fill)? GL_FALSE : GL_TRUE;
  for (i=0; i<bv->size; i++) {
    bv->elements[i] = val;
  }
  SCM_RETURN(SCM_OBJ(bv));")

;;=============================================================
;; Miscellaneous
;;

(define-cproc gl-clear-index (c::<float>)
  (call <void> "glClearIndex"))

(define-cproc gl-clear-color (r::<float> g::<float> b::<float> a::<float>)
  (call <void> "glClearColor"))

(define-cproc gl-clear (mask::<uint>)
  (call <void> "glClear"))

(define-cproc gl-index-mask (mask::<uint>)
  (call <void> "glIndexMask"))

(define-cproc gl-color-mask (r::<boolean> g::<boolean> b::<boolean> a::<boolean>)
  (call <void> "glColorMask"))

(define-cproc gl-alpha-func (func::<fixnum> ref::<float>)
  (call <void> "glAlphaFunc"))

(define-cproc gl-blend-func (sfactor::<fixnum> dfactor::<fixnum>)
  (call <void> "glBlendFunc"))

(define-cproc gl-logic-op (opcode::<fixnum>)
  (call <void> "glLogicOp"))

(define-cproc gl-cull-face (mode::<fixnum>)
  (call <void> "glCullFace"))

(define-cproc gl-front-face (mode::<fixnum>)
  (call <void> "glFrontFace"))

(define-cproc gl-point-size (size::<float>)
  (call <void> "glPointSize"))

(define-cproc gl-line-width (width::<float>)
  (call <void> "glLineWidth"))

(define-cproc gl-line-stipple (factor::<fixnum> pat::<ushort>)
  (call <void> "glLineStipple"))

(define-cproc gl-polygon-mode (face::<fixnum> mode::<fixnum>)
  (call <void> "glPolygonMode"))

(define-cproc gl-polygon-offset (factor::<float> units::<float>)
  (call <void> "glPolygonOffset"))

(define-cproc gl-polygon-stipple (mask)
  "  if (!SCM_U8VECTORP(mask) || SCM_U8VECTOR_SIZE(mask) != 128) {
    Scm_Error(\"u8vector of size 128 required, but got %S\", mask);
  }
  glPolygonStipple(SCM_U8VECTOR_ELEMENTS(mask));
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-edge-flag (flag)
  "if (SCM_GL_BOOLEAN_VECTOR_P(flag)) {
     glEdgeFlagv(SCM_GL_BOOLEAN_VECTOR(flag)->elements);
   } else {
     glEdgeFlag(!SCM_FALSEP(flag));
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-scissor (x::<int> y::<int> width::<int> height::<int>)
  (call <void> "glScissor"))

(define-cproc gl-clip-plane (plane::<fixnum> equation)
  "if (!SCM_F64VECTORP(equation) || SCM_F64VECTOR_SIZE(equation) != 4) {
   Scm_Error(\"f64vector of size 4 required for EQUATION, but got %S\", equation);
  }
  glClipPlane(plane, SCM_F64VECTOR_ELEMENTS(equation));
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-clip-plane (plane::<fixnum>)
  "  ScmF64Vector *v = SCM_F64VECTOR(Scm_MakeF64Vector(4, 0.0));
  glGetClipPlane(plane, SCM_F64VECTOR_ELEMENTS(v));
  SCM_RETURN(SCM_OBJ(v));")

(define-cproc gl-draw-buffer (mode::<fixnum>)
  (call <void> "glDrawBuffer"))

(define-cproc gl-read-buffer (mode::<fixnum>)
  (call <void> "glReadBuffer"))

(define-cproc gl-enable (cap::<fixnum>)
  (call <void> "glEnable"))
  
(define-cproc gl-disable (cap::<fixnum>)
  (call <void> "glDisable"))

(define-cproc gl-is-enabled (cap::<fixnum>)
  (call <boolean> "glIsEnabled"))

(define-cproc gl-enable-client-state (cap::<fixnum>)
  (call <void> "glEnableClientState"))

(define-cproc gl-disable-client-state (cap::<fixnum>)
  (call <void> "glDisableClientState"))

;; Gauche-gl specific
(define-cproc gl-state-vector-size (state::<fixnum>)
  (call <int> "Scm_GLStateInfoSize"))

(define-cproc gl-get-boolean (state::<fixnum>)
  "int vsize = Scm_GLStateInfoSize(state);
  if (vsize <= 0)
    Scm_Error(\"you can't query state %x by glGetBooleanv\", state);
  if (vsize == 1) {
    GLboolean b;
    glGetBooleanv((GLenum)state, &b);
    SCM_RETURN(SCM_MAKE_BOOL(b));
  } else {
    ScmObj v = Scm_MakeGLBooleanVector(vsize, GL_FALSE);
    glGetBooleanv((GLenum)state, SCM_GL_BOOLEAN_VECTOR(v)->elements);
    SCM_RETURN(v);
  }")

(define-cproc gl-get-boolean! (vec state::<fixnum>)
  "int vsize;
  if (!SCM_GL_BOOLEAN_VECTOR_P(vec))
     Scm_Error(\"gl-boolean-vector required, but got %S\", vec);
  vsize = Scm_GLStateInfoSize(state);
  if (vsize != SCM_GL_BOOLEAN_VECTOR_SIZE(vec))
    Scm_Error(\"state %x needs a vector of size %d, but got %S\",
               state, vsize, vec);
  glGetBooleanv((GLenum)state, SCM_GL_BOOLEAN_VECTOR(vec)->elements);
  SCM_RETURN(SCM_OBJ(vec));")

(define-cproc gl-get-integer (state::<fixnum>)
  "int vsize = Scm_GLStateInfoSize(state);
  if (vsize <= 0)
    Scm_Error(\"you can't query state %x by glGetIntegerv\", state);
  if (vsize == 1) {
    GLint i;
    glGetIntegerv((GLenum)state, &i);
    SCM_RETURN(Scm_MakeInteger(i));
  } else {
    ScmS32Vector *v = SCM_S32VECTOR(Scm_MakeS32Vector(vsize, 0));
    glGetIntegerv((GLenum)state, (GLint*)SCM_S32VECTOR_ELEMENTS(v));
    SCM_RETURN(SCM_OBJ(v));
  }")

(define-cproc gl-get-integer! (vec state::<fixnum>)
  "int vsize;
  if (!SCM_S32VECTORP(vec)) Scm_Error(\"s32vector required, but got %S\", vec);
  vsize = Scm_GLStateInfoSize(state);
  if (vsize != SCM_S32VECTOR_SIZE(vec))
    Scm_Error(\"state %x needs a vector of size %d, but got %S\",
               state, vsize, vec);
  glGetIntegerv((GLenum)state, (GLint*)SCM_S32VECTOR_ELEMENTS(vec));
  SCM_RETURN(SCM_OBJ(vec));")

(define-cproc gl-get-float (state::<fixnum>)
  "int vsize = Scm_GLStateInfoSize(state);
  if (vsize <= 0)
    Scm_Error(\"you can't query state %x by glGetFloatv\", state);
  if (vsize == 1) {
    GLfloat v;
    glGetFloatv((GLenum)state, &v);
    SCM_RETURN(Scm_MakeFlonum((double)v));
  } else {
    ScmF32Vector *v = SCM_F32VECTOR(Scm_MakeF32Vector(vsize, 0));
    glGetFloatv((GLenum)state, SCM_F32VECTOR_ELEMENTS(v));
    SCM_RETURN(SCM_OBJ(v));
  }")

(define-cproc gl-get-float! (vec state::<fixnum>)
  "int vsize;
  if (!SCM_F32VECTORP(vec)) Scm_Error(\"s32vector required, but got %S\", vec);
  vsize = Scm_GLStateInfoSize(state);
  if (vsize != SCM_F32VECTOR_SIZE(vec))
    Scm_Error(\"state %x needs a vector of size %d, but got %S\",
               state, vsize, vec);
  glGetFloatv((GLenum)state, SCM_F32VECTOR_ELEMENTS(vec));
  SCM_RETURN(SCM_OBJ(vec));")

(define-cproc gl-get-double (state::<fixnum>)
  "int vsize = Scm_GLStateInfoSize(state);
  if (vsize <= 0)
    Scm_Error(\"you can't query state %x by glGetDoublev\", state);
  if (vsize == 1) {
    GLdouble v;
    glGetDoublev((GLenum)state, &v);
    SCM_RETURN(Scm_MakeFlonum(v));
  } else {
    ScmF64Vector *v = SCM_F64VECTOR(Scm_MakeF64Vector(vsize, 0));
    glGetDoublev((GLenum)state, SCM_F64VECTOR_ELEMENTS(v));
    SCM_RETURN(SCM_OBJ(v));
  }")

(define-cproc gl-get-double! (vec state::<fixnum>)
  "int vsize;
  if (!SCM_F64VECTORP(vec)) Scm_Error(\"s32vector required, but got %S\", vec);
  vsize = Scm_GLStateInfoSize(state);
  if (vsize != SCM_F64VECTOR_SIZE(vec))
    Scm_Error(\"state %x needs a vector of size %d, but got %S\",
               state, vsize, vec);
  glGetDoublev((GLenum)state, SCM_F64VECTOR_ELEMENTS(vec));
  SCM_RETURN(SCM_OBJ(vec));")

;; glGetPointerv

(define-cproc gl-push-attrib (mask::<ulong>)
  (call <void> "glPushAttrib"))

(define-cproc gl-pop-attrib ()
  (call <void> "glPopAttrib"))

(define-cproc gl-push-client-attrib (mask::<ulong>)
  (call <void> "glPushClientAttrib"))

(define-cproc gl-pop-client-attrib ()
  (call <void> "glPopClientAttrib"))

(define-cproc gl-render-mode (mode::<fixnum>)
  (call <int> "glRenderMode"))

(define-cproc gl-get-error ()
  (call <int> "glGetError"))

(define-cproc gl-get-string (name::<fixnum>)
  "const GLubyte *s = glGetString(name);
  if (s) SCM_RETURN(Scm_MakeString((const char*)s, -1, -1, SCM_MAKSTR_COPYING));
  else   SCM_RETURN(SCM_FALSE);")

(define-cproc gl-flush ()
  (call <void> "glFlush"))

(define-cproc gl-finish ()
  (call <void> "glFinish"))

(define-cproc gl-hint (target::<int> mode::<int>)
  (call <void> "glHint"))

;;=============================================================
;; Depth Buffer
;;

(define-cproc gl-clear-depth (depth::<real>)
  (call <void> "glClearDepth"))

(define-cproc gl-depth-func (func::<fixnum>)
  (call <void> "glDepthFunc"))

(define-cproc gl-depth-mask (flag::<boolean>)
  (call <void> "glDepthMask"))

(define-cproc gl-depth-range (nearv::<real> farv::<real>)
  (call <void> "glDepthRange"))

;;=============================================================
;; Accumulation Buffer
;;

(define-cproc gl-clear-accum (r::<real> g::<real> b::<real> a::<real>)
  (call <void> "glClearAccum"))

(define-cproc gl-accum (op::<fixnum> value::<real>)
  (call <void> "glAccum"))

;;=============================================================
;; Transformation
;;

(define-cproc gl-matrix-mode (mode::<fixnum>)
  (call <void> "glMatrixMode"))

(define-cproc gl-ortho (left::<real> right::<real>
                        bottom::<real> top::<real>
                        nearv::<real> farv::<real>)
  (call <void> "glOrtho"))

(define-cproc gl-frustum (left::<real> right::<real>
                          bottom::<real> top::<real>
                          nearv::<real> farv::<real>)
  (call <void> "glFrustum"))

(define-cproc gl-viewport (x::<fixnum> y::<fixnum>
                           width::<fixnum> height::<fixnum>)
  (call <void> "glViewport"))

(define-cproc gl-push-matrix ()
  (call <void> "glPushMatrix"))

(define-cproc gl-pop-matrix ()
  (call <void> "glPopMatrix"))

(define-cproc gl-load-identity ()
  (call <void> "glLoadIdentity"))

(define-cproc gl-load-matrix (m)
  "if (SCM_MATRIX4FP(m)) {
     glLoadMatrixf(SCM_MATRIX4F_D(m));
  } else if (SCM_F32VECTORP(m) && SCM_F32VECTOR_SIZE(m) == 16) {
     glLoadMatrixf(SCM_F32VECTOR_ELEMENTS(m));
  } else if (SCM_F64VECTORP(m) && SCM_F64VECTOR_SIZE(m) == 16) {
     glLoadMatrixd(SCM_F64VECTOR_ELEMENTS(m));
  } else {
     Scm_Error(\"matrix4f, or f32vector or f64vector of length 16 is required, but got %S\", m);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-mult-matrix (m)
  "if (SCM_MATRIX4FP(m)) {
     glMultMatrixf(SCM_MATRIX4F_D(m));
  } else if (SCM_F32VECTORP(m) && SCM_F32VECTOR_SIZE(m) == 16) {
     glMultMatrixf(SCM_F32VECTOR_ELEMENTS(m));
  } else if (SCM_F64VECTORP(m) && SCM_F64VECTOR_SIZE(m) == 16) {
     glMultMatrixd(SCM_F64VECTOR_ELEMENTS(m));
  } else {
     Scm_Error(\"matrix4f, or f32vector or f64vector of length 16 is required, but got %S\", m);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-rotate (angle::<real> x::<real> y::<real> z::<real>)
  (call <void> "glRotated"))

(define-cproc gl-scale (x::<real> y::<real> z::<real>)
  (call <void> "glScaled"))

(define-cproc gl-translate (x::<real> y::<real> z::<real>)
  (call <void> "glTranslated"))

;;=============================================================
;; Display lists
;;

(define-cproc gl-is-list (list::<int>)
  (call <boolean> "glIsList"))

(define-cproc gl-delete-lists (list::<int> range::<int>)
  (call <void> "glDeleteLists"))

(define-cproc gl-gen-lists (range::<int>)
  (call <ulong> "glGenLists"))

(define-cproc gl-new-list (list::<int> mode::<int>)
  (call <void> "glNewList"))

(define-cproc gl-end-list ()
  (call <void> "glEndList"))

(define-cproc gl-call-list (list::<int>)
  (call <void> "glCallList"))

;; this may be called as
;;  (gl-call-lists array)
;;  (gl-call-lists size array)
;;  (gl-call-lists size type array)
(define-cproc gl-call-lists (arg0 &optional arg1 arg2)
  "GLsizei size = 0;  
   int type = -1;
   ScmObj array, bad;
   if (SCM_UNBOUNDP(arg2)) {
     if (SCM_UNBOUNDP(arg1)) {
       /* single arg case */
       array = arg0;
     } else {
       /* double arg case */
       if (!SCM_INTP(arg0)) {
         bad = arg0; goto badarg;
       }
       size = SCM_INT_VALUE(arg0);
       array = arg1;
     }
   } else {
     /* triple arg case */
     if (!SCM_INTP(arg0)) {
       bad = arg0; goto badarg;
     }
     size = SCM_INT_VALUE(arg0);
     if (!SCM_INTP(arg1)) {
       bad = arg1; goto badarg;
     }
     type = SCM_INT_VALUE(arg1);
     array = arg2;
   }

   if (SCM_U8VECTORP(array)) {
     switch (type) {
       case -1:
         if (size == 0) size = SCM_U8VECTOR_SIZE(array);
         else if (SCM_U8VECTOR_SIZE(array) < size) goto nee;
         glCallLists(size, GL_UNSIGNED_BYTE, SCM_U8VECTOR_ELEMENTS(array));
         break;
       case GL_2_BYTES:
         if (size == 0) size = SCM_U8VECTOR_SIZE(array)/2;
         else if (SCM_U8VECTOR_SIZE(array)/2 < size) goto nee;
         glCallLists(size, GL_2_BYTES, SCM_U8VECTOR_ELEMENTS(array));
         break;
       case GL_3_BYTES:
         if (size == 0) size = SCM_U8VECTOR_SIZE(array)/3;
         else if (SCM_U8VECTOR_SIZE(array)/3 < size) goto nee;
         glCallLists(size, GL_3_BYTES, SCM_U8VECTOR_ELEMENTS(array));
         break;
       case GL_4_BYTES:
         if (size == 0) size = SCM_U8VECTOR_SIZE(array)/4;
         else if (SCM_U8VECTOR_SIZE(array)/4 < size) goto nee;
         glCallLists(size, GL_4_BYTES, SCM_U8VECTOR_ELEMENTS(array));
         break;
       default:
         goto badtype;
     }
   } else if (SCM_STRINGP(array)) {
     if (size == 0) size = SCM_STRING_SIZE(array);
     else if (SCM_STRING_SIZE(array) < size) goto nee;
     glCallLists(size, GL_UNSIGNED_BYTE, SCM_STRING_START(array));
   } else if (SCM_S8VECTORP(array)) {
     if (size == 0) size = SCM_S8VECTOR_SIZE(array);
     else if (SCM_S8VECTOR_SIZE(array) < size) goto nee;
     glCallLists(size, GL_BYTE, SCM_S8VECTOR_ELEMENTS(array));
   } else if (SCM_S16VECTORP(array)) {
     if (size == 0) size = SCM_S16VECTOR_SIZE(array);
     else if (SCM_S16VECTOR_SIZE(array) < size) goto nee;
     glCallLists(size, GL_SHORT, SCM_S16VECTOR_ELEMENTS(array));
   } else if (SCM_U16VECTORP(array)) {
     if (size == 0) size = SCM_U16VECTOR_SIZE(array);
     else if (SCM_U16VECTOR_SIZE(array) < size) goto nee;
     glCallLists(size, GL_UNSIGNED_SHORT, SCM_U16VECTOR_ELEMENTS(array));
   } else if (SCM_S32VECTORP(array)) {
     if (size == 0) size = SCM_S32VECTOR_SIZE(array);
     else if (SCM_S32VECTOR_SIZE(array) < size) goto nee;
     glCallLists(size, GL_INT, SCM_S32VECTOR_ELEMENTS(array));
   } else if (SCM_U32VECTORP(array)) {
     if (size == 0) size = SCM_U32VECTOR_SIZE(array);
     else if (SCM_U32VECTOR_SIZE(array) < size) goto nee;
     glCallLists(size, GL_UNSIGNED_INT, SCM_U32VECTOR_ELEMENTS(array));
   } else if (SCM_F32VECTORP(array)) {
     if (size == 0) size = SCM_F32VECTOR_SIZE(array);
     else if (SCM_F32VECTOR_SIZE(array) < size) goto nee;
     glCallLists(size, GL_INT, SCM_U32VECTOR_ELEMENTS(array));
   }
   SCM_RETURN(SCM_UNDEFINED);
  badarg:
   Scm_Error(\"bad argument to gl-call-lists: %S\", bad);
  nee:
   Scm_Error(\"not enough elements passed to gl-call-lists: %S\", array);
  badtype:
   Scm_Error(\"given type %d doesn't match the passed array (u8vector)\", type);
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-list-base (base::<int>)
  (call <void> "glListBase"))

;;=============================================================
;; Drawing functions
;;

(define-cproc gl-begin (mode::<int>)
  (call <void> "glBegin"))

(define-cproc gl-end ()
  (call <void> "glEnd"))

(define-cproc gl-vertex (v &rest args)
  "if (SCM_POINT4FP(v) || SCM_VECTOR4FP(v)) {
     glVertex3fv(SCM_VECTOR4F_D(v));
  } else if (SCM_F32VECTORP(v)) {
     switch (SCM_F32VECTOR_SIZE(v)) {
       case 3: glVertex3fv((GLfloat*)SCM_F32VECTOR_ELEMENTS(v)); break;
       case 2: glVertex2fv((GLfloat*)SCM_F32VECTOR_ELEMENTS(v)); break;
       case 4: glVertex4fv((GLfloat*)SCM_F32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_F64VECTORP(v)) {
     switch (SCM_F64VECTOR_SIZE(v)) {
       case 3: glVertex3dv((GLdouble*)SCM_F64VECTOR_ELEMENTS(v)); break;
       case 2: glVertex2dv((GLdouble*)SCM_F64VECTOR_ELEMENTS(v)); break;
       case 4: glVertex4dv((GLdouble*)SCM_F64VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S32VECTORP(v)) {
     switch (SCM_S32VECTOR_SIZE(v)) {
       case 3: glVertex3iv((GLint*)SCM_S32VECTOR_ELEMENTS(v)); break;
       case 2: glVertex2iv((GLint*)SCM_S32VECTOR_ELEMENTS(v)); break;
       case 4: glVertex4iv((GLint*)SCM_S32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S16VECTORP(v)) {
     switch (SCM_S16VECTOR_SIZE(v)) {
       case 3: glVertex3sv((GLshort*)SCM_S16VECTOR_ELEMENTS(v)); break;
       case 2: glVertex2sv((GLshort*)SCM_S16VECTOR_ELEMENTS(v)); break;
       case 4: glVertex4sv((GLshort*)SCM_S16VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else {
     double val[4];
     int nvals = Scm_GLGetDoubles(v, args, val, 4, 2);
     switch (nvals) {
       case 3: glVertex3dv(val); break;
       case 2: glVertex2dv(val); break;
       case 4: glVertex4dv(val); break;
     }
  }
  SCM_RETURN(SCM_UNDEFINED);
 badarg:
  Scm_Error(\"bad argument for v: %S, must be one of f32, f64, s32 or s16 vector of length 2, 3, or 4.\", v);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-normal (v &rest args)
  "if (SCM_VECTOR4FP(v)) {
     glNormal3fv(SCM_VECTOR4F_D(v));
  } else if (SCM_F32VECTORP(v) && SCM_F32VECTOR_SIZE(v) == 3) {
     glNormal3fv((GLfloat*)SCM_F32VECTOR_ELEMENTS(v));
  } else if (SCM_F64VECTORP(v) && SCM_F64VECTOR_SIZE(v) == 3) {
     glNormal3dv((GLdouble*)SCM_F64VECTOR_ELEMENTS(v));
  } else if (SCM_S32VECTORP(v) && SCM_S32VECTOR_SIZE(v) == 3) {
     glNormal3iv((GLint*)SCM_S32VECTOR_ELEMENTS(v));
  } else if (SCM_S16VECTORP(v) && SCM_S16VECTOR_SIZE(v) == 3) {
     glNormal3sv((GLshort*)SCM_S16VECTOR_ELEMENTS(v));
  } else {
     double val[3];
     Scm_GLGetDoubles(v, args, val, 3, 3);
     glNormal3dv(val);
  }
  SCM_RETURN(SCM_UNDEFINED);")

;; glIndex*

(define-cproc gl-color (v &rest args)
  "if (SCM_F32VECTORP(v)) {
     switch (SCM_F32VECTOR_SIZE(v)) {
       case 3: glColor3fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 4: glColor4fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_F64VECTORP(v)) {
     switch (SCM_F64VECTOR_SIZE(v)) {
       case 3: glColor3dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 4: glColor4dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_U8VECTORP(v)) {
     switch (SCM_U8VECTOR_SIZE(v)) {
       case 3: glColor3ubv(SCM_U8VECTOR_ELEMENTS(v)); break;
       case 4: glColor4ubv(SCM_U8VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_U16VECTORP(v)) {
     switch (SCM_U16VECTOR_SIZE(v)) {
       case 3: glColor3usv(SCM_U16VECTOR_ELEMENTS(v)); break;
       case 4: glColor4usv(SCM_U16VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_U32VECTORP(v)) {
     switch (SCM_U32VECTOR_SIZE(v)) {
       case 3: glColor3uiv((GLuint*)SCM_U32VECTOR_ELEMENTS(v)); break;
       case 4: glColor4uiv((GLuint*)SCM_U32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S8VECTORP(v)) {
     switch (SCM_S8VECTOR_SIZE(v)) {
       case 3: glColor3bv(SCM_S8VECTOR_ELEMENTS(v)); break;
       case 4: glColor4bv(SCM_S8VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S16VECTORP(v)) {
     switch (SCM_S16VECTOR_SIZE(v)) {
       case 3: glColor3sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 4: glColor4sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S32VECTORP(v)) {
     switch (SCM_S32VECTOR_SIZE(v)) {
       case 3: glColor3iv((GLint*)SCM_S32VECTOR_ELEMENTS(v)); break;
       case 4: glColor4iv((GLint*)SCM_S32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else {
     double val[4];
     int nvals = Scm_GLGetDoubles(v, args, val, 4, 3);
     switch (nvals) {
       case 3: glColor3dv(val); break;
       case 4: glColor4dv(val); break;
     }
  }
  SCM_RETURN(SCM_UNDEFINED);
 badarg:
  Scm_Error(\"bad argument for color: %S, must be an uniform vector of length 3 or 4\", v);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-coord (v &rest args)
  "if (SCM_F32VECTORP(v)) {
     switch (SCM_F32VECTOR_SIZE(v)) {
       case 2: glTexCoord2fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 1: glTexCoord1fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 3: glTexCoord3fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 4: glTexCoord4fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_F64VECTORP(v)) {
     switch (SCM_F64VECTOR_SIZE(v)) {
       case 2: glTexCoord2dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 1: glTexCoord1dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 3: glTexCoord3dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 4: glTexCoord4dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S32VECTORP(v)) {
     switch (SCM_S32VECTOR_SIZE(v)) {
       case 2: glTexCoord2iv((GLint*)SCM_S32VECTOR_ELEMENTS(v)); break;
       case 1: glTexCoord2iv((GLint*)SCM_S32VECTOR_ELEMENTS(v)); break;
       case 3: glTexCoord3iv((GLint*)SCM_S32VECTOR_ELEMENTS(v)); break;
       case 4: glTexCoord4iv((GLint*)SCM_S32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S16VECTORP(v)) {
     switch (SCM_S16VECTOR_SIZE(v)) {
       case 2: glTexCoord2sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 1: glTexCoord1sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 3: glTexCoord3sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 4: glTexCoord4sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else {
     double val[4];
     int nvals = Scm_GLGetDoubles(v, args, val, 4, 1);
     switch (nvals) {
       case 2: glTexCoord2dv(val); break;
       case 1: glTexCoord1dv(val); break;
       case 3: glTexCoord3dv(val); break;
       case 4: glTexCoord4dv(val); break;
     }
  }
  SCM_RETURN(SCM_UNDEFINED);
 badarg:
  Scm_Error(\"bad argument for v: %S, must be one of f32, f64, s32 or s16 vector of length 1, 2, 3, or 4.\", v);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-raster-pos (v &rest args)
  "if (SCM_F32VECTORP(v)) {
     switch (SCM_F32VECTOR_SIZE(v)) {
       case 3: glRasterPos3fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 2: glRasterPos2fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       case 4: glRasterPos4fv(SCM_F32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_F64VECTORP(v)) {
     switch (SCM_F64VECTOR_SIZE(v)) {
       case 3: glRasterPos3dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 2: glRasterPos2dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       case 4: glRasterPos4dv(SCM_F64VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S32VECTORP(v)) {
     switch (SCM_S32VECTOR_SIZE(v)) {
       case 3: glRasterPos3iv((GLint*)SCM_S32VECTOR_ELEMENTS(v)); break;
       case 2: glRasterPos2iv((GLint*)SCM_S32VECTOR_ELEMENTS(v)); break;
       case 4: glRasterPos4iv((GLint*)SCM_S32VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else if (SCM_S16VECTORP(v)) {
     switch (SCM_S16VECTOR_SIZE(v)) {
       case 3: glRasterPos3sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 2: glRasterPos2sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       case 4: glRasterPos4sv(SCM_S16VECTOR_ELEMENTS(v)); break;
       default: goto badarg;
     }
  } else {
     double val[4];
     int nvals = Scm_GLGetDoubles(v, args, val, 4, 2);
     switch (nvals) {
       case 3: glRasterPos3dv(val); break;
       case 2: glRasterPos2dv(val); break;
       case 4: glRasterPos4dv(val); break;
     }
  }
  SCM_RETURN(SCM_UNDEFINED);
 badarg:
  Scm_Error(\"bad argument for v: %S, must be one of f32, f64, s32 or s16 vector of length 2, 3, or 4.\", v);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-rect (v1 v2 &rest args)
  "if (SCM_POINT4FP(v1)) {
     if (!SCM_POINT4FP(v2)) goto badarg2;
     glRectfv(SCM_POINT4F_D(v1), SCM_POINT4F_D(v2));
  } else if (SCM_F32VECTORP(v1)) {
     if (SCM_F32VECTOR_SIZE(v1) != 2) goto badarg1;
     if (!SCM_F32VECTORP(v2) || SCM_F32VECTOR_SIZE(v2) != 2) goto badarg2;
     glRectfv(SCM_F32VECTOR_ELEMENTS(v1), SCM_F32VECTOR_ELEMENTS(v2));
  } else if (SCM_F64VECTORP(v1)) {
     if (SCM_F64VECTOR_SIZE(v1) != 2) goto badarg1;
     if (!SCM_F64VECTORP(v2) || SCM_F64VECTOR_SIZE(v2) != 2) goto badarg2;
     glRectdv(SCM_F64VECTOR_ELEMENTS(v1), SCM_F64VECTOR_ELEMENTS(v2));
  } else if (SCM_S32VECTORP(v1)) {
     if (SCM_S32VECTOR_SIZE(v1) != 2) goto badarg1;
     if (!SCM_S32VECTORP(v2) || SCM_S32VECTOR_SIZE(v2) != 2) goto badarg2;
     glRectiv((GLint*)SCM_S32VECTOR_ELEMENTS(v1), (GLint*)SCM_S32VECTOR_ELEMENTS(v2));
  } else if (SCM_S16VECTORP(v1)) {
     if (SCM_S16VECTOR_SIZE(v1) != 2) goto badarg1;
     if (!SCM_S16VECTORP(v2) || SCM_S16VECTOR_SIZE(v2) != 2) goto badarg2;
     glRectsv(SCM_S16VECTOR_ELEMENTS(v1), SCM_S16VECTOR_ELEMENTS(v2));
  } else {
     double val[4];
     Scm_GLGetDoubles(v1, Scm_Cons(v2, args), val, 4, 4);
     glRectd(val[0], val[1], val[2], val[3]);
  }
  SCM_RETURN(SCM_UNDEFINED);
 badarg1:
  Scm_Error(\"bad argument for v1: %S, must be one of f32, f64, s32 or s16 vector of length 2\", v1);
  SCM_RETURN(SCM_UNDEFINED);
 badarg2:
  Scm_Error(\"bad argument for v2: %S, must be one of f32, f64, s32 or s16 vector of length 2\", v2);
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Vertex Arrays
;;

;; NOTE: it is caller's responsibility to guarantee VEC has enough length.
;; GL doesn't have interface to specify the boundary, so I can't detect
;; invalid length vector.

;; Scheme version doesn't have TYPE - it's derived from vector type.
;; STRIDE argument refers to the # of elements, rather than bytes.

(define-cproc gl-vertex-pointer (size::<fixnum> vec
                                 &optional (stride::<fixnum> 0)
                                           (offset::<fixnum> 0))
  "if (size < 2 || size > 4) {
    Scm_Error(\"bad argument for size: %d, must be 2, 3 or 4\", size);
  }
  if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_POINT4F_ARRAY_P(vec)) {
    glVertexPointer(size, GL_FLOAT, stride*sizeof(GLfloat),
                    (void*)(SCM_POINT4F_ARRAY_D(vec)+offset));
  } else if (SCM_F32VECTORP(vec)) {
    glVertexPointer(size, GL_FLOAT, stride*sizeof(GLfloat),
                    (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glVertexPointer(size, GL_DOUBLE, stride*sizeof(GLdouble),
                    (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S32VECTORP(vec)) {
    glVertexPointer(size, GL_INT, stride*sizeof(GLint),
                    (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glVertexPointer(size, GL_SHORT, stride*sizeof(GLshort),
                    (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, s32 or s16vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-normal-pointer (vec
                                 &optional (stride::<fixnum> 0)
                                           (offset::<fixnum> 0))
  "if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_VECTOR4F_ARRAY_P(vec)) {
    glNormalPointer(GL_FLOAT, stride*sizeof(GLfloat),
                    (void*)(SCM_VECTOR4F_ARRAY_D(vec)+offset));
  } else if (SCM_F32VECTORP(vec)) {
    glNormalPointer(GL_FLOAT, stride*sizeof(GLfloat),
                    (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glNormalPointer(GL_DOUBLE, stride*sizeof(GLdouble),
                    (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S32VECTORP(vec)) {
    glNormalPointer(GL_INT, stride*sizeof(GLint),
                    (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glNormalPointer(GL_SHORT, stride*sizeof(GLshort),
                    (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S8VECTORP(vec)) {
    glNormalPointer(GL_BYTE, stride*sizeof(GLbyte),
                    (void*)(SCM_S8VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, s8, s16 or s32vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-color-pointer (size::<fixnum> vec
                                &optional (stride::<fixnum> 0)
                                          (offset::<fixnum> 0))
  "  if (size < 3 || size > 4) {
    Scm_Error(\"bad argument for size: %d, must be 2, 3 or 4\", size);
  }
  if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_F32VECTORP(vec)) {
    glColorPointer(size, GL_FLOAT, stride*sizeof(GLfloat),
                  (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glColorPointer(size, GL_DOUBLE, stride*sizeof(GLdouble),
                   (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_U32VECTORP(vec)) {
    glColorPointer(size, GL_UNSIGNED_INT, stride*sizeof(GLuint),
                   (void*)(SCM_U32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_U16VECTORP(vec)) {
    glColorPointer(size, GL_UNSIGNED_SHORT, stride*sizeof(GLushort),
                   (void*)(SCM_U16VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_U8VECTORP(vec)) {
    glColorPointer(size, GL_UNSIGNED_BYTE, stride*sizeof(GLubyte),
                   (void*)(SCM_U8VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S32VECTORP(vec)) {
    glColorPointer(size, GL_INT, stride*sizeof(GLint),
                   (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glColorPointer(size, GL_SHORT, stride*sizeof(GLshort),
                   (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S8VECTORP(vec)) {
    glColorPointer(size, GL_BYTE, stride*sizeof(GLbyte),
                   (void*)(SCM_S8VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, s8, u8, s16, u16, s32 or u32vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-index-pointer (vec
                                &optional (stride::<fixnum> 0)
                                          (offset::<fixnum> 0))
  "if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_S32VECTORP(vec)) {
    glIndexPointer(GL_INT, stride*sizeof(GLint),
                   (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glIndexPointer(GL_SHORT, stride*sizeof(GLshort),
                   (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_U8VECTORP(vec)) {
    glIndexPointer(GL_UNSIGNED_BYTE, stride*sizeof(GLubyte),
                   (void*)(SCM_U8VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F32VECTORP(vec)) {
    glIndexPointer(GL_FLOAT, stride*sizeof(GLfloat),
                   (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glIndexPointer(GL_DOUBLE, stride*sizeof(GLdouble),
                   (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, u8, s16 or s32 vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-coord-pointer (size::<fixnum> vec
                                    &optional (stride::<fixnum> 0)
                                              (offset::<fixnum> 0))
  "  if (size < 1 || size > 4) {
    Scm_Error(\"bad argument for size: %d, must be 1, 2, 3 or 4\", size);
  }
  if (stride < 0) {
    Scm_Error(\"bad argument for stride: %d, must be 0 or positive\", stride);
  }
  if (offset < 0) {
    Scm_Error(\"bad argument for offset: %d, must be 0 or positive\", offset);
  }
  if (SCM_F32VECTORP(vec)) {
    glTexCoordPointer(size, GL_FLOAT, stride*sizeof(GLfloat),
                     (void*)(SCM_F32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_F64VECTORP(vec)) {
    glTexCoordPointer(size, GL_DOUBLE, stride*sizeof(GLdouble),
                      (void*)(SCM_F64VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S32VECTORP(vec)) {
    glTexCoordPointer(size, GL_INT, stride*sizeof(GLint),
                      (void*)(SCM_S32VECTOR_ELEMENTS(vec)+offset));
  } else if (SCM_S16VECTORP(vec)) {
    glTexCoordPointer(size, GL_SHORT, stride*sizeof(GLshort),
                      (void*)(SCM_S16VECTOR_ELEMENTS(vec)+offset));
  } else {
    Scm_Error(\"bad argument for vec: %S, must be f32, f64, s16 or s32vector\", vec);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-edge-flag-pointer (vec
                                    &optional (stride::<fixnum> 0)
                                              (offset::<fixnum> 0))
  "if (SCM_GL_BOOLEAN_VECTOR_P(vec)) {
     glEdgeFlagPointer(stride, SCM_GL_BOOLEAN_VECTOR_ELEMENTS(vec) + offset);
   } else {
     Scm_Error(\"gl-boolean-vector required for vec, but got %S\", vec);
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-array-element (ith::<fixnum>)
  "glArrayElement(ith);
   SCM_RETURN(SCM_UNDEFINED);")

;; count and type is derived from indices vector
(define-cproc gl-draw-elements (mode::<fixnum> indices)
  "if (SCM_U8VECTORP(indices)) {
    glDrawElements(mode, SCM_U8VECTOR_SIZE(indices), GL_UNSIGNED_BYTE,
                   SCM_U8VECTOR_ELEMENTS(indices));
  } else if (SCM_U16VECTORP(indices)) {
    glDrawElements(mode, SCM_U16VECTOR_SIZE(indices), GL_UNSIGNED_SHORT,
                   SCM_U16VECTOR_ELEMENTS(indices));
  } else if (SCM_U32VECTORP(indices)) {
    glDrawElements(mode, SCM_U32VECTOR_SIZE(indices), GL_UNSIGNED_INT,
                   SCM_U32VECTOR_ELEMENTS(indices));
  } else {
    Scm_Error(\"bad argument for indices: %S, must be u8, u16 or u32vector\", indices);
  }
  SCM_RETURN(SCM_UNDEFINED);")


(define-cproc gl-draw-arrays (mode::<fixnum> first::<fixnum> count::<fixnum>)
  (call <void> "glDrawArrays"))

;; Note: we don't allow non-uniform vector for the interleaved arrays, so
;; the color component must be float.
(define-cproc gl-interleaved-arrays (format::<fixnum> vec
                                     &optional (stride::<fixnum> 0)
                                               (offset::<fixnum> 0))
  "  switch (format) {
     case GL_C4UB_V2F:; case GL_C4UB_V3F:; case GL_T2F_C4UB_V3F:
       Scm_Error(\"interleaved arrays with integer color component is not supported.\");
  }
  if (!SCM_F32VECTORP(vec)) {
    Scm_Error(\"bad argument for vec: %S, must be f32vector.\", vec);
  }
  glInterleavedArrays(format, stride * sizeof(GLfloat),
                      SCM_F32VECTOR_ELEMENTS(vec));
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Lighting
;;

(define-cproc gl-shade-model (mode::<fixnum>)
  (call <void> "glShadeModel"))

(define-cproc gl-light (light::<fixnum> pname::<fixnum> param)
  "switch (pname) {
   case GL_AMBIENT:; case GL_DIFFUSE:; case GL_SPECULAR:; case GL_POSITION:;
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
       glLightfv(light, pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
       glLightiv(light, pname, (GLint*)SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32 vector of length 4\", param);
     }
     break;
   case GL_SPOT_DIRECTION:
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 3) {
       glLightfv(light, pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 3) {
       glLightiv(light, pname, (GLint*)SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32 vector of length 3\", param);
     }
     break;
   default:
     if (SCM_REALP(param)) {
       glLightf(light, pname, (GLfloat)Scm_GetDouble(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be a real number.\", param);
     }
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-light (light::<fixnum> pname::<fixnum>)
  "switch (pname) {
   case GL_AMBIENT:; case GL_DIFFUSE:; case GL_SPECULAR:; case GL_POSITION:
     {
       ScmF32Vector *v = SCM_F32VECTOR(Scm_MakeF32Vector(4, 0.0));
       glGetLightfv(light, pname, SCM_F32VECTOR_ELEMENTS(v));
       SCM_RETURN(SCM_OBJ(v));
     }
   case GL_SPOT_DIRECTION:
     {
       ScmF32Vector *v = SCM_F32VECTOR(Scm_MakeF32Vector(3, 0.0));
       glGetLightfv(light, pname, SCM_F32VECTOR_ELEMENTS(v));
       SCM_RETURN(SCM_OBJ(v));
     }
   default:
     {
       float v;
       glGetLightfv(light, pname, &v);
       SCM_RETURN(Scm_MakeFlonum((double)v));
     }
   }")

(define-cproc gl-light-model (pname::<fixnum> param)
  "switch (pname) {
    case GL_LIGHT_MODEL_AMBIENT:
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
       glLightModelfv(pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
       glLightModeliv(pname, (GLint*)SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter for GL_LIGHT_MODEL_AMBIENT: %S, must be f32 or s32 vector of length 4\", param);
     }
     break;
    case GL_LIGHT_MODEL_COLOR_CONTROL:
     if (SCM_INTP(param)) {
       glLightModeli(pname, SCM_INT_VALUE(param));
     } else {
       Scm_Error(\"bad parameter for GL_LIGHT_MODEL_COLOR_CONTROL: %S, must be an exact small integer\", param);
     }
     break;
    default:
     glLightModeli(pname, !SCM_FALSEP(param));
     break;
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-material (face::<fixnum> pname::<fixnum> param)
  "switch (pname) {
   case GL_AMBIENT:; case GL_DIFFUSE:; case GL_SPECULAR:; case GL_EMISSION:;
   case GL_AMBIENT_AND_DIFFUSE:;
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
       glMaterialfv(face, pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
       glMaterialiv(face, pname, (GLint*)SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32 vector of length 4\", param);
     }
     break;
   case GL_COLOR_INDEXES:
     if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 3) {
       glMaterialfv(face, pname, SCM_F32VECTOR_ELEMENTS(param));
     } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 3) {
       glMaterialiv(face, pname, (GLint*)SCM_S32VECTOR_ELEMENTS(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be f32 or s32vector of length 3\", param);
     }
     break;
   default:
     if (SCM_REALP(param)) {
       glMaterialf(face, pname, (GLfloat)Scm_GetDouble(param));
     } else {
       Scm_Error(\"bad parameter: %S, must be a real number.\", param);
     }
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-material (face::<fixnum> pname::<fixnum>)
  "switch (pname) {
   case GL_AMBIENT:; case GL_DIFFUSE:; case GL_SPECULAR:; case GL_EMISSION:;
     {
       ScmF32Vector *v = SCM_F32VECTOR(Scm_MakeF32Vector(4, 0.0));
       glGetMaterialfv(face, pname, SCM_F32VECTOR_ELEMENTS(v));
       SCM_RETURN(SCM_OBJ(v));
     }
   case GL_COLOR_INDEXES:
     {
       ScmS32Vector *v = SCM_S32VECTOR(Scm_MakeS32Vector(3, 0.0));
       glGetMaterialiv(face, pname, (GLint*)SCM_S32VECTOR_ELEMENTS(v));
       SCM_RETURN(SCM_OBJ(v));
     }
   case GL_SHININESS:
     {
       float v;
       glGetMaterialfv(face, pname, &v);
       SCM_RETURN(Scm_MakeFlonum((double)v));
     }
   default:
     Scm_Error(\"bad pname: %d\", pname);
     SCM_RETURN(SCM_UNDEFINED);
   }")

(define-cproc gl-color-material (face::<fixnum> mode::<fixnum>)
  (call <void> "glColorMaterial"))

;;=============================================================
;; Raster functions
;;

(define-cproc gl-pixel-zoom (xfactor::<real> yfactor::<real>)
  (call <void> "glPixelZoom"))

(define-cproc gl-pixel-store (pname::<fixnum> param)
  "if (SCM_EXACTP(param)) {
     glPixelStorei(pname, Scm_GetInteger(param));
   } else if (SCM_FLONUMP(param)) {
     glPixelStoref(pname, (float)SCM_FLONUM_VALUE(param));
   } else {
     Scm_Error(\"real number required for param, but got %S\", param);
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-pixel-transfer (pname::<fixnum> param)
  "if (SCM_BOOLP(param)) {
     glPixelTransferi(pname, SCM_BOOL_VALUE(param));
   } else if (SCM_EXACTP(param)) {
     glPixelTransferi(pname, Scm_GetInteger(param));
   } else if (SCM_FLONUMP(param)) {
     glPixelTransferf(pname, (GLfloat)SCM_FLONUM_VALUE(param));
   } else {
     Scm_Error(\"real number or boolean required for param, but got %S\", param);
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-pixel-map (map::<fixnum> values)
  "if (SCM_U32VECTORP(values)) {
    glPixelMapuiv(map, SCM_U32VECTOR_SIZE(values),
                  (GLuint*)SCM_U32VECTOR_ELEMENTS(values));
  } else if (SCM_U16VECTORP(values)) {
    glPixelMapusv(map, SCM_U16VECTOR_SIZE(values),
                  SCM_U16VECTOR_ELEMENTS(values));
  } else if (SCM_F32VECTORP(values)) {
    glPixelMapfv(map, SCM_F32VECTOR_SIZE(values),
                 SCM_F32VECTOR_ELEMENTS(values));
  } else {
     Scm_Error(\"map value vector must be u16, u32 or f32 vector, but got %S\",
               values);
  }
   SCM_RETURN(SCM_UNDEFINED);")

;; values must have enough size
(define-cproc gl-get-pixel-map! (map::<fixnum> values)
  "if (SCM_U32VECTORP(values)) {
    glGetPixelMapuiv(map, (GLuint*)SCM_U32VECTOR_ELEMENTS(values));
  } else if (SCM_U16VECTORP(values)) {
    glGetPixelMapusv(map, SCM_U16VECTOR_ELEMENTS(values));
  } else if (SCM_F32VECTORP(values)) {
    glGetPixelMapfv(map, SCM_F32VECTOR_ELEMENTS(values));
  } else {
     Scm_Error(\"map value vector must be u16, u32 or f32 vector, but got %S\",
               values);
  }
  SCM_RETURN(values);")

;; allocate the vector in it.  type can be a class 
;; <u32vector> (default), <u16vector> or <f32vector>
(define-cproc gl-get-pixel-map (map::<fixnum> &optional type)
  " int size; ScmObj vec = SCM_UNDEFINED;
  glGetIntegerv(map, &size);
  CHECK_ERROR(\"couldn't get pixel map size\");
  SCM_ASSERT(size >= 0);
  if (SCM_UNBOUNDP(type) || type == SCM_OBJ(SCM_CLASS_U32VECTOR)) {
    vec = Scm_MakeU32Vector(size, 0);
    glGetPixelMapuiv(map, (GLuint*)SCM_U32VECTOR_ELEMENTS(vec));
  } else if (type == SCM_OBJ(SCM_CLASS_U16VECTOR)) {
    vec = Scm_MakeU16Vector(size, 0);
    glGetPixelMapusv(map, SCM_U16VECTOR_ELEMENTS(vec));
  } else if (type == SCM_OBJ(SCM_CLASS_F32VECTOR)) {
    vec = Scm_MakeF32Vector(size, 0);
    glGetPixelMapfv(map, SCM_F32VECTOR_ELEMENTS(vec));
  } else {
     Scm_Error(\"pixel map vector class must be either <u32vector>, <u16vector> or <f32vector>, but got %S\", type);
  }
  SCM_RETURN(vec);")

(define-cproc gl-bitmap (width::<int> height::<int>
                         xbo::<float> ybo::<float>
                         xbi::<float> ybi::<float> bitmap)
  "if (!SCM_U8VECTORP(bitmap)) {
    Scm_Error(\"bitmap must be an u8vector, but got %S\", bitmap);
  }
  if (SCM_U8VECTOR_SIZE(bitmap) != ((width+7)/8)*height) {
    Scm_Error(\"size (width=%d, height=%d) doesn't match bitmap vector %S\",
              width, height, bitmap);
  }
  glBitmap(width, height, xbo, ybo, xbi, ybi, SCM_U8VECTOR_ELEMENTS(bitmap));
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-read-pixels (x::<fixnum> y::<fixnum>
                              width::<fixnum> height::<fixnum>
                              format::<fixnum> type::<fixnum>)
  "  int elttype, size, packed; ScmObj vec = SCM_UNDEFINED;
  size = Scm_GLPixelDataSize(width, height, format, type, &elttype, &packed);
  vec = Scm_GLAllocUVector(elttype, size);
  if (!SCM_UVECTORP(vec)) {
    Scm_Error(\"invalid format or type (%S, %S)\", format, type);
  }
  glReadPixels(x, y, width, height, format, type, SCM_UVECTOR_ELEMENTS(vec));
  SCM_RETURN(vec);")

; gl-read-pixels!

(define-cproc gl-draw-pixels (width::<fixnum> height::<fixnum>
                              format::<fixnum> type::<fixnum> pixels)
  "  int elttype, size, packed;
  size = Scm_GLPixelDataSize(width, height, format, type, &elttype, &packed);
  glDrawPixels(width, height, format, type,
               Scm_GLPixelDataCheck(pixels, elttype, size));
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-copy-pixels (x::<fixnum> y::<fixnum>
                              width::<fixnum> height::<fixnum> type::<fixnum>)
  (call <void> "glCopyPixels"))

;;=============================================================
;; Stenciling
;;

(define-cproc gl-stencil-func (func::<fixnum> ref::<int> mask::<uint>)
  (call <void> "glStencilFunc"))

(define-cproc gl-stencil-mask (mask::<uint>)
  (call <void> "glStencilMask"))

(define-cproc gl-stencil-op (func::<fixnum> zfail::<fixnum> zpass::<fixnum>)
  (call <void> "glStencilOp"))

(define-cproc gl-clear-stencil (s::<int>)
  (call <void> "glClearStencil"))

;;=============================================================
;; Texture mapping
;;

(define-cproc gl-tex-gen (coord::<fixnum> pname::<fixnum> param)
  "switch (pname) {
    case GL_TEXTURE_GEN_MODE:
      if (!SCM_INTP(param)) {
        Scm_Error(\"integer parameter required for GL_TEXTURE_GEN_MODE, but got %S\", param);
      }
      glTexGeni(coord, pname, SCM_INT_VALUE(param));
      break;
    case GL_OBJECT_PLANE:;
    case GL_EYE_PLANE:;
      if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
        glTexGenfv(coord, pname, SCM_F32VECTOR_ELEMENTS(param));
      } else if (SCM_F64VECTORP(param) && SCM_F64VECTOR_SIZE(param) == 4) {
        glTexGendv(coord, pname, SCM_F64VECTOR_ELEMENTS(param));
      } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
        glTexGeniv(coord, pname, (GLint*)SCM_S32VECTOR_ELEMENTS(param));
      } else {
        Scm_Error(\"s32, f32 or f64 vector of size 4 is required for parameter, but got %S\", param);
      }
      break;
     default:
      Scm_Error(\"unknown or unsupported glTexGen pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-env (target::<fixnum> pname::<fixnum> param)
  "switch (pname) {
    case GL_TEXTURE_ENV_MODE:
      if (SCM_INTP(param)) {
        glTexEnvi(target, pname, SCM_INT_VALUE(param));
      } else {
        Scm_Error(\"integer parameter required for GL_TEXTURE_ENV_MODE, but got %S\", param);
      }
      break;
    case GL_TEXTURE_ENV_COLOR:
      if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
        glTexEnvfv(target, pname, SCM_F32VECTOR_ELEMENTS(param));
      } else {
        Scm_Error(\"f32 vector of size 4 is required for GL_TEXTURE_ENV_COLOR parameter, but got %S\", param);
      }
      break;
    default:
      Scm_Error(\"unknown or unsupported glTexEnv pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-parameter (target::<fixnum> pname::<fixnum> param)
  "switch (pname) {
     case GL_TEXTURE_WRAP_S:;
     case GL_TEXTURE_WRAP_T:;
#if !defined(__CYGWIN__)
     case GL_TEXTURE_WRAP_R:;
     case GL_TEXTURE_BASE_LEVEL:;
     case GL_TEXTURE_MAX_LEVEL:;
#endif /*!defined(__CYGWIN__)*/
     case GL_TEXTURE_MAG_FILTER:;
     case GL_TEXTURE_MIN_FILTER:;
       if (SCM_INTP(param)) {
         glTexParameteri(target, pname, Scm_GetInteger(param));
       } else {
         Scm_Error(\"integer parameter required, but got %S\", param);
       }
       break;
     case GL_TEXTURE_PRIORITY:;
#if !defined(__CYGWIN__)
     case GL_TEXTURE_MIN_LOD:;
     case GL_TEXTURE_MAX_LOD:;
#endif /*!defined(__CYGWIN__)*/
       if (SCM_REALP(param)) {
         glTexParameterf(target, pname, (GLfloat)Scm_GetDouble(param));
       } else {
         Scm_Error(\"real parameter required, but got %S\", param);
       }
       break;
     case GL_TEXTURE_BORDER_COLOR:
       if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
         glTexParameterfv(target, pname, SCM_F32VECTOR_ELEMENTS(param));
       } else if (SCM_S32VECTORP(param) && SCM_S32VECTOR_SIZE(param) == 4) {
         glTexParameteriv(target, pname, (GLint*)SCM_S32VECTOR_ELEMENTS(param));
       } else {
         Scm_Error(\"f32 or s32 vector parameter of size 4 required, but got %S\", param);
       }
       break;
     default:
       Scm_Error(\"unknown or unsupported glTexParameter pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-tex-parameter (target::<fixnum> pname::<fixnum>)
  " ScmObj vec; GLint i; GLfloat f;
  switch (pname) {
     case GL_TEXTURE_WRAP_S:;
     case GL_TEXTURE_WRAP_T:;
     case GL_TEXTURE_WRAP_R:;
     case GL_TEXTURE_BASE_LEVEL:;
     case GL_TEXTURE_MAX_LEVEL:;
     case GL_TEXTURE_MAG_FILTER:;
     case GL_TEXTURE_MIN_FILTER:;
       glGetTexParameteriv(target, pname, &i);
       SCM_RETURN(Scm_MakeInteger(i));
     case GL_TEXTURE_PRIORITY:;
     case GL_TEXTURE_MIN_LOD:;
     case GL_TEXTURE_MAX_LOD:;
       glGetTexParameterfv(target, pname, &f);
       SCM_RETURN(Scm_MakeFlonum((double)f));
     case GL_TEXTURE_BORDER_COLOR:
       vec = Scm_MakeF32Vector(4, 0.0);
       glGetTexParameterfv(target, pname, SCM_F32VECTOR_ELEMENTS(vec));
       SCM_RETURN(vec);
     default:
       Scm_Error(\"unknown or unsupported glTexParameter pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-get-tex-level-parameter (target::<fixnum> level::<fixnum>
                                          pname::<fixnum>)
  "GLint i;
   switch (pname) {
     case GL_TEXTURE_WIDTH:;
     case GL_TEXTURE_HEIGHT:;
     case GL_TEXTURE_DEPTH:;
     case GL_TEXTURE_BORDER:;
     case GL_TEXTURE_INTERNAL_FORMAT:;
     case GL_TEXTURE_RED_SIZE:;
     case GL_TEXTURE_GREEN_SIZE:;
     case GL_TEXTURE_BLUE_SIZE:;
     case GL_TEXTURE_ALPHA_SIZE:;
     case GL_TEXTURE_LUMINANCE_SIZE:;
     case GL_TEXTURE_INTENSITY_SIZE:;
       glGetTexLevelParameteriv(target, level, pname, &i);
       SCM_RETURN(Scm_MakeInteger(i));
     default:
       Scm_Error(\"unknown or unsupported glTexLevelParameter pname: %d\", pname);
       SCM_RETURN(SCM_UNDEFINED);
   }")

;; Caller must ensure vector has enough length, since we need to get
;; pixel store parameters to check that, which is expensive.
;; We allow #f to TEXELS just to allcate texture area (to be used
;; as a render target via framebuffer object).
(define-cproc gl-tex-image-1d (target::<fixnum> level::<fixnum>
                               internalformat::<fixnum>
                               width::<fixnum> border::<fixnum>
                               format::<fixnum> type::<fixnum> texels)
  "int elttype, size; void *texelptr;
  size = Scm_GLPixelDataSize(width, 1, format, type, &elttype, NULL);
  if (SCM_FALSEP(texels)) {
    texelptr = NULL;
  } else {
    texelptr = Scm_GLPixelDataCheck(texels, elttype, size);
    glTexImage1D(target, level, internalformat, width, border, format, type,
                 texelptr);
  }
  SCM_RETURN(SCM_UNDEFINED);")


;; Caller must ensure vector has enough length, since we need to get
;; pixel store parameters to check that, which is expensive.
;; We allow #f to TEXELS just to allcate texture area (to be used
;; as a render target via framebuffer object).
(define-cproc gl-tex-image-2d (target::<fixnum> level::<fixnum>
                               internalformat::<fixnum>
                               width::<fixnum> height::<fixnum>
                               border::<fixnum> format::<fixnum>
                               type::<fixnum> texels)
  "int elttype, size; void *texelptr;
  size = Scm_GLPixelDataSize(width, height, format, type, &elttype, NULL);
  if (SCM_FALSEP(texels)) {
    texelptr = NULL;
  } else {
    texelptr = Scm_GLPixelDataCheck(texels, elttype, size);
    glTexImage2D(target, level, internalformat, width, height, border, format, type, texelptr);
  }
  SCM_RETURN(SCM_UNDEFINED);")

; gl-get-tex-image

(define-cproc gl-gen-textures (size::<fixnum>)
  "ScmObj vec;
  if (size <= 0) Scm_Error(\"size must be a positive integer, but got %d\", size);
  vec = Scm_MakeU32Vector(size, 0);
  glGenTextures(size, (GLuint*)SCM_U32VECTOR_ELEMENTS(vec));
  SCM_RETURN(vec);")

(define-cproc gl-delete-textures (names)
  "if (!SCM_U32VECTORP(names)) Scm_Error(\"texture names must be an u32vector, but got %S\", names);
  glDeleteTextures(SCM_U32VECTOR_SIZE(names),
                   (GLuint*)SCM_U32VECTOR_ELEMENTS(names));
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-bind-texture (target::<fixnum> name::<int>)
  "glBindTexture(target, name);
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-prioritize-textures (names::<u32vector>
                                      priorities::<f32vector>)
  "int n = SCM_U32VECTOR_SIZE(names);
  if (n != SCM_F32VECTOR_SIZE(priorities)) {
    Scm_Error(\"priority vector length doesn't match the names vector length %d: %S\", n, priorities);
  }
  glPrioritizeTextures(n, (GLuint*)SCM_U32VECTOR_ELEMENTS(names), 
                       SCM_F32VECTOR_ELEMENTS(priorities));
  SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-are-textures-resident! (names::<u32vector>
                                         res::<gl-boolean-vector>)
  "GLboolean b; int n;
   n = SCM_U32VECTOR_SIZE(names);
   b = glAreTexturesResident(n, (GLuint*)SCM_U32VECTOR_ELEMENTS(names), 
                             SCM_GL_BOOLEAN_VECTOR_ELEMENTS(res));
   SCM_RETURN(SCM_MAKE_BOOL(b));")

(define-cproc gl-is-texture (name::<int>)
  "SCM_RETURN(SCM_MAKE_INT(glIsTexture(name)));")

(define-cproc gl-tex-sub-image-1d (target::<fixnum> level::<fixnum>
                                   xoffset::<fixnum> width::<fixnum>
                                   format::<fixnum> type::<fixnum>
                                   texels)
  "int elttype, size; void *texelptr;
   size = Scm_GLPixelDataSize(width, 1, format, type, &elttype, NULL);
   texelptr = Scm_GLPixelDataCheck(texels, elttype, size);
   if (texelptr) {
     glTexSubImage1D(target, level, xoffset, width, format, type, texelptr);
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-tex-sub-image-2d (target::<fixnum> level::<fixnum>
                                   xoffset::<fixnum> yoffset::<fixnum>
                                   width::<fixnum> height::<fixnum>
                                   format::<fixnum> type::<fixnum>
                                   texels)
  "int elttype, size; void *texelptr;
   size = Scm_GLPixelDataSize(width, height, format, type, &elttype, NULL);
   texelptr = Scm_GLPixelDataCheck(texels, elttype, size);
   if (texelptr) {
     glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, texelptr);
   }
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-copy-tex-image-1d (target::<fixnum> level::<fixnum>
                                    internal-format::<fixnum>
                                    x::<fixnum> y::<fixnum>
                                    width::<fixnum> border::<fixnum>)
  (call <void> "glCopyTexImage1D"))

(define-cproc gl-copy-tex-image-2d (target::<fixnum> level::<fixnum>
                                    internal-format::<fixnum>
                                    x::<fixnum> y::<fixnum>
                                    width::<fixnum> height::<fixnum>
                                    border::<fixnum>)
  (call <void> "glCopyTexImage2D"))

(define-cproc gl-copy-tex-sub-image-1d (target::<fixnum> level::<fixnum>
                                        xoffset::<fixnum> x::<fixnum>
                                        y::<fixnum> width::<fixnum>)
  (call <void> "glCopyTexSubImage1D"))

(define-cproc gl-copy-tex-sub-image-2d (target::<fixnum> level::<fixnum>
                                        xoffset::<fixnum> yoffset::<fixnum>
                                        x::<fixnum> y::<fixnum>
                                        width::<fixnum> height::<fixnum>)
  (call <void> "glCopyTexSubImage2D"))

;;=============================================================
;; Evaluators
;;

; gl-map1
; gl-map2
; gl-get-map
; gl-eval-coord1
; gl-eval-coord2
; gl-map-grid
; gl-eval-point1
; gl-eval-point2
; gl-eval-mesh1
; gl-eval-mesh2

;;=============================================================
;; Fog
;;

(define-cproc gl-fog (pname::<fixnum> param)
  "switch (pname) {
    case GL_FOG_MODE:;
    case GL_FOG_INDEX:;
      if (SCM_INTP(param)) {
        glFogi(pname, SCM_INT_VALUE(param));
      } else {
        Scm_Error(\"integer parameter required, but got %S\", param);
      }
      break;
    case GL_FOG_DENSITY:;
    case GL_FOG_START:;
    case GL_FOG_END:;
      if (SCM_REALP(param)) {
        glFogf(pname, (GLfloat)Scm_GetDouble(param));
      } else {
        Scm_Error(\"real number parameter required, but got %S\", param);
      }
      break;
    case GL_FOG_COLOR:
      if (SCM_F32VECTORP(param) && SCM_F32VECTOR_SIZE(param) == 4) {
        glFogfv(pname, SCM_F32VECTOR_ELEMENTS(param));
      } else {
        Scm_Error(\"f32 vector of size 4 is required, but got %S\", param);
      }
      break;
    default:
      Scm_Error(\"unknown or unsupported glFog pname: %d\", pname);
  }
  SCM_RETURN(SCM_UNDEFINED);")

;;=============================================================
;; Selection and feedback
;;

(define-cproc gl-feedback-buffer (type::<fixnum>
                                  buffer::<f32vector>)
  "glFeedbackBuffer(SCM_F32VECTOR_SIZE(buffer), type,
                    SCM_F32VECTOR_ELEMENTS(buffer));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-select-buffer (buffer::<u32vector>)
  "glSelectBuffer(SCM_U32VECTOR_SIZE(buffer), 
                  (GLuint*)SCM_U32VECTOR_ELEMENTS(buffer));
   SCM_RETURN(SCM_UNDEFINED);")

(define-cproc gl-pass-through (token::<float>)
  (call <void> "glPassThrough"))

(define-cproc gl-init-names ()
  (call <void> "glInitNames"))

(define-cproc gl-load-name (name::<int>)
  (call <void> "glLoadName"))

(define-cproc gl-push-name (name::<int>)
  (call <void> "glPushName"))

(define-cproc gl-pop-name ()
  (call <void> "glPopName"))

;; Local variables:
;; mode: scheme
;; end:
